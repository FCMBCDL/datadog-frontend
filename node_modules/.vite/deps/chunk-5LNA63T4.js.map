{
  "version": 3,
  "sources": ["../../@datadog/browser-core/src/tools/display.ts", "../../@datadog/browser-core/src/tools/utils/numberUtils.ts", "../../@datadog/browser-core/src/tools/utils/timeUtils.ts", "../../@datadog/browser-core/src/tools/getGlobalObject.ts", "../../@datadog/browser-core/src/tools/monitor.ts", "../../@datadog/browser-core/src/tools/getZoneJsOriginalValue.ts", "../../@datadog/browser-core/src/tools/timer.ts", "../../@datadog/browser-core/src/tools/utils/byteUtils.ts", "../../@datadog/browser-core/src/tools/utils/responseUtils.ts", "../../@datadog/browser-core/src/domain/error/error.types.ts", "../../@datadog/browser-core/src/transport/sendWithRetryStrategy.ts", "../../@datadog/browser-core/src/transport/httpRequest.ts", "../../@datadog/browser-core/src/transport/eventBridge.ts", "../../@datadog/browser-core/src/browser/addEventListener.ts", "../../@datadog/browser-core/src/tools/utils/polyfills.ts", "../../@datadog/browser-core/src/tools/observable.ts", "../../@datadog/browser-core/src/browser/pageMayExitObservable.ts", "../../@datadog/browser-core/src/tools/utils/functionUtils.ts", "../../@datadog/browser-core/src/tools/serialisation/jsonStringify.ts", "../../@datadog/browser-core/src/transport/batch.ts", "../../@datadog/browser-core/src/transport/flushController.ts", "../../@datadog/browser-core/src/transport/startBatchWithReplica.ts", "../../@datadog/browser-core/src/tools/serialisation/sanitize.ts", "../../@datadog/browser-core/src/tools/stackTrace/computeStackTrace.ts", "../../@datadog/browser-core/src/tools/stackTrace/handlingStack.ts", "../../@datadog/browser-core/src/domain/error/error.ts", "../../@datadog/browser-core/src/tools/utils/objectUtils.ts", "../../@datadog/browser-core/src/tools/experimentalFeatures.ts", "../../@datadog/browser-core/src/domain/intakeSites.ts", "../../@datadog/browser-core/src/tools/sendToExtension.ts", "../../@datadog/browser-core/src/tools/utils/typeUtils.ts", "../../@datadog/browser-core/src/tools/mergeInto.ts", "../../@datadog/browser-core/src/domain/connectivity/connectivity.ts", "../../@datadog/browser-core/src/tools/utils/arrayUtils.ts", "../../@datadog/browser-core/src/tools/boundedBuffer.ts", "../../@datadog/browser-core/src/domain/telemetry/rawTelemetryEvent.types.ts", "../../@datadog/browser-core/src/domain/telemetry/telemetry.ts", "../../@datadog/browser-core/src/tools/catchUserErrors.ts", "../../@datadog/browser-core/src/tools/utils/stringUtils.ts", "../../@datadog/browser-core/src/tools/utils/browserDetection.ts", "../../@datadog/browser-core/src/browser/cookie.ts", "../../@datadog/browser-core/src/domain/session/storeStrategies/sessionStoreStrategy.ts", "../../@datadog/browser-core/src/domain/session/sessionConstants.ts", "../../@datadog/browser-core/src/domain/session/sessionStateValidation.ts", "../../@datadog/browser-core/src/domain/session/sessionState.ts", "../../@datadog/browser-core/src/domain/session/oldCookiesMigration.ts", "../../@datadog/browser-core/src/domain/session/storeStrategies/sessionInCookie.ts", "../../@datadog/browser-core/src/domain/session/storeStrategies/sessionInLocalStorage.ts", "../../@datadog/browser-core/src/domain/session/sessionStoreOperations.ts", "../../@datadog/browser-core/src/domain/session/sessionStore.ts", "../../@datadog/browser-core/src/domain/trackingConsent.ts", "../../@datadog/browser-core/src/tools/matchOption.ts", "../../@datadog/browser-core/src/domain/extension/extensionUtils.ts", "../../@datadog/browser-core/src/domain/allowedTrackingOrigins.ts", "../../@datadog/browser-core/src/tools/utils/urlPolyfill.ts", "../../@datadog/browser-core/src/domain/configuration/endpointBuilder.ts", "../../@datadog/browser-core/src/domain/configuration/tags.ts", "../../@datadog/browser-core/src/domain/configuration/transportConfiguration.ts", "../../@datadog/browser-core/src/domain/configuration/configuration.ts", "../../@datadog/browser-core/src/boot/init.ts", "../../@datadog/browser-core/src/tools/instrumentMethod.ts", "../../@datadog/browser-core/src/domain/error/trackRuntimeError.ts", "../../@datadog/browser-core/src/boot/displayAlreadyInitializedError.ts", "../../@datadog/browser-core/src/domain/report/reportObservable.ts", "../../@datadog/browser-core/src/tools/valueHistory.ts", "../../@datadog/browser-core/src/domain/synthetics/syntheticsWorkerValues.ts", "../../@datadog/browser-core/src/domain/session/sessionManager.ts", "../../@datadog/browser-core/src/tools/encoder.ts", "../../@datadog/browser-core/src/tools/abstractLifeCycle.ts", "../../@datadog/browser-core/src/domain/eventRateLimiter/createEventRateLimiter.ts", "../../@datadog/browser-core/src/browser/runOnReadyState.ts", "../../@datadog/browser-core/src/browser/xhrObservable.ts", "../../@datadog/browser-core/src/browser/fetchObservable.ts", "../../@datadog/browser-core/src/tools/requestIdleCallback.ts", "../../@datadog/browser-core/src/tools/taskQueue.ts", "../../@datadog/browser-core/src/domain/console/consoleObservable.ts", "../../@datadog/browser-core/src/domain/context/contextUtils.ts", "../../@datadog/browser-core/src/domain/context/contextManager.ts", "../../@datadog/browser-core/src/domain/context/defineContextMethod.ts", "../../@datadog/browser-core/src/domain/context/storeContextManager.ts", "../../@datadog/browser-core/src/tools/abstractHooks.ts", "../../@datadog/browser-core/src/domain/contexts/accountContext.ts", "../../@datadog/browser-core/src/domain/contexts/globalContext.ts", "../../@datadog/browser-core/src/domain/contexts/userContext.ts", "../../@datadog/browser-core/src/domain/context/contextConstants.ts", "../../@datadog/browser-core/src/tools/readBytesFromStream.ts", "../../@datadog/browser-core/src/domain/resourceUtils.ts", "../../@datadog/browser-rum-core/src/rawRumEvent.types.ts", "../../@datadog/browser-rum-core/src/domain/vital/vitalCollection.ts", "../../@datadog/browser-rum-core/src/domain/plugins.ts", "../../@datadog/browser-rum-core/src/domain/sampler/sampler.ts", "../../@datadog/browser-rum-core/src/domain/tracing/identifier.ts", "../../@datadog/browser-rum-core/src/domain/tracing/tracer.ts", "../../@datadog/browser-rum-core/src/domain/configuration/configuration.ts", "../../@datadog/browser-rum-core/src/domain/configuration/remoteConfiguration.ts", "../../@datadog/browser-rum-core/src/boot/preStartRum.ts", "../../@datadog/browser-rum-core/src/boot/rumPublicApi.ts", "../../@datadog/browser-rum-core/src/domain/resource/resourceUtils.ts", "../../@datadog/browser-rum-core/src/browser/firstInputPolyfill.ts", "../../@datadog/browser-rum-core/src/browser/performanceObservable.ts", "../../@datadog/browser-rum-core/src/browser/domMutationObservable.ts", "../../@datadog/browser-rum-core/src/browser/windowOpenObservable.ts", "../../@datadog/browser-rum-core/src/domain/contexts/internalContext.ts", "../../@datadog/browser-rum-core/src/domain/lifeCycle.ts", "../../@datadog/browser-rum-core/src/domain/contexts/viewHistory.ts", "../../@datadog/browser-rum-core/src/domain/requestCollection.ts", "../../@datadog/browser-rum-core/src/domain/discardNegativeDuration.ts", "../../@datadog/browser-rum-core/src/domain/trackEventCounts.ts", "../../@datadog/browser-rum-core/src/browser/htmlDomUtils.ts", "../../@datadog/browser-rum-core/src/domain/waitPageActivityEnd.ts", "../../@datadog/browser-rum-core/src/domain/privacy.ts", "../../@datadog/browser-rum-core/src/domain/action/getActionNameFromElement.ts", "../../@datadog/browser-rum-core/src/domain/getSelectorFromElement.ts", "../../@datadog/browser-rum-core/src/domain/action/clickChain.ts", "../../@datadog/browser-rum-core/src/domain/action/listenActionEvents.ts", "../../@datadog/browser-rum-core/src/domain/action/computeFrustration.ts", "../../@datadog/browser-rum-core/src/domain/action/interactionSelectorCache.ts", "../../@datadog/browser-rum-core/src/domain/action/trackClickActions.ts", "../../@datadog/browser-rum-core/src/domain/action/actionCollection.ts", "../../@datadog/browser-rum-core/src/domain/error/trackConsoleError.ts", "../../@datadog/browser-rum-core/src/domain/error/trackReportError.ts", "../../@datadog/browser-rum-core/src/domain/error/errorCollection.ts", "../../@datadog/browser-rum-core/src/domain/resource/matchRequestResourceEntry.ts", "../../@datadog/browser-rum-core/src/domain/tracing/getDocumentTraceId.ts", "../../@datadog/browser-rum-core/src/browser/performanceUtils.ts", "../../@datadog/browser-rum-core/src/domain/resource/retrieveInitialDocumentResourceTiming.ts", "../../@datadog/browser-rum-core/src/domain/resource/resourceCollection.ts", "../../@datadog/browser-rum-core/src/domain/view/trackViewEventCounts.ts", "../../@datadog/browser-rum-core/src/domain/view/viewMetrics/trackFirstContentfulPaint.ts", "../../@datadog/browser-rum-core/src/domain/view/viewMetrics/trackFirstInput.ts", "../../@datadog/browser-rum-core/src/domain/view/viewMetrics/trackNavigationTimings.ts", "../../@datadog/browser-rum-core/src/domain/view/viewMetrics/trackLargestContentfulPaint.ts", "../../@datadog/browser-rum-core/src/domain/view/viewMetrics/trackFirstHidden.ts", "../../@datadog/browser-rum-core/src/domain/view/viewMetrics/trackInitialViewMetrics.ts", "../../@datadog/browser-rum-core/src/domain/view/viewMetrics/getClsAttributionImpactedArea.ts", "../../@datadog/browser-rum-core/src/domain/view/viewMetrics/trackCumulativeLayoutShift.ts", "../../@datadog/browser-rum-core/src/domain/view/viewMetrics/interactionCountPolyfill.ts", "../../@datadog/browser-rum-core/src/domain/view/viewMetrics/trackInteractionToNextPaint.ts", "../../@datadog/browser-rum-core/src/domain/view/viewMetrics/trackLoadingTime.ts", "../../@datadog/browser-rum-core/src/browser/scroll.ts", "../../@datadog/browser-rum-core/src/browser/viewportObservable.ts", "../../@datadog/browser-rum-core/src/domain/view/viewMetrics/trackScrollMetrics.ts", "../../@datadog/browser-rum-core/src/domain/view/viewMetrics/trackCommonViewMetrics.ts", "../../@datadog/browser-rum-core/src/domain/view/bfCacheSupport.ts", "../../@datadog/browser-rum-core/src/domain/view/viewMetrics/trackBfcacheMetrics.ts", "../../@datadog/browser-rum-core/src/domain/view/trackViews.ts", "../../@datadog/browser-rum-core/src/domain/view/viewCollection.ts", "../../@datadog/browser-rum-core/src/domain/rumSessionManager.ts", "../../@datadog/browser-rum-core/src/transport/startRumBatch.ts", "../../@datadog/browser-rum-core/src/transport/startRumEventBridge.ts", "../../@datadog/browser-rum-core/src/domain/contexts/urlContexts.ts", "../../@datadog/browser-rum-core/src/browser/locationChangeObservable.ts", "../../@datadog/browser-rum-core/src/domain/contexts/featureFlagContext.ts", "../../@datadog/browser-rum-core/src/domain/startCustomerDataTelemetry.ts", "../../@datadog/browser-rum-core/src/domain/contexts/pageStateHistory.ts", "../../@datadog/browser-rum-core/src/domain/contexts/displayContext.ts", "../../@datadog/browser-rum-core/src/browser/cookieObservable.ts", "../../@datadog/browser-rum-core/src/domain/contexts/ciVisibilityContext.ts", "../../@datadog/browser-rum-core/src/domain/longAnimationFrame/longAnimationFrameCollection.ts", "../../@datadog/browser-rum-core/src/domain/longTask/longTaskCollection.ts", "../../@datadog/browser-rum-core/src/domain/contexts/syntheticsContext.ts", "../../@datadog/browser-rum-core/src/domain/limitModification.ts", "../../@datadog/browser-rum-core/src/domain/assembly.ts", "../../@datadog/browser-rum-core/src/domain/contexts/sessionContext.ts", "../../@datadog/browser-rum-core/src/domain/contexts/connectivityContext.ts", "../../@datadog/browser-rum-core/src/domain/contexts/defaultContext.ts", "../../@datadog/browser-rum-core/src/domain/hooks.ts", "../../@datadog/browser-rum-core/src/domain/event/eventCollection.ts", "../../@datadog/browser-rum-core/src/boot/startRum.ts", "../../@datadog/browser-rum-core/src/domain/getSessionReplayUrl.ts"],
  "sourcesContent": ["/* eslint-disable local-rules/disallow-side-effects */\n/**\n * Keep references on console methods to avoid triggering patched behaviors\n *\n * NB: in some setup, console could already be patched by another SDK.\n * In this case, some display messages can be sent by the other SDK\n * but we should be safe from infinite loop nonetheless.\n */\n\nexport const ConsoleApiName = {\n  log: 'log',\n  debug: 'debug',\n  info: 'info',\n  warn: 'warn',\n  error: 'error',\n} as const\n\nexport type ConsoleApiName = (typeof ConsoleApiName)[keyof typeof ConsoleApiName]\n\ninterface Display {\n  debug: typeof console.debug\n  log: typeof console.log\n  info: typeof console.info\n  warn: typeof console.warn\n  error: typeof console.error\n}\n\n/**\n * When building JS bundles, some users might use a plugin[1] or configuration[2] to remove\n * \"console.*\" references. This causes some issue as we expect `console.*` to be defined.\n * As a workaround, let's use a variable alias, so those expressions won't be taken into account by\n * simple static analysis.\n *\n * [1]: https://babeljs.io/docs/babel-plugin-transform-remove-console/\n * [2]: https://github.com/terser/terser#compress-options (look for drop_console)\n */\nexport const globalConsole = console\n\nexport const originalConsoleMethods = {} as Display\nObject.keys(ConsoleApiName).forEach((name) => {\n  originalConsoleMethods[name as ConsoleApiName] = globalConsole[name as ConsoleApiName]\n})\n\nconst PREFIX = 'Datadog Browser SDK:'\n\nexport const display: Display = {\n  debug: originalConsoleMethods.debug.bind(globalConsole, PREFIX),\n  log: originalConsoleMethods.log.bind(globalConsole, PREFIX),\n  info: originalConsoleMethods.info.bind(globalConsole, PREFIX),\n  warn: originalConsoleMethods.warn.bind(globalConsole, PREFIX),\n  error: originalConsoleMethods.error.bind(globalConsole, PREFIX),\n}\n\nexport const DOCS_ORIGIN = 'https://docs.datadoghq.com'\nexport const DOCS_TROUBLESHOOTING = `${DOCS_ORIGIN}/real_user_monitoring/browser/troubleshooting`\nexport const MORE_DETAILS = 'More details:'\n", "/**\n * Return true if the draw is successful\n * @param threshold between 0 and 100\n */\nexport function performDraw(threshold: number): boolean {\n  return threshold !== 0 && Math.random() * 100 <= threshold\n}\n\nexport function round(num: number, decimals: 0 | 1 | 2 | 3 | 4) {\n  return +num.toFixed(decimals)\n}\n\nexport function isPercentage(value: unknown) {\n  return isNumber(value) && value >= 0 && value <= 100\n}\n\nexport function isNumber(value: unknown): value is number {\n  return typeof value === 'number'\n}\n", "import { isNumber, round } from './numberUtils'\n\nexport const ONE_SECOND = 1000\nexport const ONE_MINUTE = 60 * ONE_SECOND\nexport const ONE_HOUR = 60 * ONE_MINUTE\nexport const ONE_DAY = 24 * ONE_HOUR\nexport const ONE_YEAR = 365 * ONE_DAY\n\nexport type Duration = number & { d: 'Duration in ms' }\nexport type ServerDuration = number & { s: 'Duration in ns' }\nexport type TimeStamp = number & { t: 'Epoch time' }\nexport type RelativeTime = number & { r: 'Time relative to navigation start' } & { d: 'Duration in ms' }\nexport type ClocksState = { relative: RelativeTime; timeStamp: TimeStamp }\n\nexport function relativeToClocks(relative: RelativeTime) {\n  return { relative, timeStamp: getCorrectedTimeStamp(relative) }\n}\n\nexport function timeStampToClocks(timeStamp: TimeStamp) {\n  return { relative: getRelativeTime(timeStamp), timeStamp }\n}\n\nfunction getCorrectedTimeStamp(relativeTime: RelativeTime) {\n  const correctedOrigin = (dateNow() - performance.now()) as TimeStamp\n  // apply correction only for positive drift\n  if (correctedOrigin > getNavigationStart()) {\n    return Math.round(addDuration(correctedOrigin, relativeTime)) as TimeStamp\n  }\n  return getTimeStamp(relativeTime)\n}\n\nexport function currentDrift() {\n  return Math.round(dateNow() - addDuration(getNavigationStart(), performance.now() as Duration))\n}\n\nexport function toServerDuration(duration: Duration): ServerDuration\nexport function toServerDuration(duration: Duration | undefined): ServerDuration | undefined\nexport function toServerDuration(duration: Duration | undefined) {\n  if (!isNumber(duration)) {\n    return duration\n  }\n  return round(duration * 1e6, 0) as ServerDuration\n}\n\nexport function dateNow() {\n  // Do not use `Date.now` because sometimes websites are wrongly \"polyfilling\" it. For example, we\n  // had some users using a very old version of `datejs`, which patched `Date.now` to return a Date\n  // instance instead of a timestamp[1]. Those users are unlikely to fix this, so let's handle this\n  // case ourselves.\n  // [1]: https://github.com/datejs/Datejs/blob/97f5c7c58c5bc5accdab8aa7602b6ac56462d778/src/core-debug.js#L14-L16\n  return new Date().getTime()\n}\n\nexport function timeStampNow() {\n  return dateNow() as TimeStamp\n}\n\nexport function relativeNow() {\n  return performance.now() as RelativeTime\n}\n\nexport function clocksNow() {\n  return { relative: relativeNow(), timeStamp: timeStampNow() }\n}\n\nexport function clocksOrigin() {\n  return { relative: 0 as RelativeTime, timeStamp: getNavigationStart() }\n}\n\nexport function elapsed(start: TimeStamp, end: TimeStamp): Duration\nexport function elapsed(start: RelativeTime, end: RelativeTime): Duration\nexport function elapsed(start: number, end: number) {\n  return (end - start) as Duration\n}\n\nexport function addDuration(a: TimeStamp, b: Duration): TimeStamp\nexport function addDuration(a: RelativeTime, b: Duration): RelativeTime\nexport function addDuration(a: Duration, b: Duration): Duration\nexport function addDuration(a: number, b: number) {\n  return a + b\n}\n\n// Get the time since the navigation was started.\nexport function getRelativeTime(timestamp: TimeStamp) {\n  return (timestamp - getNavigationStart()) as RelativeTime\n}\n\nexport function getTimeStamp(relativeTime: RelativeTime) {\n  return Math.round(addDuration(getNavigationStart(), relativeTime)) as TimeStamp\n}\n\nexport function looksLikeRelativeTime(time: RelativeTime | TimeStamp): time is RelativeTime {\n  return time < ONE_YEAR\n}\n\n/**\n * Navigation start slightly change on some rare cases\n */\nlet navigationStart: TimeStamp | undefined\n\n/**\n * Notes: this does not use `performance.timeOrigin` because:\n * - It doesn't seem to reflect the actual time on which the navigation has started: it may be much farther in the past,\n * at least in Firefox 71. (see: https://bugzilla.mozilla.org/show_bug.cgi?id=1429926)\n * - It is not supported in Safari <15\n */\nfunction getNavigationStart() {\n  if (navigationStart === undefined) {\n    navigationStart = performance.timing.navigationStart as TimeStamp\n  }\n  return navigationStart\n}\n", "/**\n * inspired by https://mathiasbynens.be/notes/globalthis\n */\n\nexport function getGlobalObject<T = typeof globalThis>(): T {\n  if (typeof globalThis === 'object') {\n    return globalThis as unknown as T\n  }\n  Object.defineProperty(Object.prototype, '_dd_temp_', {\n    get() {\n      return this as object\n    },\n    configurable: true,\n  })\n  // @ts-ignore _dd_temp is defined using defineProperty\n  let globalObject: unknown = _dd_temp_\n  // @ts-ignore _dd_temp is defined using defineProperty\n  delete Object.prototype._dd_temp_\n  if (typeof globalObject !== 'object') {\n    // on safari _dd_temp_ is available on window but not globally\n    // fallback on other browser globals check\n    if (typeof self === 'object') {\n      globalObject = self\n    } else if (typeof window === 'object') {\n      globalObject = window\n    } else {\n      globalObject = {}\n    }\n  }\n  return globalObject as T\n}\n", "import { display } from './display'\n\nlet onMonitorErrorCollected: undefined | ((error: unknown) => void)\nlet debugMode = false\n\nexport function startMonitorErrorCollection(newOnMonitorErrorCollected: (error: unknown) => void) {\n  onMonitorErrorCollected = newOnMonitorErrorCollected\n}\n\nexport function setDebugMode(newDebugMode: boolean) {\n  debugMode = newDebugMode\n}\n\nexport function resetMonitor() {\n  onMonitorErrorCollected = undefined\n  debugMode = false\n}\n\nexport function monitored<T extends (...params: any[]) => unknown>(\n  _: any,\n  __: string,\n  descriptor: TypedPropertyDescriptor<T>\n) {\n  const originalMethod = descriptor.value!\n  descriptor.value = function (this: any, ...args: Parameters<T>) {\n    const decorated = onMonitorErrorCollected ? monitor(originalMethod) : originalMethod\n    return decorated.apply(this, args) as ReturnType<T>\n  } as T\n}\n\nexport function monitor<T extends (...args: any[]) => any>(fn: T): T {\n  return function (this: any) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return callMonitored(fn, this, arguments as unknown as Parameters<T>)\n  } as unknown as T // consider output type has input type\n}\n\nexport function callMonitored<T extends (...args: any[]) => any>(\n  fn: T,\n  context: ThisParameterType<T>,\n  args: Parameters<T>\n): ReturnType<T> | undefined\nexport function callMonitored<T extends (this: void) => any>(fn: T): ReturnType<T> | undefined\nexport function callMonitored<T extends (...args: any[]) => any>(\n  fn: T,\n  context?: any,\n  args?: any\n): ReturnType<T> | undefined {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return fn.apply(context, args)\n  } catch (e) {\n    monitorError(e)\n  }\n}\n\nexport function monitorError(e: unknown) {\n  displayIfDebugEnabled(e)\n  if (onMonitorErrorCollected) {\n    try {\n      onMonitorErrorCollected(e)\n    } catch (e) {\n      displayIfDebugEnabled(e)\n    }\n  }\n}\n\nexport function displayIfDebugEnabled(...args: any[]) {\n  if (debugMode) {\n    display.error('[MONITOR]', ...args)\n  }\n}\n", "import { getGlobalObject } from './getGlobalObject'\n\nexport interface BrowserWindowWithZoneJs extends Window {\n  Zone?: {\n    // All Zone.js versions expose the __symbol__ method, but we observed that some website have a\n    // 'Zone' global variable unrelated to Zone.js, so let's consider this method optional\n    // nonetheless.\n    __symbol__?: (name: string) => string\n  }\n}\n\n/**\n * Gets the original value for a DOM API that was potentially patched by Zone.js.\n *\n * Zone.js[1] is a library that patches a bunch of JS and DOM APIs. It usually stores the original\n * value of the patched functions/constructors/methods in a hidden property prefixed by\n * __zone_symbol__.\n *\n * In multiple occasions, we observed that Zone.js is the culprit of important issues leading to\n * browser resource exhaustion (memory leak, high CPU usage). This method is used as a workaround to\n * use the original DOM API instead of the one patched by Zone.js.\n *\n * [1]: https://github.com/angular/angular/tree/main/packages/zone.js\n */\nexport function getZoneJsOriginalValue<Target, Name extends keyof Target & string>(\n  target: Target,\n  name: Name\n): Target[Name] {\n  const browserWindow = getGlobalObject<BrowserWindowWithZoneJs>()\n  let original: Target[Name] | undefined\n  if (browserWindow.Zone && typeof browserWindow.Zone.__symbol__ === 'function') {\n    original = (target as any)[browserWindow.Zone.__symbol__(name)]\n  }\n  if (!original) {\n    original = target[name]\n  }\n  return original\n}\n", "import { getZoneJsOriginalValue } from './getZoneJsOriginalValue'\nimport { monitor } from './monitor'\nimport { getGlobalObject } from './getGlobalObject'\n\nexport type TimeoutId = ReturnType<typeof globalThis.setTimeout>\n\nexport function setTimeout(callback: () => void, delay?: number): TimeoutId {\n  return getZoneJsOriginalValue(getGlobalObject(), 'setTimeout')(monitor(callback), delay)\n}\n\nexport function clearTimeout(timeoutId: TimeoutId | undefined) {\n  getZoneJsOriginalValue(getGlobalObject(), 'clearTimeout')(timeoutId)\n}\n\nexport function setInterval(callback: () => void, delay?: number): TimeoutId {\n  return getZoneJsOriginalValue(getGlobalObject(), 'setInterval')(monitor(callback), delay)\n}\n\nexport function clearInterval(timeoutId: TimeoutId | undefined) {\n  getZoneJsOriginalValue(getGlobalObject(), 'clearInterval')(timeoutId)\n}\n", "export const ONE_KIBI_BYTE = 1024\nexport const ONE_MEBI_BYTE = 1024 * ONE_KIBI_BYTE\n\n// eslint-disable-next-line no-control-regex\nconst HAS_MULTI_BYTES_CHARACTERS = /[^\\u0000-\\u007F]/\n\nexport function computeBytesCount(candidate: string): number {\n  // Accurate bytes count computations can degrade performances when there is a lot of events to process\n  if (!HAS_MULTI_BYTES_CHARACTERS.test(candidate)) {\n    return candidate.length\n  }\n\n  if (window.TextEncoder !== undefined) {\n    return new TextEncoder().encode(candidate).length\n  }\n\n  return new Blob([candidate]).size\n}\n\nexport function concatBuffers(buffers: Uint8Array[]): Uint8Array {\n  const length = buffers.reduce((total, buffer) => total + buffer.length, 0)\n  const result: Uint8Array = new Uint8Array(length)\n  let offset = 0\n  for (const buffer of buffers) {\n    result.set(buffer, offset)\n    offset += buffer.length\n  }\n  return result\n}\n", "export function isServerError(status: number) {\n  return status >= 500\n}\n\nexport function tryToClone(response: Response): Response | undefined {\n  try {\n    return response.clone()\n  } catch {\n    // clone can throw if the response has already been used by another instrumentation or is disturbed\n    return\n  }\n}\n", "import type { Context } from '../../tools/serialisation/context'\nimport type { ClocksState } from '../../tools/utils/timeUtils'\n\n// TS v4.6 introduced Error.cause[1] typed as `Error`. TS v4.8 changed Error.cause to be\n// `unknown`[2].\n//\n// Because we still support TS 3.8, we need to declare our own type. We can remove it once we drop\n// support for TS v4.7 and before. The 'cause' property defined by TS needs to be omitted because\n// we define it with a type `unknown` which is incompatible with TS 4.6 and 4.7.\n//\n// [1]: https://devblogs.microsoft.com/typescript/announcing-typescript-4-6/#target-es2022\n// [2]: https://devblogs.microsoft.com/typescript/announcing-typescript-4-8/#lib-d-ts-updates\nexport interface ErrorWithCause extends Omit<Error, 'cause'> {\n  cause?: unknown\n}\n\nexport type RawErrorCause = {\n  message: string\n  source: ErrorSource\n  type?: string\n  stack?: string\n}\n\nexport type Csp = {\n  disposition: 'enforce' | 'report'\n}\n\nexport interface RawError {\n  startClocks: ClocksState\n  message: string\n  type?: string\n  stack?: string\n  source: ErrorSource\n  originalError?: unknown\n  handling?: ErrorHandling\n  handlingStack?: string\n  componentStack?: string\n  causes?: RawErrorCause[]\n  fingerprint?: string\n  csp?: Csp\n  context?: Context\n}\n\nexport const ErrorSource = {\n  AGENT: 'agent',\n  CONSOLE: 'console',\n  CUSTOM: 'custom',\n  LOGGER: 'logger',\n  NETWORK: 'network',\n  SOURCE: 'source',\n  REPORT: 'report',\n} as const\n\nexport const enum NonErrorPrefix {\n  UNCAUGHT = 'Uncaught',\n  PROVIDED = 'Provided',\n}\n\nexport const enum ErrorHandling {\n  HANDLED = 'handled',\n  UNHANDLED = 'unhandled',\n}\n\nexport type ErrorSource = (typeof ErrorSource)[keyof typeof ErrorSource]\n", "import type { TrackType } from '../domain/configuration'\nimport { setTimeout } from '../tools/timer'\nimport { clocksNow, ONE_MINUTE, ONE_SECOND } from '../tools/utils/timeUtils'\nimport { ONE_MEBI_BYTE, ONE_KIBI_BYTE } from '../tools/utils/byteUtils'\nimport { isServerError } from '../tools/utils/responseUtils'\nimport type { RawError } from '../domain/error/error.types'\nimport { ErrorSource } from '../domain/error/error.types'\nimport type { Payload, HttpResponse } from './httpRequest'\n\nexport const MAX_ONGOING_BYTES_COUNT = 80 * ONE_KIBI_BYTE\nexport const MAX_ONGOING_REQUESTS = 32\nexport const MAX_QUEUE_BYTES_COUNT = 3 * ONE_MEBI_BYTE\nexport const MAX_BACKOFF_TIME = ONE_MINUTE\nexport const INITIAL_BACKOFF_TIME = ONE_SECOND\n\nconst enum TransportStatus {\n  UP,\n  FAILURE_DETECTED,\n  DOWN,\n}\n\nconst enum RetryReason {\n  AFTER_SUCCESS,\n  AFTER_RESUME,\n}\n\nexport interface RetryState {\n  transportStatus: TransportStatus\n  currentBackoffTime: number\n  bandwidthMonitor: ReturnType<typeof newBandwidthMonitor>\n  queuedPayloads: ReturnType<typeof newPayloadQueue>\n  queueFullReported: boolean\n}\n\ntype SendStrategy = (payload: Payload, onResponse: (r: HttpResponse) => void) => void\n\nexport function sendWithRetryStrategy(\n  payload: Payload,\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  trackType: TrackType,\n  reportError: (error: RawError) => void\n) {\n  if (\n    state.transportStatus === TransportStatus.UP &&\n    state.queuedPayloads.size() === 0 &&\n    state.bandwidthMonitor.canHandle(payload)\n  ) {\n    send(payload, state, sendStrategy, {\n      onSuccess: () => retryQueuedPayloads(RetryReason.AFTER_SUCCESS, state, sendStrategy, trackType, reportError),\n      onFailure: () => {\n        state.queuedPayloads.enqueue(payload)\n        scheduleRetry(state, sendStrategy, trackType, reportError)\n      },\n    })\n  } else {\n    state.queuedPayloads.enqueue(payload)\n  }\n}\n\nfunction scheduleRetry(\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  trackType: TrackType,\n  reportError: (error: RawError) => void\n) {\n  if (state.transportStatus !== TransportStatus.DOWN) {\n    return\n  }\n  setTimeout(() => {\n    const payload = state.queuedPayloads.first()\n    send(payload, state, sendStrategy, {\n      onSuccess: () => {\n        state.queuedPayloads.dequeue()\n        state.currentBackoffTime = INITIAL_BACKOFF_TIME\n        retryQueuedPayloads(RetryReason.AFTER_RESUME, state, sendStrategy, trackType, reportError)\n      },\n      onFailure: () => {\n        state.currentBackoffTime = Math.min(MAX_BACKOFF_TIME, state.currentBackoffTime * 2)\n        scheduleRetry(state, sendStrategy, trackType, reportError)\n      },\n    })\n  }, state.currentBackoffTime)\n}\n\nfunction send(\n  payload: Payload,\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  { onSuccess, onFailure }: { onSuccess: () => void; onFailure: () => void }\n) {\n  state.bandwidthMonitor.add(payload)\n  sendStrategy(payload, (response) => {\n    state.bandwidthMonitor.remove(payload)\n    if (!shouldRetryRequest(response)) {\n      state.transportStatus = TransportStatus.UP\n      onSuccess()\n    } else {\n      // do not consider transport down if another ongoing request could succeed\n      state.transportStatus =\n        state.bandwidthMonitor.ongoingRequestCount > 0 ? TransportStatus.FAILURE_DETECTED : TransportStatus.DOWN\n      payload.retry = {\n        count: payload.retry ? payload.retry.count + 1 : 1,\n        lastFailureStatus: response.status,\n      }\n      onFailure()\n    }\n  })\n}\n\nfunction retryQueuedPayloads(\n  reason: RetryReason,\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  trackType: TrackType,\n  reportError: (error: RawError) => void\n) {\n  if (reason === RetryReason.AFTER_SUCCESS && state.queuedPayloads.isFull() && !state.queueFullReported) {\n    reportError({\n      message: `Reached max ${trackType} events size queued for upload: ${MAX_QUEUE_BYTES_COUNT / ONE_MEBI_BYTE}MiB`,\n      source: ErrorSource.AGENT,\n      startClocks: clocksNow(),\n    })\n    state.queueFullReported = true\n  }\n  const previousQueue = state.queuedPayloads\n  state.queuedPayloads = newPayloadQueue()\n  while (previousQueue.size() > 0) {\n    sendWithRetryStrategy(previousQueue.dequeue()!, state, sendStrategy, trackType, reportError)\n  }\n}\n\nfunction shouldRetryRequest(response: HttpResponse) {\n  return (\n    response.type !== 'opaque' &&\n    ((response.status === 0 && !navigator.onLine) ||\n      response.status === 408 ||\n      response.status === 429 ||\n      isServerError(response.status))\n  )\n}\n\nexport function newRetryState(): RetryState {\n  return {\n    transportStatus: TransportStatus.UP,\n    currentBackoffTime: INITIAL_BACKOFF_TIME,\n    bandwidthMonitor: newBandwidthMonitor(),\n    queuedPayloads: newPayloadQueue(),\n    queueFullReported: false,\n  }\n}\n\nfunction newPayloadQueue() {\n  const queue: Payload[] = []\n  return {\n    bytesCount: 0,\n    enqueue(payload: Payload) {\n      if (this.isFull()) {\n        return\n      }\n      queue.push(payload)\n      this.bytesCount += payload.bytesCount\n    },\n    first() {\n      return queue[0]\n    },\n    dequeue() {\n      const payload = queue.shift()\n      if (payload) {\n        this.bytesCount -= payload.bytesCount\n      }\n      return payload\n    },\n    size() {\n      return queue.length\n    },\n    isFull() {\n      return this.bytesCount >= MAX_QUEUE_BYTES_COUNT\n    },\n  }\n}\n\nfunction newBandwidthMonitor() {\n  return {\n    ongoingRequestCount: 0,\n    ongoingByteCount: 0,\n    canHandle(payload: Payload) {\n      return (\n        this.ongoingRequestCount === 0 ||\n        (this.ongoingByteCount + payload.bytesCount <= MAX_ONGOING_BYTES_COUNT &&\n          this.ongoingRequestCount < MAX_ONGOING_REQUESTS)\n      )\n    },\n    add(payload: Payload) {\n      this.ongoingRequestCount += 1\n      this.ongoingByteCount += payload.bytesCount\n    },\n    remove(payload: Payload) {\n      this.ongoingRequestCount -= 1\n      this.ongoingByteCount -= payload.bytesCount\n    },\n  }\n}\n", "import type { EndpointBuilder } from '../domain/configuration'\nimport type { Context } from '../tools/serialisation/context'\nimport { monitor, monitorError } from '../tools/monitor'\nimport type { RawError } from '../domain/error/error.types'\nimport { newRetryState, sendWithRetryStrategy } from './sendWithRetryStrategy'\n\n/**\n * Use POST request without content type to:\n * - avoid CORS preflight requests\n * - allow usage of sendBeacon\n *\n * multiple elements are sent separated by \\n in order\n * to be parsed correctly without content type header\n */\n\nexport type HttpRequest = ReturnType<typeof createHttpRequest>\n\nexport interface HttpResponse extends Context {\n  status: number\n  type?: ResponseType\n}\n\nexport interface Payload {\n  data: string | FormData | Blob\n  bytesCount: number\n  retry?: RetryInfo\n  encoding?: 'deflate'\n}\n\nexport interface RetryInfo {\n  count: number\n  lastFailureStatus: number\n}\n\nexport function createHttpRequest(\n  endpointBuilder: EndpointBuilder,\n  bytesLimit: number,\n  reportError: (error: RawError) => void\n) {\n  const retryState = newRetryState()\n  const sendStrategyForRetry = (payload: Payload, onResponse: (r: HttpResponse) => void) =>\n    fetchKeepAliveStrategy(endpointBuilder, bytesLimit, payload, onResponse)\n\n  return {\n    send: (payload: Payload) => {\n      sendWithRetryStrategy(payload, retryState, sendStrategyForRetry, endpointBuilder.trackType, reportError)\n    },\n    /**\n     * Since fetch keepalive behaves like regular fetch on Firefox,\n     * keep using sendBeaconStrategy on exit\n     */\n    sendOnExit: (payload: Payload) => {\n      sendBeaconStrategy(endpointBuilder, bytesLimit, payload)\n    },\n  }\n}\n\nfunction sendBeaconStrategy(endpointBuilder: EndpointBuilder, bytesLimit: number, payload: Payload) {\n  const canUseBeacon = !!navigator.sendBeacon && payload.bytesCount < bytesLimit\n  if (canUseBeacon) {\n    try {\n      const beaconUrl = endpointBuilder.build('beacon', payload)\n      const isQueued = navigator.sendBeacon(beaconUrl, payload.data)\n\n      if (isQueued) {\n        return\n      }\n    } catch (e) {\n      reportBeaconError(e)\n    }\n  }\n\n  fetchStrategy(endpointBuilder, payload)\n}\n\nlet hasReportedBeaconError = false\n\nfunction reportBeaconError(e: unknown) {\n  if (!hasReportedBeaconError) {\n    hasReportedBeaconError = true\n    monitorError(e)\n  }\n}\n\nexport function fetchKeepAliveStrategy(\n  endpointBuilder: EndpointBuilder,\n  bytesLimit: number,\n  payload: Payload,\n  onResponse?: (r: HttpResponse) => void\n) {\n  const canUseKeepAlive = isKeepAliveSupported() && payload.bytesCount < bytesLimit\n\n  if (canUseKeepAlive) {\n    const fetchUrl = endpointBuilder.build('fetch-keepalive', payload)\n\n    fetch(fetchUrl, { method: 'POST', body: payload.data, keepalive: true, mode: 'cors' })\n      .then(monitor((response: Response) => onResponse?.({ status: response.status, type: response.type })))\n      .catch(monitor(() => fetchStrategy(endpointBuilder, payload, onResponse)))\n  } else {\n    fetchStrategy(endpointBuilder, payload, onResponse)\n  }\n}\n\nexport function fetchStrategy(\n  endpointBuilder: EndpointBuilder,\n  payload: Payload,\n  onResponse?: (r: HttpResponse) => void\n) {\n  const fetchUrl = endpointBuilder.build('fetch', payload)\n\n  fetch(fetchUrl, { method: 'POST', body: payload.data, mode: 'cors' })\n    .then(monitor((response: Response) => onResponse?.({ status: response.status, type: response.type })))\n    .catch(monitor(() => onResponse?.({ status: 0 })))\n}\n\nfunction isKeepAliveSupported() {\n  // Request can throw, cf https://developer.mozilla.org/en-US/docs/Web/API/Request/Request#errors\n  try {\n    return window.Request && 'keepalive' in new Request('http://a')\n  } catch {\n    return false\n  }\n}\n", "import { getGlobalObject } from '../tools/getGlobalObject'\nimport type { DefaultPrivacyLevel } from '../domain/configuration'\n\nexport interface BrowserWindowWithEventBridge extends Window {\n  DatadogEventBridge?: DatadogEventBridge\n}\n\nexport interface DatadogEventBridge {\n  getCapabilities?(): string\n  getPrivacyLevel?(): DefaultPrivacyLevel\n  getAllowedWebViewHosts(): string\n  send(msg: string): void\n}\n\nexport const enum BridgeCapability {\n  RECORDS = 'records',\n}\n\nexport function getEventBridge<T, E>() {\n  const eventBridgeGlobal = getEventBridgeGlobal()\n\n  if (!eventBridgeGlobal) {\n    return\n  }\n\n  return {\n    getCapabilities() {\n      return JSON.parse(eventBridgeGlobal.getCapabilities?.() || '[]') as BridgeCapability[]\n    },\n    getPrivacyLevel() {\n      return eventBridgeGlobal.getPrivacyLevel?.()\n    },\n    getAllowedWebViewHosts() {\n      return JSON.parse(eventBridgeGlobal.getAllowedWebViewHosts()) as string[]\n    },\n    send(eventType: T, event: E, viewId?: string) {\n      const view = viewId ? { id: viewId } : undefined\n      eventBridgeGlobal.send(JSON.stringify({ eventType, event, view }))\n    },\n  }\n}\n\nexport function bridgeSupports(capability: BridgeCapability): boolean {\n  const bridge = getEventBridge()\n  return !!bridge && bridge.getCapabilities().includes(capability)\n}\n\nexport function canUseEventBridge(currentHost = getGlobalObject<Window>().location?.hostname): boolean {\n  const bridge = getEventBridge()\n  return (\n    !!bridge &&\n    bridge\n      .getAllowedWebViewHosts()\n      .some((allowedHost) => currentHost === allowedHost || currentHost.endsWith(`.${allowedHost}`))\n  )\n}\n\nfunction getEventBridgeGlobal() {\n  return getGlobalObject<BrowserWindowWithEventBridge>().DatadogEventBridge\n}\n", "import { monitor } from '../tools/monitor'\nimport { getZoneJsOriginalValue } from '../tools/getZoneJsOriginalValue'\nimport type { CookieStore, CookieStoreEventMap, VisualViewport, VisualViewportEventMap } from './browser.types'\n\nexport type TrustableEvent<E extends Event = Event> = E & { __ddIsTrusted?: boolean }\n\nexport const enum DOM_EVENT {\n  BEFORE_UNLOAD = 'beforeunload',\n  CLICK = 'click',\n  DBL_CLICK = 'dblclick',\n  KEY_DOWN = 'keydown',\n  LOAD = 'load',\n  POP_STATE = 'popstate',\n  SCROLL = 'scroll',\n  TOUCH_START = 'touchstart',\n  TOUCH_END = 'touchend',\n  TOUCH_MOVE = 'touchmove',\n  VISIBILITY_CHANGE = 'visibilitychange',\n  PAGE_SHOW = 'pageshow',\n  FREEZE = 'freeze',\n  RESUME = 'resume',\n  DOM_CONTENT_LOADED = 'DOMContentLoaded',\n  POINTER_DOWN = 'pointerdown',\n  POINTER_UP = 'pointerup',\n  POINTER_CANCEL = 'pointercancel',\n  HASH_CHANGE = 'hashchange',\n  PAGE_HIDE = 'pagehide',\n  MOUSE_DOWN = 'mousedown',\n  MOUSE_UP = 'mouseup',\n  MOUSE_MOVE = 'mousemove',\n  FOCUS = 'focus',\n  BLUR = 'blur',\n  CONTEXT_MENU = 'contextmenu',\n  RESIZE = 'resize',\n  CHANGE = 'change',\n  INPUT = 'input',\n  PLAY = 'play',\n  PAUSE = 'pause',\n  SECURITY_POLICY_VIOLATION = 'securitypolicyviolation',\n  SELECTION_CHANGE = 'selectionchange',\n  STORAGE = 'storage',\n}\n\ninterface AddEventListenerOptions {\n  once?: boolean\n  capture?: boolean\n  passive?: boolean\n}\n\ntype EventMapFor<T> = T extends Window\n  ? WindowEventMap & {\n      // TS 4.9.5 does not support `freeze` and `resume` events yet\n      freeze: Event\n      resume: Event\n      // TS 4.9.5 does not define `visibilitychange` on Window (only Document)\n      visibilitychange: Event\n    }\n  : T extends Document\n    ? DocumentEventMap\n    : T extends HTMLElement\n      ? HTMLElementEventMap\n      : T extends VisualViewport\n        ? VisualViewportEventMap\n        : T extends ShadowRoot\n          ? // ShadowRootEventMap is not yet defined in our supported TS version. Instead, use\n            // GlobalEventHandlersEventMap which is more than enough as we only need to listen for events bubbling\n            // through the ShadowRoot like \"change\" or \"input\"\n            GlobalEventHandlersEventMap\n          : T extends XMLHttpRequest\n            ? XMLHttpRequestEventMap\n            : T extends Performance\n              ? PerformanceEventMap\n              : T extends Worker\n                ? WorkerEventMap\n                : T extends CookieStore\n                  ? CookieStoreEventMap\n                  : Record<never, never>\n\n/**\n * Add an event listener to an event target object (Window, Element, mock object...).  This provides\n * a few conveniences compared to using `element.addEventListener` directly:\n *\n * * supports IE11 by: using an option object only if needed and emulating the `once` option\n *\n * * wraps the listener with a `monitor` function\n *\n * * returns a `stop` function to remove the listener\n */\nexport function addEventListener<Target extends EventTarget, EventName extends keyof EventMapFor<Target> & string>(\n  configuration: { allowUntrustedEvents?: boolean | undefined },\n  eventTarget: Target,\n  eventName: EventName,\n  listener: (event: EventMapFor<Target>[EventName] & { type: EventName }) => void,\n  options?: AddEventListenerOptions\n) {\n  return addEventListeners(configuration, eventTarget, [eventName], listener, options)\n}\n\n/**\n * Add event listeners to an event target object (Window, Element, mock object...).  This provides\n * a few conveniences compared to using `element.addEventListener` directly:\n *\n * * supports IE11 by: using an option object only if needed and emulating the `once` option\n *\n * * wraps the listener with a `monitor` function\n *\n * * returns a `stop` function to remove the listener\n *\n * * with `once: true`, the listener will be called at most once, even if different events are listened\n */\nexport function addEventListeners<Target extends EventTarget, EventName extends keyof EventMapFor<Target> & string>(\n  configuration: { allowUntrustedEvents?: boolean | undefined },\n  eventTarget: Target,\n  eventNames: EventName[],\n  listener: (event: EventMapFor<Target>[EventName] & { type: EventName }) => void,\n  { once, capture, passive }: AddEventListenerOptions = {}\n) {\n  const listenerWithMonitor = monitor((event: TrustableEvent) => {\n    if (!event.isTrusted && !event.__ddIsTrusted && !configuration.allowUntrustedEvents) {\n      return\n    }\n    if (once) {\n      stop()\n    }\n    listener(event as unknown as EventMapFor<Target>[EventName] & { type: EventName })\n  })\n\n  const options = passive ? { capture, passive } : capture\n\n  // Use the window.EventTarget.prototype when possible to avoid wrong overrides (e.g: https://github.com/salesforce/lwc/issues/1824)\n  const listenerTarget =\n    window.EventTarget && eventTarget instanceof EventTarget ? window.EventTarget.prototype : eventTarget\n\n  const add = getZoneJsOriginalValue(listenerTarget, 'addEventListener')\n  eventNames.forEach((eventName) => add.call(eventTarget, eventName, listenerWithMonitor, options))\n\n  function stop() {\n    const remove = getZoneJsOriginalValue(listenerTarget, 'removeEventListener')\n    eventNames.forEach((eventName) => remove.call(eventTarget, eventName, listenerWithMonitor, options))\n  }\n\n  return {\n    stop,\n  }\n}\n", "export function findLast<T, S extends T>(\n  array: T[],\n  predicate: (item: T, index: number, array: T[]) => item is S\n): S | undefined {\n  for (let i = array.length - 1; i >= 0; i -= 1) {\n    const item = array[i]\n    if (predicate(item, i, array)) {\n      return item\n    }\n  }\n  return undefined\n}\n\n// Keep the following wrapper functions as it can be mangled and will result in smaller bundle size that using\n// the native Object.values and Object.entries directly\n\nexport function objectValues<T = unknown>(object: { [key: string]: T }) {\n  return Object.values(object)\n}\n\nexport function objectEntries<T = unknown>(object: { [key: string]: T }): Array<[string, T]> {\n  return Object.entries(object)\n}\n", "export interface Subscription {\n  unsubscribe: () => void\n}\n\n// eslint-disable-next-line no-restricted-syntax\nexport class Observable<T> {\n  private observers: Array<(data: T) => void> = []\n  private onLastUnsubscribe?: () => void\n\n  constructor(private onFirstSubscribe?: (observable: Observable<T>) => (() => void) | void) {}\n\n  subscribe(f: (data: T) => void): Subscription {\n    this.observers.push(f)\n    if (this.observers.length === 1 && this.onFirstSubscribe) {\n      this.onLastUnsubscribe = this.onFirstSubscribe(this) || undefined\n    }\n    return {\n      unsubscribe: () => {\n        this.observers = this.observers.filter((other) => f !== other)\n        if (!this.observers.length && this.onLastUnsubscribe) {\n          this.onLastUnsubscribe()\n        }\n      },\n    }\n  }\n\n  notify(data: T) {\n    this.observers.forEach((observer) => observer(data))\n  }\n}\n\nexport function mergeObservables<T>(...observables: Array<Observable<T>>) {\n  return new Observable<T>((globalObservable) => {\n    const subscriptions: Subscription[] = observables.map((observable) =>\n      observable.subscribe((data) => globalObservable.notify(data))\n    )\n    return () => subscriptions.forEach((subscription) => subscription.unsubscribe())\n  })\n}\n", "import { Observable } from '../tools/observable'\nimport { objectValues } from '../tools/utils/polyfills'\nimport type { Configuration } from '../domain/configuration'\nimport { addEventListeners, addEventListener, DOM_EVENT } from './addEventListener'\n\nexport const PageExitReason = {\n  HIDDEN: 'visibility_hidden',\n  UNLOADING: 'before_unload',\n  PAGEHIDE: 'page_hide',\n  FROZEN: 'page_frozen',\n} as const\n\nexport type PageExitReason = (typeof PageExitReason)[keyof typeof PageExitReason]\n\nexport interface PageMayExitEvent {\n  reason: PageExitReason\n}\n\nexport function createPageMayExitObservable(configuration: Configuration): Observable<PageMayExitEvent> {\n  return new Observable<PageMayExitEvent>((observable) => {\n    const { stop: stopListeners } = addEventListeners(\n      configuration,\n      window,\n      [DOM_EVENT.VISIBILITY_CHANGE, DOM_EVENT.FREEZE],\n      (event) => {\n        if (event.type === DOM_EVENT.VISIBILITY_CHANGE && document.visibilityState === 'hidden') {\n          /**\n           * Only event that guarantee to fire on mobile devices when the page transitions to background state\n           * (e.g. when user switches to a different application, goes to homescreen, etc), or is being unloaded.\n           */\n          observable.notify({ reason: PageExitReason.HIDDEN })\n        } else if (event.type === DOM_EVENT.FREEZE) {\n          /**\n           * After transitioning in background a tab can be freezed to preserve resources. (cf: https://developer.chrome.com/blog/page-lifecycle-api)\n           * Allow to collect events happening between hidden and frozen state.\n           */\n          observable.notify({ reason: PageExitReason.FROZEN })\n        }\n      },\n      { capture: true }\n    )\n\n    const stopBeforeUnloadListener = addEventListener(configuration, window, DOM_EVENT.BEFORE_UNLOAD, () => {\n      observable.notify({ reason: PageExitReason.UNLOADING })\n    }).stop\n\n    return () => {\n      stopListeners()\n      stopBeforeUnloadListener()\n    }\n  })\n}\n\nexport function isPageExitReason(reason: string): reason is PageExitReason {\n  return objectValues(PageExitReason).includes(reason as PageExitReason)\n}\n", "import type { TimeoutId } from '../timer'\nimport { setTimeout, clearTimeout } from '../timer'\n\n// use lodash API\nexport function throttle<T extends (...args: any[]) => void>(\n  fn: T,\n  wait: number,\n  options?: { leading?: boolean; trailing?: boolean }\n) {\n  const needLeadingExecution = options && options.leading !== undefined ? options.leading : true\n  const needTrailingExecution = options && options.trailing !== undefined ? options.trailing : true\n  let inWaitPeriod = false\n  let pendingExecutionWithParameters: Parameters<T> | undefined\n  let pendingTimeoutId: TimeoutId\n\n  return {\n    throttled: (...parameters: Parameters<T>) => {\n      if (inWaitPeriod) {\n        pendingExecutionWithParameters = parameters\n        return\n      }\n      if (needLeadingExecution) {\n        fn(...parameters)\n      } else {\n        pendingExecutionWithParameters = parameters\n      }\n      inWaitPeriod = true\n      pendingTimeoutId = setTimeout(() => {\n        if (needTrailingExecution && pendingExecutionWithParameters) {\n          fn(...pendingExecutionWithParameters)\n        }\n        inWaitPeriod = false\n        pendingExecutionWithParameters = undefined\n      }, wait)\n    },\n    cancel: () => {\n      clearTimeout(pendingTimeoutId)\n      inWaitPeriod = false\n      pendingExecutionWithParameters = undefined\n    },\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport function noop() {}\n", "import { noop } from '../utils/functionUtils'\n\n/**\n * Custom implementation of JSON.stringify that ignores some toJSON methods. We need to do that\n * because some sites badly override toJSON on certain objects. Removing all toJSON methods from\n * nested values would be too costly, so we just detach them from the root value, and native classes\n * used to build JSON values (Array and Object).\n *\n * Note: this still assumes that JSON.stringify is correct.\n */\nexport function jsonStringify(\n  value: unknown,\n  replacer?: Array<string | number>,\n  space?: string | number\n): string | undefined {\n  if (typeof value !== 'object' || value === null) {\n    return JSON.stringify(value)\n  }\n\n  // Note: The order matter here. We need to detach toJSON methods on parent classes before their\n  // subclasses.\n  const restoreObjectPrototypeToJson = detachToJsonMethod(Object.prototype)\n  const restoreArrayPrototypeToJson = detachToJsonMethod(Array.prototype)\n  const restoreValuePrototypeToJson = detachToJsonMethod(Object.getPrototypeOf(value))\n  const restoreValueToJson = detachToJsonMethod(value)\n\n  try {\n    return JSON.stringify(value, replacer, space)\n  } catch {\n    return '<error: unable to serialize object>'\n  } finally {\n    restoreObjectPrototypeToJson()\n    restoreArrayPrototypeToJson()\n    restoreValuePrototypeToJson()\n    restoreValueToJson()\n  }\n}\n\nexport interface ObjectWithToJsonMethod {\n  toJSON?: () => unknown\n}\n\nexport function detachToJsonMethod(value: object) {\n  const object = value as ObjectWithToJsonMethod\n  const objectToJson = object.toJSON\n  if (objectToJson) {\n    delete object.toJSON\n    return () => {\n      object.toJSON = objectToJson\n    }\n  }\n  return noop\n}\n", "import { DOCS_TROUBLESHOOTING, MORE_DETAILS, display } from '../tools/display'\nimport type { Context } from '../tools/serialisation/context'\nimport { objectValues } from '../tools/utils/polyfills'\nimport { isPageExitReason } from '../browser/pageMayExitObservable'\nimport { jsonStringify } from '../tools/serialisation/jsonStringify'\nimport type { Encoder, EncoderResult } from '../tools/encoder'\nimport { computeBytesCount } from '../tools/utils/byteUtils'\nimport type { HttpRequest, Payload } from './httpRequest'\nimport type { FlushController, FlushEvent } from './flushController'\n\nexport interface Batch {\n  flushController: FlushController\n  add: (message: Context) => void\n  upsert: (message: Context, key: string) => void\n  stop: () => void\n}\n\nexport function createBatch({\n  encoder,\n  request,\n  flushController,\n  messageBytesLimit,\n}: {\n  encoder: Encoder\n  request: HttpRequest\n  flushController: FlushController\n  messageBytesLimit: number\n}): Batch {\n  let upsertBuffer: { [key: string]: string } = {}\n  const flushSubscription = flushController.flushObservable.subscribe((event) => flush(event))\n\n  function push(serializedMessage: string, estimatedMessageBytesCount: number, key?: string) {\n    flushController.notifyBeforeAddMessage(estimatedMessageBytesCount)\n\n    if (key !== undefined) {\n      upsertBuffer[key] = serializedMessage\n      flushController.notifyAfterAddMessage()\n    } else {\n      encoder.write(encoder.isEmpty ? serializedMessage : `\\n${serializedMessage}`, (realMessageBytesCount) => {\n        flushController.notifyAfterAddMessage(realMessageBytesCount - estimatedMessageBytesCount)\n      })\n    }\n  }\n\n  function hasMessageFor(key?: string): key is string {\n    return key !== undefined && upsertBuffer[key] !== undefined\n  }\n\n  function remove(key: string) {\n    const removedMessage = upsertBuffer[key]\n    delete upsertBuffer[key]\n    const messageBytesCount = encoder.estimateEncodedBytesCount(removedMessage)\n    flushController.notifyAfterRemoveMessage(messageBytesCount)\n  }\n\n  function addOrUpdate(message: Context, key?: string) {\n    const serializedMessage = jsonStringify(message)!\n\n    const estimatedMessageBytesCount = encoder.estimateEncodedBytesCount(serializedMessage)\n\n    if (estimatedMessageBytesCount >= messageBytesLimit) {\n      display.warn(\n        `Discarded a message whose size was bigger than the maximum allowed size ${messageBytesLimit}KB. ${MORE_DETAILS} ${DOCS_TROUBLESHOOTING}/#technical-limitations`\n      )\n      return\n    }\n\n    if (hasMessageFor(key)) {\n      remove(key)\n    }\n\n    push(serializedMessage, estimatedMessageBytesCount, key)\n  }\n\n  function flush(event: FlushEvent) {\n    const upsertMessages = objectValues(upsertBuffer).join('\\n')\n    upsertBuffer = {}\n\n    const pageMightExit = isPageExitReason(event.reason)\n    const send = pageMightExit ? request.sendOnExit : request.send\n\n    if (\n      pageMightExit &&\n      // Note: checking that the encoder is async is not strictly needed, but it's an optimization:\n      // if the encoder is async we need to send two requests in some cases (one for encoded data\n      // and the other for non-encoded data). But if it's not async, we don't have to worry about\n      // it and always send a single request.\n      encoder.isAsync\n    ) {\n      const encoderResult = encoder.finishSync()\n\n      // Send encoded messages\n      if (encoderResult.outputBytesCount) {\n        send(formatPayloadFromEncoder(encoderResult))\n      }\n\n      // Send messages that are not yet encoded at this point\n      const pendingMessages = [encoderResult.pendingData, upsertMessages].filter(Boolean).join('\\n')\n      if (pendingMessages) {\n        send({\n          data: pendingMessages,\n          bytesCount: computeBytesCount(pendingMessages),\n        })\n      }\n    } else {\n      if (upsertMessages) {\n        encoder.write(encoder.isEmpty ? upsertMessages : `\\n${upsertMessages}`)\n      }\n      encoder.finish((encoderResult) => {\n        send(formatPayloadFromEncoder(encoderResult))\n      })\n    }\n  }\n\n  return {\n    flushController,\n    add: addOrUpdate,\n    upsert: addOrUpdate,\n    stop: flushSubscription.unsubscribe,\n  }\n}\n\nfunction formatPayloadFromEncoder(encoderResult: EncoderResult): Payload {\n  let data: string | Blob\n  if (typeof encoderResult.output === 'string') {\n    data = encoderResult.output\n  } else {\n    data = new Blob([encoderResult.output], {\n      // This will set the 'Content-Type: text/plain' header. Reasoning:\n      // * The intake rejects the request if there is no content type.\n      // * The browser will issue CORS preflight requests if we set it to 'application/json', which\n      // could induce higher intake load (and maybe has other impacts).\n      // * Also it's not quite JSON, since we are concatenating multiple JSON objects separated by\n      // new lines.\n      type: 'text/plain',\n    })\n  }\n\n  return {\n    data,\n    bytesCount: encoderResult.outputBytesCount,\n    encoding: encoderResult.encoding,\n  }\n}\n", "import type { PageMayExitEvent, PageExitReason } from '../browser/pageMayExitObservable'\nimport { Observable } from '../tools/observable'\nimport type { TimeoutId } from '../tools/timer'\nimport { clearTimeout, setTimeout } from '../tools/timer'\nimport type { Duration } from '../tools/utils/timeUtils'\n\nexport type FlushReason = PageExitReason | 'duration_limit' | 'bytes_limit' | 'messages_limit' | 'session_expire'\n\nexport type FlushController = ReturnType<typeof createFlushController>\nexport interface FlushEvent {\n  reason: FlushReason\n  bytesCount: number\n  messagesCount: number\n}\n\ninterface FlushControllerOptions {\n  messagesLimit: number\n  bytesLimit: number\n  durationLimit: Duration\n  pageMayExitObservable: Observable<PageMayExitEvent>\n  sessionExpireObservable: Observable<void>\n}\n\n/**\n * Returns a \"flush controller\", responsible of notifying when flushing a pool of pending data needs\n * to happen. The implementation is designed to support both synchronous and asynchronous usages,\n * but relies on invariants described in each method documentation to keep a coherent state.\n */\nexport function createFlushController({\n  messagesLimit,\n  bytesLimit,\n  durationLimit,\n  pageMayExitObservable,\n  sessionExpireObservable,\n}: FlushControllerOptions) {\n  const pageMayExitSubscription = pageMayExitObservable.subscribe((event) => flush(event.reason))\n  const sessionExpireSubscription = sessionExpireObservable.subscribe(() => flush('session_expire'))\n\n  const flushObservable = new Observable<FlushEvent>(() => () => {\n    pageMayExitSubscription.unsubscribe()\n    sessionExpireSubscription.unsubscribe()\n  })\n\n  let currentBytesCount = 0\n  let currentMessagesCount = 0\n\n  function flush(flushReason: FlushReason) {\n    if (currentMessagesCount === 0) {\n      return\n    }\n\n    const messagesCount = currentMessagesCount\n    const bytesCount = currentBytesCount\n\n    currentMessagesCount = 0\n    currentBytesCount = 0\n    cancelDurationLimitTimeout()\n\n    flushObservable.notify({\n      reason: flushReason,\n      messagesCount,\n      bytesCount,\n    })\n  }\n\n  let durationLimitTimeoutId: TimeoutId | undefined\n  function scheduleDurationLimitTimeout() {\n    if (durationLimitTimeoutId === undefined) {\n      durationLimitTimeoutId = setTimeout(() => {\n        flush('duration_limit')\n      }, durationLimit)\n    }\n  }\n\n  function cancelDurationLimitTimeout() {\n    clearTimeout(durationLimitTimeoutId)\n    durationLimitTimeoutId = undefined\n  }\n\n  return {\n    flushObservable,\n    get messagesCount() {\n      return currentMessagesCount\n    },\n\n    /**\n     * Notifies that a message will be added to a pool of pending messages waiting to be flushed.\n     *\n     * This function needs to be called synchronously, right before adding the message, so no flush\n     * event can happen after `notifyBeforeAddMessage` and before adding the message.\n     *\n     * @param estimatedMessageBytesCount: an estimation of the message bytes count once it is\n     * actually added.\n     */\n    notifyBeforeAddMessage(estimatedMessageBytesCount: number) {\n      if (currentBytesCount + estimatedMessageBytesCount >= bytesLimit) {\n        flush('bytes_limit')\n      }\n      // Consider the message to be added now rather than in `notifyAfterAddMessage`, because if no\n      // message was added yet and `notifyAfterAddMessage` is called asynchronously, we still want\n      // to notify when a flush is needed (for example on page exit).\n      currentMessagesCount += 1\n      currentBytesCount += estimatedMessageBytesCount\n      scheduleDurationLimitTimeout()\n    },\n\n    /**\n     * Notifies that a message *was* added to a pool of pending messages waiting to be flushed.\n     *\n     * This function can be called asynchronously after the message was added, but in this case it\n     * should not be called if a flush event occurred in between.\n     *\n     * @param messageBytesCountDiff: the difference between the estimated message bytes count and\n     * its actual bytes count once added to the pool.\n     */\n    notifyAfterAddMessage(messageBytesCountDiff = 0) {\n      currentBytesCount += messageBytesCountDiff\n\n      if (currentMessagesCount >= messagesLimit) {\n        flush('messages_limit')\n      } else if (currentBytesCount >= bytesLimit) {\n        flush('bytes_limit')\n      }\n    },\n\n    /**\n     * Notifies that a message was removed from a pool of pending messages waiting to be flushed.\n     *\n     * This function needs to be called synchronously, right after removing the message, so no flush\n     * event can happen after removing the message and before `notifyAfterRemoveMessage`.\n     *\n     * @param messageBytesCount: the message bytes count that was added to the pool. Should\n     * correspond to the sum of bytes counts passed to `notifyBeforeAddMessage` and\n     * `notifyAfterAddMessage`.\n     */\n    notifyAfterRemoveMessage(messageBytesCount: number) {\n      currentBytesCount -= messageBytesCount\n      currentMessagesCount -= 1\n      if (currentMessagesCount === 0) {\n        cancelDurationLimitTimeout()\n      }\n    },\n  }\n}\n", "import type { Configuration, EndpointBuilder } from '../domain/configuration'\nimport type { Context } from '../tools/serialisation/context'\nimport type { Observable } from '../tools/observable'\nimport type { PageMayExitEvent } from '../browser/pageMayExitObservable'\nimport type { RawError } from '../domain/error/error.types'\nimport type { Encoder } from '../tools/encoder'\nimport { createBatch } from './batch'\nimport { createHttpRequest } from './httpRequest'\nimport { createFlushController } from './flushController'\n\nexport interface BatchConfiguration {\n  endpoint: EndpointBuilder\n  encoder: Encoder\n}\n\ninterface ReplicaBatchConfiguration<T> extends BatchConfiguration {\n  transformMessage?: (message: T) => T\n}\n\nexport function startBatchWithReplica<T extends Context>(\n  configuration: Configuration,\n  primary: BatchConfiguration,\n  replica: ReplicaBatchConfiguration<T> | undefined,\n  reportError: (error: RawError) => void,\n  pageMayExitObservable: Observable<PageMayExitEvent>,\n  sessionExpireObservable: Observable<void>,\n  batchFactoryImp = createBatch\n) {\n  const primaryBatch = createBatchFromConfig(configuration, primary)\n  const replicaBatch = replica && createBatchFromConfig(configuration, replica)\n\n  function createBatchFromConfig(configuration: Configuration, { endpoint, encoder }: BatchConfiguration) {\n    return batchFactoryImp({\n      encoder,\n      request: createHttpRequest(endpoint, configuration.batchBytesLimit, reportError),\n      flushController: createFlushController({\n        messagesLimit: configuration.batchMessagesLimit,\n        bytesLimit: configuration.batchBytesLimit,\n        durationLimit: configuration.flushTimeout,\n        pageMayExitObservable,\n        sessionExpireObservable,\n      }),\n      messageBytesLimit: configuration.messageBytesLimit,\n    })\n  }\n\n  return {\n    flushObservable: primaryBatch.flushController.flushObservable,\n\n    add(message: T, replicated = true) {\n      primaryBatch.add(message)\n      if (replicaBatch && replicated) {\n        replicaBatch.add(replica.transformMessage ? replica.transformMessage(message) : message)\n      }\n    },\n\n    upsert: (message: T, key: string) => {\n      primaryBatch.upsert(message, key)\n      if (replicaBatch) {\n        replicaBatch.upsert(replica.transformMessage ? replica.transformMessage(message) : message, key)\n      }\n    },\n\n    stop: () => {\n      primaryBatch.stop()\n      if (replicaBatch) {\n        replicaBatch.stop()\n      }\n    },\n  }\n}\n", "import { display } from '../display'\nimport { ONE_KIBI_BYTE } from '../utils/byteUtils'\nimport type { Context, ContextArray, ContextValue } from './context'\nimport type { ObjectWithToJsonMethod } from './jsonStringify'\nimport { detachToJsonMethod } from './jsonStringify'\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\ntype PrimitivesAndFunctions = string | number | boolean | undefined | null | symbol | bigint | Function\ntype ExtendedContextValue = PrimitivesAndFunctions | object | ExtendedContext | ExtendedContextArray\ntype ExtendedContext = { [key: string]: ExtendedContextValue }\ntype ExtendedContextArray = ExtendedContextValue[]\n\ntype ContainerElementToProcess = {\n  source: ExtendedContextArray | ExtendedContext\n  target: ContextArray | Context\n  path: string\n}\n\ntype SanitizedEvent = {\n  type: string\n  isTrusted: boolean\n  currentTarget: string | null | undefined\n  target: string | null | undefined\n}\n\n// The maximum size of a single event is 256KiB. By default, we ensure that user-provided data\n// going through sanitize fits inside our events, while leaving room for other contexts, metadata, ...\nconst SANITIZE_DEFAULT_MAX_CHARACTER_COUNT = 220 * ONE_KIBI_BYTE\n\n// Symbol for the root element of the JSONPath used for visited objects\nconst JSON_PATH_ROOT_ELEMENT = '$'\n\n// When serializing (using JSON.stringify) a key of an object, { key: 42 } gets wrapped in quotes as \"key\".\n// With the separator (:), we need to add 3 characters to the count.\nconst KEY_DECORATION_LENGTH = 3\n\n/**\n * Ensures user-provided data is 'safe' for the SDK\n * - Deep clones data\n * - Removes cyclic references\n * - Transforms unserializable types to a string representation\n *\n * LIMITATIONS:\n * - Size is in characters, not byte count (may differ according to character encoding)\n * - Size does not take into account indentation that can be applied to JSON.stringify\n * - Non-numerical properties of Arrays are ignored. Same behavior as JSON.stringify\n *\n * @param source              User-provided data meant to be serialized using JSON.stringify\n * @param maxCharacterCount   Maximum number of characters allowed in serialized form\n */\nexport function sanitize(source: string, maxCharacterCount?: number): string | undefined\nexport function sanitize(source: Context, maxCharacterCount?: number): Context\nexport function sanitize(source: unknown, maxCharacterCount?: number): ContextValue\nexport function sanitize(source: unknown, maxCharacterCount = SANITIZE_DEFAULT_MAX_CHARACTER_COUNT) {\n  // Unbind any toJSON function we may have on [] or {} prototypes\n  const restoreObjectPrototypeToJson = detachToJsonMethod(Object.prototype)\n  const restoreArrayPrototypeToJson = detachToJsonMethod(Array.prototype)\n\n  // Initial call to sanitizeProcessor - will populate containerQueue if source is an Array or a plain Object\n  const containerQueue: ContainerElementToProcess[] = []\n  const visitedObjectsWithPath = new WeakMap<object, string>()\n  const sanitizedData = sanitizeProcessor(\n    source as ExtendedContextValue,\n    JSON_PATH_ROOT_ELEMENT,\n    undefined,\n    containerQueue,\n    visitedObjectsWithPath\n  )\n  const serializedSanitizedData = JSON.stringify(sanitizedData)\n  let accumulatedCharacterCount = serializedSanitizedData ? serializedSanitizedData.length : 0\n\n  if (accumulatedCharacterCount > maxCharacterCount) {\n    warnOverCharacterLimit(maxCharacterCount, 'discarded', source)\n    return undefined\n  }\n\n  while (containerQueue.length > 0 && accumulatedCharacterCount < maxCharacterCount) {\n    const containerToProcess = containerQueue.shift()!\n    let separatorLength = 0 // 0 for the first element, 1 for subsequent elements\n\n    // Arrays and Objects have to be handled distinctly to ensure\n    // we do not pick up non-numerical properties from Arrays\n    if (Array.isArray(containerToProcess.source)) {\n      for (let key = 0; key < containerToProcess.source.length; key++) {\n        const targetData = sanitizeProcessor(\n          containerToProcess.source[key],\n          containerToProcess.path,\n          key,\n          containerQueue,\n          visitedObjectsWithPath\n        )\n\n        if (targetData !== undefined) {\n          accumulatedCharacterCount += JSON.stringify(targetData).length\n        } else {\n          // When an element of an Array (targetData) is undefined, it is serialized as null:\n          // JSON.stringify([undefined]) => '[null]' - This accounts for 4 characters\n          accumulatedCharacterCount += 4\n        }\n        accumulatedCharacterCount += separatorLength\n        separatorLength = 1\n        if (accumulatedCharacterCount > maxCharacterCount) {\n          warnOverCharacterLimit(maxCharacterCount, 'truncated', source)\n          break\n        }\n        ;(containerToProcess.target as ContextArray)[key] = targetData\n      }\n    } else {\n      for (const key in containerToProcess.source) {\n        if (Object.prototype.hasOwnProperty.call(containerToProcess.source, key)) {\n          const targetData = sanitizeProcessor(\n            containerToProcess.source[key],\n            containerToProcess.path,\n            key,\n            containerQueue,\n            visitedObjectsWithPath\n          )\n          // When a property of an object has an undefined value, it will be dropped during serialization:\n          // JSON.stringify({a:undefined}) => '{}'\n          if (targetData !== undefined) {\n            accumulatedCharacterCount +=\n              JSON.stringify(targetData).length + separatorLength + key.length + KEY_DECORATION_LENGTH\n            separatorLength = 1\n          }\n          if (accumulatedCharacterCount > maxCharacterCount) {\n            warnOverCharacterLimit(maxCharacterCount, 'truncated', source)\n            break\n          }\n          ;(containerToProcess.target as Context)[key] = targetData\n        }\n      }\n    }\n  }\n\n  // Rebind detached toJSON functions\n  restoreObjectPrototypeToJson()\n  restoreArrayPrototypeToJson()\n\n  return sanitizedData\n}\n\n/**\n * Internal function to factorize the process common to the\n * initial call to sanitize, and iterations for Arrays and Objects\n *\n */\nfunction sanitizeProcessor(\n  source: ExtendedContextValue,\n  parentPath: string,\n  key: string | number | undefined,\n  queue: ContainerElementToProcess[],\n  visitedObjectsWithPath: WeakMap<object, string>\n) {\n  // Start by handling toJSON, as we want to sanitize its output\n  const sourceToSanitize = tryToApplyToJSON(source)\n\n  if (!sourceToSanitize || typeof sourceToSanitize !== 'object') {\n    return sanitizePrimitivesAndFunctions(sourceToSanitize)\n  }\n\n  const sanitizedSource = sanitizeObjects(sourceToSanitize)\n  if (sanitizedSource !== '[Object]' && sanitizedSource !== '[Array]' && sanitizedSource !== '[Error]') {\n    return sanitizedSource\n  }\n\n  // Handle potential cyclic references\n  // We need to use source as sourceToSanitize could be a reference to a new object\n  // At this stage, we know the source is an object type\n  const sourceAsObject = source as object\n  if (visitedObjectsWithPath.has(sourceAsObject)) {\n    return `[Reference seen at ${visitedObjectsWithPath.get(sourceAsObject)!}]`\n  }\n\n  // Add processed source to queue\n  const currentPath = key !== undefined ? `${parentPath}.${key}` : parentPath\n  const target = Array.isArray(sourceToSanitize) ? ([] as ContextArray) : ({} as Context)\n  visitedObjectsWithPath.set(sourceAsObject, currentPath)\n  queue.push({ source: sourceToSanitize as ExtendedContext | ExtendedContextArray, target, path: currentPath })\n\n  return target\n}\n\n/**\n * Handles sanitization of simple, non-object types\n *\n */\nfunction sanitizePrimitivesAndFunctions(value: PrimitivesAndFunctions) {\n  // BigInt cannot be serialized by JSON.stringify(), convert it to a string representation\n  if (typeof value === 'bigint') {\n    return `[BigInt] ${value.toString()}`\n  }\n  // Functions cannot be serialized by JSON.stringify(). Moreover, if a faulty toJSON is present, it needs to be converted\n  // so it won't prevent stringify from serializing later\n  if (typeof value === 'function') {\n    return `[Function] ${value.name || 'unknown'}`\n  }\n  // JSON.stringify() does not serialize symbols.\n  if (typeof value === 'symbol') {\n    // symbol.description is part of ES2019+\n    type symbolWithDescription = symbol & { description: string }\n    return `[Symbol] ${(value as symbolWithDescription).description || value.toString()}`\n  }\n\n  return value\n}\n\n/**\n * Handles sanitization of object types\n *\n * LIMITATIONS\n * - If a class defines a toStringTag Symbol, it will fall in the catch-all method and prevent enumeration of properties.\n * To avoid this, a toJSON method can be defined.\n */\nfunction sanitizeObjects(value: object): string | SanitizedEvent {\n  try {\n    if (value instanceof Event) {\n      return sanitizeEvent(value)\n    }\n\n    if (value instanceof RegExp) {\n      return `[RegExp] ${value.toString()}`\n    }\n\n    // Handle all remaining object types in a generic way\n    const result = Object.prototype.toString.call(value)\n    const match = result.match(/\\[object (.*)\\]/)\n    if (match && match[1]) {\n      return `[${match[1]}]`\n    }\n  } catch {\n    // If the previous serialization attempts failed, and we cannot convert using\n    // Object.prototype.toString, declare the value unserializable\n  }\n  return '[Unserializable]'\n}\n\nfunction sanitizeEvent(event: Event): SanitizedEvent {\n  return {\n    type: event.type,\n    isTrusted: event.isTrusted,\n    currentTarget: event.currentTarget ? (sanitizeObjects(event.currentTarget) as string) : null,\n    target: event.target ? (sanitizeObjects(event.target) as string) : null,\n  }\n}\n\n/**\n * Checks if a toJSON function exists and tries to execute it\n *\n */\nfunction tryToApplyToJSON(value: ExtendedContextValue) {\n  const object = value as ObjectWithToJsonMethod\n  if (object && typeof object.toJSON === 'function') {\n    try {\n      return object.toJSON() as ExtendedContextValue\n    } catch {\n      // If toJSON fails, we continue by trying to serialize the value manually\n    }\n  }\n\n  return value\n}\n\n/**\n * Helper function to display the warning when the accumulated character count is over the limit\n */\nfunction warnOverCharacterLimit(maxCharacterCount: number, changeType: 'discarded' | 'truncated', source: unknown) {\n  display.warn(\n    `The data provided has been ${changeType} as it is over the limit of ${maxCharacterCount} characters:`,\n    source\n  )\n}\n", "/**\n * Cross-browser stack trace computation.\n *\n * Reference implementation: https://github.com/csnover/TraceKit/blob/04530298073c3823de72deb0b97e7b38ca7bcb59/tracekit.js\n */\n\nexport interface StackFrame {\n  url?: string\n  func?: string\n  /** The arguments passed to the function, if known. */\n  args?: string[]\n  line?: number\n  column?: number\n  /** An array of source code lines; the middle element corresponds to the correct line. */\n  context?: string[]\n}\n\nexport interface StackTrace {\n  name?: string\n  message?: string\n  url?: string\n  stack: StackFrame[]\n  incomplete?: boolean\n  partial?: boolean\n}\n\nconst UNKNOWN_FUNCTION = '?'\n\nexport function computeStackTrace(ex: unknown): StackTrace {\n  const stack: StackFrame[] = []\n\n  let stackProperty = tryToGetString(ex, 'stack')\n  const exString = String(ex)\n  if (stackProperty && stackProperty.startsWith(exString)) {\n    stackProperty = stackProperty.slice(exString.length)\n  }\n  if (stackProperty) {\n    stackProperty.split('\\n').forEach((line) => {\n      const stackFrame =\n        parseChromeLine(line) || parseChromeAnonymousLine(line) || parseWinLine(line) || parseGeckoLine(line)\n      if (stackFrame) {\n        if (!stackFrame.func && stackFrame.line) {\n          stackFrame.func = UNKNOWN_FUNCTION\n        }\n\n        stack.push(stackFrame)\n      }\n    })\n  }\n\n  if (stack.length > 0 && isWronglyReportingCustomErrors() && ex instanceof Error) {\n    // if we are wrongly reporting custom errors\n    const constructors: string[] = []\n\n    // go through each inherited constructor\n    let currentPrototype: object | undefined = ex\n    while (\n      (currentPrototype = Object.getPrototypeOf(currentPrototype)) &&\n      isNonNativeClassPrototype(currentPrototype)\n    ) {\n      const constructorName = currentPrototype.constructor?.name || UNKNOWN_FUNCTION\n      constructors.push(constructorName)\n    }\n\n    // traverse the stacktrace in reverse order because the stacktrace starts with the last inherited constructor\n    // we check constructor names to ensure we remove the correct frame (and there isn't a weird unsupported environment behavior)\n    for (let i = constructors.length - 1; i >= 0 && stack[0]?.func === constructors[i]; i--) {\n      // if the first stack frame is the custom error constructor\n      // null stack frames may represent frames that failed to be parsed because the error class did not have a constructor\n      stack.shift() // remove it\n    }\n  }\n\n  return {\n    message: tryToGetString(ex, 'message'),\n    name: tryToGetString(ex, 'name'),\n    stack,\n  }\n}\nconst fileUrl =\n  '((?:file|https?|blob|chrome-extension|electron|native|eval|webpack|snippet|<anonymous>|\\\\w+\\\\.|\\\\/).*?)'\nconst filePosition = '(?::(\\\\d+))'\nconst CHROME_LINE_RE = new RegExp(`^\\\\s*at (.*?) ?\\\\(${fileUrl}${filePosition}?${filePosition}?\\\\)?\\\\s*$`, 'i')\n\nconst CHROME_EVAL_RE = new RegExp(`\\\\((\\\\S*)${filePosition}${filePosition}\\\\)`)\n\nfunction parseChromeLine(line: string): StackFrame | undefined {\n  const parts = CHROME_LINE_RE.exec(line)\n\n  if (!parts) {\n    return\n  }\n\n  const isNative = parts[2] && parts[2].indexOf('native') === 0 // start of line\n  const isEval = parts[2] && parts[2].indexOf('eval') === 0 // start of line\n  const submatch = CHROME_EVAL_RE.exec(parts[2])\n\n  if (isEval && submatch) {\n    // throw out eval line/column and use top-most line/column number\n    parts[2] = submatch[1] // url\n    parts[3] = submatch[2] // line\n    parts[4] = submatch[3] // column\n  }\n\n  return {\n    args: isNative ? [parts[2]] : [],\n    column: parts[4] ? +parts[4] : undefined,\n    func: parts[1] || UNKNOWN_FUNCTION,\n    line: parts[3] ? +parts[3] : undefined,\n    url: !isNative ? parts[2] : undefined,\n  }\n}\n\nconst CHROME_ANONYMOUS_FUNCTION_RE = new RegExp(`^\\\\s*at ?${fileUrl}${filePosition}?${filePosition}??\\\\s*$`, 'i')\n\nfunction parseChromeAnonymousLine(line: string): StackFrame | undefined {\n  const parts = CHROME_ANONYMOUS_FUNCTION_RE.exec(line)\n\n  if (!parts) {\n    return\n  }\n\n  return {\n    args: [],\n    column: parts[3] ? +parts[3] : undefined,\n    func: UNKNOWN_FUNCTION,\n    line: parts[2] ? +parts[2] : undefined,\n    url: parts[1],\n  }\n}\n\nconst WINJS_LINE_RE =\n  /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i\n\nfunction parseWinLine(line: string): StackFrame | undefined {\n  const parts = WINJS_LINE_RE.exec(line)\n  if (!parts) {\n    return\n  }\n\n  return {\n    args: [],\n    column: parts[4] ? +parts[4] : undefined,\n    func: parts[1] || UNKNOWN_FUNCTION,\n    line: +parts[3],\n    url: parts[2],\n  }\n}\n\nconst GECKO_LINE_RE =\n  /^\\s*(.*?)(?:\\((.*?)\\))?(?:(?:(?:^|@)((?:file|https?|blob|chrome|webpack|resource|capacitor|\\[native).*?|[^@]*bundle|\\[wasm code\\])(?::(\\d+))?(?::(\\d+))?)|@)\\s*$/i\nconst GECKO_EVAL_RE = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i\n\nfunction parseGeckoLine(line: string): StackFrame | undefined {\n  const parts = GECKO_LINE_RE.exec(line)\n  if (!parts) {\n    return\n  }\n\n  const isEval = parts[3] && parts[3].indexOf(' > eval') > -1\n  const submatch = GECKO_EVAL_RE.exec(parts[3])\n\n  if (isEval && submatch) {\n    // throw out eval line/column and use top-most line number\n    parts[3] = submatch[1]\n    parts[4] = submatch[2]\n    parts[5] = undefined! // no column when eval\n  }\n\n  return {\n    args: parts[2] ? parts[2].split(',') : [],\n    column: parts[5] ? +parts[5] : undefined,\n    func: parts[1] || UNKNOWN_FUNCTION,\n    line: parts[4] ? +parts[4] : undefined,\n    url: parts[3],\n  }\n}\n\nfunction tryToGetString(candidate: unknown, property: string) {\n  if (typeof candidate !== 'object' || !candidate || !(property in candidate)) {\n    return undefined\n  }\n  const value = (candidate as { [k: string]: unknown })[property]\n  return typeof value === 'string' ? value : undefined\n}\n\nexport function computeStackTraceFromOnErrorMessage(\n  messageObj: unknown,\n  url?: string,\n  line?: number,\n  column?: number\n): StackTrace | undefined {\n  if (url === undefined) {\n    return\n  }\n  const { name, message } = tryToParseMessage(messageObj)\n  return {\n    name,\n    message,\n    stack: [{ url, column, line }],\n  }\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types\nconst ERROR_TYPES_RE =\n  /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?([\\s\\S]*)$/\n\nfunction tryToParseMessage(messageObj: unknown) {\n  let name\n  let message\n  if ({}.toString.call(messageObj) === '[object String]') {\n    ;[, name, message] = ERROR_TYPES_RE.exec(messageObj as string)!\n  }\n  return { name, message }\n}\n\n// Custom error stacktrace fix\n// Some browsers (safari/firefox) add the error constructor as a frame in the stacktrace\n// In order to normalize the stacktrace, we need to remove it\n\nfunction isNonNativeClassPrototype(prototype: object) {\n  return String(prototype.constructor).startsWith('class ')\n}\n\nlet isWronglyReportingCustomErrorsCache: boolean | undefined\n\nfunction isWronglyReportingCustomErrors() {\n  if (isWronglyReportingCustomErrorsCache !== undefined) {\n    return isWronglyReportingCustomErrorsCache\n  }\n\n  /* eslint-disable no-restricted-syntax */\n  class DatadogTestCustomError extends Error {\n    constructor() {\n      super()\n      this.name = 'Error' // set name to Error so that no browser would default to the constructor name\n    }\n  }\n\n  const [customError, nativeError] = [DatadogTestCustomError, Error].map((errConstructor) => new errConstructor()) // so that both errors should exactly have the same stacktrace\n\n  isWronglyReportingCustomErrorsCache =\n    // If customError is not a class, it means that this was built with ES5 as target, converting the class to a normal object.\n    // Thus, error constructors will be reported on all browsers, which is the expected behavior.\n    isNonNativeClassPrototype(Object.getPrototypeOf(customError)) &&\n    // If the browser is correctly reporting the stacktrace, the normal error stacktrace should be the same as the custom error stacktrace\n    nativeError.stack !== customError.stack\n\n  return isWronglyReportingCustomErrorsCache\n}\n", "import { callMonitored } from '../monitor'\nimport type { StackTrace } from './computeStackTrace'\nimport { computeStackTrace } from './computeStackTrace'\n\n/**\n * Creates a stacktrace without SDK internal frames.\n * Constraints:\n * - Has to be called at the utmost position of the call stack.\n * - No monitored function should encapsulate it, that is why we need to use callMonitored inside it.\n */\nexport function createHandlingStack(\n  type: 'console error' | 'action' | 'error' | 'instrumented method' | 'log' | 'react error'\n): string {\n  /**\n   * Skip the two internal frames:\n   * - SDK API (console.error, ...)\n   * - this function\n   * in order to keep only the user calls\n   */\n  const internalFramesToSkip = 2\n  const error = new Error(type)\n  error.name = 'HandlingStack'\n  let formattedStack: string\n\n  callMonitored(() => {\n    const stackTrace = computeStackTrace(error)\n    stackTrace.stack = stackTrace.stack.slice(internalFramesToSkip)\n    formattedStack = toStackTraceString(stackTrace)\n  })\n\n  return formattedStack!\n}\n\nexport function toStackTraceString(stack: StackTrace) {\n  let result = formatErrorMessage(stack)\n  stack.stack.forEach((frame) => {\n    const func = frame.func === '?' ? '<anonymous>' : frame.func\n    const args = frame.args && frame.args.length > 0 ? `(${frame.args.join(', ')})` : ''\n    const line = frame.line ? `:${frame.line}` : ''\n    const column = frame.line && frame.column ? `:${frame.column}` : ''\n    result += `\\n  at ${func!}${args} @ ${frame.url!}${line}${column}`\n  })\n  return result\n}\n\nexport function formatErrorMessage(stack: StackTrace) {\n  return `${stack.name || 'Error'}: ${stack.message!}`\n}\n", "import { sanitize } from '../../tools/serialisation/sanitize'\nimport type { ClocksState } from '../../tools/utils/timeUtils'\nimport type { Context } from '../../tools/serialisation/context'\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify'\nimport type { StackTrace } from '../../tools/stackTrace/computeStackTrace'\nimport { computeStackTrace } from '../../tools/stackTrace/computeStackTrace'\nimport { toStackTraceString } from '../../tools/stackTrace/handlingStack'\nimport type { ErrorSource, ErrorHandling, RawError, RawErrorCause, ErrorWithCause, NonErrorPrefix } from './error.types'\n\nexport const NO_ERROR_STACK_PRESENT_MESSAGE = 'No stack, consider using an instance of Error'\n\ntype RawErrorParams = {\n  stackTrace?: StackTrace\n  originalError: unknown\n  handlingStack?: string\n  componentStack?: string\n  startClocks: ClocksState\n  nonErrorPrefix: NonErrorPrefix\n  useFallbackStack?: boolean\n  source: ErrorSource\n  handling: ErrorHandling\n}\n\nexport function computeRawError({\n  stackTrace,\n  originalError,\n  handlingStack,\n  componentStack,\n  startClocks,\n  nonErrorPrefix,\n  useFallbackStack = true,\n  source,\n  handling,\n}: RawErrorParams): RawError {\n  const isErrorInstance = isError(originalError)\n  if (!stackTrace && isErrorInstance) {\n    stackTrace = computeStackTrace(originalError)\n  }\n\n  return {\n    startClocks,\n    source,\n    handling,\n    handlingStack,\n    componentStack,\n    originalError,\n    type: stackTrace ? stackTrace.name : undefined,\n    message: computeMessage(stackTrace, isErrorInstance, nonErrorPrefix, originalError),\n    stack: stackTrace ? toStackTraceString(stackTrace) : useFallbackStack ? NO_ERROR_STACK_PRESENT_MESSAGE : undefined,\n    causes: isErrorInstance ? flattenErrorCauses(originalError as ErrorWithCause, source) : undefined,\n    fingerprint: tryToGetFingerprint(originalError),\n    context: tryToGetErrorContext(originalError),\n  }\n}\n\nfunction computeMessage(\n  stackTrace: StackTrace | undefined,\n  isErrorInstance: boolean,\n  nonErrorPrefix: NonErrorPrefix,\n  originalError: unknown\n) {\n  // Favor stackTrace message only if tracekit has really been able to extract something meaningful (message + name)\n  // TODO rework tracekit integration to avoid scattering error building logic\n  return stackTrace?.message && stackTrace?.name\n    ? stackTrace.message\n    : !isErrorInstance\n      ? `${nonErrorPrefix} ${jsonStringify(sanitize(originalError))!}`\n      : 'Empty message'\n}\n\nexport function tryToGetFingerprint(originalError: unknown) {\n  return isError(originalError) && 'dd_fingerprint' in originalError ? String(originalError.dd_fingerprint) : undefined\n}\n\nexport function tryToGetErrorContext(originalError: unknown) {\n  if (originalError !== null && typeof originalError === 'object' && 'dd_context' in originalError) {\n    return originalError.dd_context as Context\n  }\n}\n\nexport function getFileFromStackTraceString(stack: string) {\n  return /@ (.+)/.exec(stack)?.[1]\n}\n\nexport function isError(error: unknown): error is Error {\n  return error instanceof Error || Object.prototype.toString.call(error) === '[object Error]'\n}\n\nexport function flattenErrorCauses(error: ErrorWithCause, parentSource: ErrorSource): RawErrorCause[] | undefined {\n  let currentError = error\n  const causes: RawErrorCause[] = []\n  while (isError(currentError?.cause) && causes.length < 10) {\n    const stackTrace = computeStackTrace(currentError.cause)\n    causes.push({\n      message: currentError.cause.message,\n      source: parentSource,\n      type: stackTrace?.name,\n      stack: stackTrace && toStackTraceString(stackTrace),\n    })\n    currentError = currentError.cause\n  }\n  return causes.length ? causes : undefined\n}\n", "export function shallowClone<T>(object: T): T & Record<string, never> {\n  return { ...object } as T & Record<string, never>\n}\n\nexport function objectHasValue<T extends { [key: string]: unknown }>(object: T, value: unknown): value is T[keyof T] {\n  return Object.keys(object).some((key) => object[key] === value)\n}\n\nexport function isEmptyObject(object: object) {\n  return Object.keys(object).length === 0\n}\n\nexport function mapValues<A, B>(object: { [key: string]: A }, fn: (arg: A) => B) {\n  const newObject: { [key: string]: B } = {}\n  for (const key of Object.keys(object)) {\n    newObject[key] = fn(object[key])\n  }\n  return newObject\n}\n", "/**\n * LIMITATION:\n * For NPM setup, this feature flag singleton is shared between RUM and Logs product.\n * This means that an experimental flag set on the RUM product will be set on the Logs product.\n * So keep in mind that in certain configurations, your experimental feature flag may affect other products.\n *\n * FORMAT:\n * All feature flags should be snake_cased\n */\n// We want to use a real enum (i.e. not a const enum) here, to be able to check whether an arbitrary\n// string is an expected feature flag\n\nimport { objectHasValue } from './utils/objectUtils'\n\n// eslint-disable-next-line no-restricted-syntax\nexport enum ExperimentalFeature {\n  TRACK_INTAKE_REQUESTS = 'track_intake_requests',\n  WRITABLE_RESOURCE_GRAPHQL = 'writable_resource_graphql',\n}\n\nconst enabledExperimentalFeatures: Set<ExperimentalFeature> = new Set()\n\nexport function initFeatureFlags(enableExperimentalFeatures: string[] | undefined) {\n  if (Array.isArray(enableExperimentalFeatures)) {\n    addExperimentalFeatures(\n      enableExperimentalFeatures.filter((flag): flag is ExperimentalFeature =>\n        objectHasValue(ExperimentalFeature, flag)\n      )\n    )\n  }\n}\n\nexport function addExperimentalFeatures(enabledFeatures: ExperimentalFeature[]): void {\n  enabledFeatures.forEach((flag) => {\n    enabledExperimentalFeatures.add(flag)\n  })\n}\n\nexport function isExperimentalFeatureEnabled(featureName: ExperimentalFeature): boolean {\n  return enabledExperimentalFeatures.has(featureName)\n}\n\nexport function resetExperimentalFeatures(): void {\n  enabledExperimentalFeatures.clear()\n}\n\nexport function getExperimentalFeatures(): Set<ExperimentalFeature> {\n  return enabledExperimentalFeatures\n}\n", "export type Site =\n  | 'datadoghq.com'\n  | 'us3.datadoghq.com'\n  | 'us5.datadoghq.com'\n  | 'datadoghq.eu'\n  | 'ddog-gov.com'\n  | 'ap1.datadoghq.com'\n\nexport const INTAKE_SITE_STAGING: Site = 'datad0g.com' as Site\nexport const INTAKE_SITE_FED_STAGING: Site = 'dd0g-gov.com' as Site\nexport const INTAKE_SITE_US1: Site = 'datadoghq.com'\nexport const INTAKE_SITE_EU1: Site = 'datadoghq.eu'\nexport const INTAKE_SITE_US1_FED: Site = 'ddog-gov.com'\n\nexport const PCI_INTAKE_HOST_US1 = 'pci.browser-intake-datadoghq.com'\nexport const INTAKE_URL_PARAMETERS = ['ddsource', 'ddtags']\n", "interface BrowserWindow {\n  __ddBrowserSdkExtensionCallback?: (message: unknown) => void\n}\n\ntype ExtensionMessageType = 'logs' | 'record' | 'rum' | 'telemetry'\n\nexport function sendToExtension(type: ExtensionMessageType, payload: unknown) {\n  const callback = (window as BrowserWindow).__ddBrowserSdkExtensionCallback\n  if (callback) {\n    callback({ type, payload })\n  }\n}\n", "/**\n * Similar to `typeof`, but distinguish plain objects from `null` and arrays\n */\nexport function getType(value: unknown) {\n  if (value === null) {\n    return 'null'\n  }\n  if (Array.isArray(value)) {\n    return 'array'\n  }\n  return typeof value\n}\n", "import { getType } from './utils/typeUtils'\n\ntype Merged<TDestination, TSource> =\n  // case 1 - source is undefined - return destination\n  TSource extends undefined\n    ? TDestination\n    : // case 2 - destination is undefined - return source\n      TDestination extends undefined\n      ? TSource\n      : // case 3 - source is an array - see if it merges or overwrites\n        TSource extends any[]\n        ? TDestination extends any[]\n          ? TDestination & TSource\n          : TSource\n        : // case 4 - source is an object - see if it merges or overwrites\n          TSource extends object\n          ? TDestination extends object\n            ? TDestination extends any[]\n              ? TSource\n              : TDestination & TSource\n            : TSource\n          : // case 5 - cannot merge - return source\n            TSource\n\n/**\n * Iterate over source and affect its sub values into destination, recursively.\n * If the source and destination can't be merged, return source.\n */\nexport function mergeInto<D, S>(\n  destination: D,\n  source: S,\n  circularReferenceChecker = createCircularReferenceChecker()\n): Merged<D, S> {\n  // ignore the source if it is undefined\n  if (source === undefined) {\n    return destination as Merged<D, S>\n  }\n\n  if (typeof source !== 'object' || source === null) {\n    // primitive values - just return source\n    return source as Merged<D, S>\n  } else if (source instanceof Date) {\n    return new Date(source.getTime()) as unknown as Merged<D, S>\n  } else if (source instanceof RegExp) {\n    const flags =\n      source.flags ||\n      // old browsers compatibility\n      [\n        source.global ? 'g' : '',\n        source.ignoreCase ? 'i' : '',\n        source.multiline ? 'm' : '',\n        source.sticky ? 'y' : '',\n        source.unicode ? 'u' : '',\n      ].join('')\n    return new RegExp(source.source, flags) as unknown as Merged<D, S>\n  }\n\n  if (circularReferenceChecker.hasAlreadyBeenSeen(source)) {\n    // remove circular references\n    return undefined as unknown as Merged<D, S>\n  } else if (Array.isArray(source)) {\n    const merged: any[] = Array.isArray(destination) ? destination : []\n    for (let i = 0; i < source.length; ++i) {\n      merged[i] = mergeInto(merged[i], source[i], circularReferenceChecker)\n    }\n    return merged as unknown as Merged<D, S>\n  }\n\n  const merged = getType(destination) === 'object' ? (destination as Record<any, any>) : {}\n  for (const key in source) {\n    if (Object.prototype.hasOwnProperty.call(source, key)) {\n      merged[key] = mergeInto(merged[key], source[key], circularReferenceChecker)\n    }\n  }\n  return merged as unknown as Merged<D, S>\n}\n\n/**\n * A simplistic implementation of a deep clone algorithm.\n * Caveats:\n * - It doesn't maintain prototype chains - don't use with instances of custom classes.\n * - It doesn't handle Map and Set\n */\nexport function deepClone<T>(value: T): T {\n  return mergeInto(undefined, value) as T\n}\n\ntype Combined<A, B> = A extends null ? B : B extends null ? A : Merged<A, B>\n\n/*\n * Performs a deep merge of objects and arrays.\n * - Arguments won't be mutated\n * - Object and arrays in the output value are de-referenced (\"deep cloned\")\n * - Arrays values are merged index by index\n * - Objects are merged by keys\n * - Values get replaced, unless undefined\n */\nexport function combine<A, B>(a: A, b: B): Combined<A, B>\nexport function combine<A, B, C>(a: A, b: B, c: C): Combined<Combined<A, B>, C>\nexport function combine<A, B, C, D>(a: A, b: B, c: C, d: D): Combined<Combined<Combined<A, B>, C>, D>\nexport function combine<A, B, C, D, E>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E\n): Combined<Combined<Combined<Combined<A, B>, C>, D>, E>\nexport function combine<A, B, C, D, E, F>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n  f: F\n): Combined<Combined<Combined<Combined<Combined<A, B>, C>, D>, E>, F>\nexport function combine<A, B, C, D, E, F, G>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n  f: F,\n  g: G\n): Combined<Combined<Combined<Combined<Combined<Combined<A, B>, C>, D>, E>, F>, G>\nexport function combine<A, B, C, D, E, F, G, H>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n  f: F,\n  g: G,\n  h: H\n): Combined<Combined<Combined<Combined<Combined<Combined<Combined<A, B>, C>, D>, E>, F>, G>, H>\nexport function combine(...sources: any[]): unknown {\n  let destination: any\n\n  for (const source of sources) {\n    // Ignore any undefined or null sources.\n    if (source === undefined || source === null) {\n      continue\n    }\n\n    destination = mergeInto(destination, source)\n  }\n\n  return destination as unknown\n}\n\ninterface CircularReferenceChecker {\n  hasAlreadyBeenSeen(value: any): boolean\n}\n\nfunction createCircularReferenceChecker(): CircularReferenceChecker {\n  if (typeof WeakSet !== 'undefined') {\n    const set: WeakSet<any> = new WeakSet()\n    return {\n      hasAlreadyBeenSeen(value) {\n        const has = set.has(value)\n        if (!has) {\n          set.add(value)\n        }\n        return has\n      },\n    }\n  }\n  const array: any[] = []\n  return {\n    hasAlreadyBeenSeen(value) {\n      const has = array.indexOf(value) >= 0\n      if (!has) {\n        array.push(value)\n      }\n      return has\n    },\n  }\n}\n", "export type NetworkInterface = 'bluetooth' | 'cellular' | 'ethernet' | 'none' | 'wifi' | 'wimax' | 'other' | 'unknown'\nexport type EffectiveType = 'slow-2g' | '2g' | '3g' | '4g'\n\ninterface BrowserNavigator extends Navigator {\n  connection?: NetworkInformation\n}\n\nexport interface NetworkInformation {\n  type?: NetworkInterface\n  effectiveType?: EffectiveType\n  saveData: boolean\n}\n\nexport interface Connectivity {\n  status: 'connected' | 'not_connected'\n  interfaces?: NetworkInterface[]\n  effective_type?: EffectiveType\n  [key: string]: unknown\n}\n\nexport function getConnectivity(): Connectivity {\n  const navigator = window.navigator as BrowserNavigator\n  return {\n    status: navigator.onLine ? 'connected' : 'not_connected',\n    interfaces: navigator.connection && navigator.connection.type ? [navigator.connection.type] : undefined,\n    effective_type: navigator.connection?.effectiveType,\n  }\n}\n", "export function removeDuplicates<T>(array: T[]) {\n  const set = new Set<T>()\n  array.forEach((item) => set.add(item))\n  return Array.from(set)\n}\n\nexport function removeItem<T>(array: T[], item: T) {\n  const index = array.indexOf(item)\n  if (index >= 0) {\n    array.splice(index, 1)\n  }\n}\n", "import { removeItem } from './utils/arrayUtils'\n\nconst BUFFER_LIMIT = 500\n\nexport interface BoundedBuffer<T = void> {\n  add: (callback: (arg: T) => void) => void\n  remove: (callback: (arg: T) => void) => void\n  drain: (arg: T) => void\n}\n\nexport function createBoundedBuffer<T = void>(): BoundedBuffer<T> {\n  const buffer: Array<(arg: T) => void> = []\n\n  const add: BoundedBuffer<T>['add'] = (callback: (arg: T) => void) => {\n    const length = buffer.push(callback)\n    if (length > BUFFER_LIMIT) {\n      buffer.splice(0, 1)\n    }\n  }\n\n  const remove: BoundedBuffer<T>['remove'] = (callback: (arg: T) => void) => {\n    removeItem(buffer, callback)\n  }\n\n  const drain = (arg: T) => {\n    buffer.forEach((callback) => callback(arg))\n    buffer.length = 0\n  }\n\n  return {\n    add,\n    remove,\n    drain,\n  }\n}\n", "import type { TelemetryEvent, TelemetryConfigurationEvent, TelemetryUsageEvent } from './telemetryEvent.types'\n\nexport const TelemetryType = {\n  LOG: 'log',\n  CONFIGURATION: 'configuration',\n  USAGE: 'usage',\n} as const\n\nexport const enum StatusType {\n  debug = 'debug',\n  error = 'error',\n}\n\nexport interface RuntimeEnvInfo {\n  is_local_file: boolean\n  is_worker: boolean\n}\n\nexport type RawTelemetryEvent = TelemetryEvent['telemetry']\nexport type RawTelemetryConfiguration = TelemetryConfigurationEvent['telemetry']['configuration']\nexport type RawTelemetryUsage = TelemetryUsageEvent['telemetry']['usage']\nexport type RawTelemetryUsageFeature = TelemetryUsageEvent['telemetry']['usage']['feature']\n", "import type { Context, ContextValue } from '../../tools/serialisation/context'\nimport { ConsoleApiName } from '../../tools/display'\nimport { NO_ERROR_STACK_PRESENT_MESSAGE, isError } from '../error/error'\nimport { toStackTraceString } from '../../tools/stackTrace/handlingStack'\nimport { getExperimentalFeatures } from '../../tools/experimentalFeatures'\nimport type { Configuration } from '../configuration'\nimport { INTAKE_SITE_STAGING, INTAKE_SITE_US1_FED } from '../intakeSites'\nimport { Observable } from '../../tools/observable'\nimport { timeStampNow } from '../../tools/utils/timeUtils'\nimport { displayIfDebugEnabled, startMonitorErrorCollection } from '../../tools/monitor'\nimport { sendToExtension } from '../../tools/sendToExtension'\nimport { performDraw } from '../../tools/utils/numberUtils'\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify'\nimport { combine } from '../../tools/mergeInto'\nimport type { RawError } from '../error/error.types'\nimport { NonErrorPrefix } from '../error/error.types'\nimport type { StackTrace } from '../../tools/stackTrace/computeStackTrace'\nimport { computeStackTrace } from '../../tools/stackTrace/computeStackTrace'\nimport { getConnectivity } from '../connectivity'\nimport { createBoundedBuffer } from '../../tools/boundedBuffer'\nimport { canUseEventBridge, getEventBridge, startBatchWithReplica } from '../../transport'\nimport type { Encoder } from '../../tools/encoder'\nimport type { PageMayExitEvent } from '../../browser/pageMayExitObservable'\nimport { DeflateEncoderStreamId } from '../deflate'\nimport type { TelemetryEvent } from './telemetryEvent.types'\nimport type {\n  RawTelemetryConfiguration,\n  RawTelemetryEvent,\n  RuntimeEnvInfo,\n  RawTelemetryUsage,\n} from './rawTelemetryEvent.types'\nimport { StatusType, TelemetryType } from './rawTelemetryEvent.types'\n\n// replaced at build time\ndeclare const __BUILD_ENV__SDK_VERSION__: string\ndeclare const __BUILD_ENV__SDK_SETUP__: string\n\nconst ALLOWED_FRAME_URLS = [\n  'https://www.datadoghq-browser-agent.com',\n  'https://www.datad0g-browser-agent.com',\n  'https://d3uc069fcn7uxw.cloudfront.net',\n  'https://d20xtzwzcl0ceb.cloudfront.net',\n  'http://localhost',\n  '<anonymous>',\n]\n\nexport const enum TelemetryService {\n  LOGS = 'browser-logs-sdk',\n  RUM = 'browser-rum-sdk',\n}\n\nexport interface Telemetry {\n  setContextProvider: (key: string, contextProvider: () => ContextValue | undefined) => void\n  stop: () => void\n  enabled: boolean\n}\n\nconst TELEMETRY_EXCLUDED_SITES: string[] = [INTAKE_SITE_US1_FED]\n\n// eslint-disable-next-line local-rules/disallow-side-effects\nlet preStartTelemetryBuffer = createBoundedBuffer()\nlet onRawTelemetryEventCollected = (event: RawTelemetryEvent) => {\n  preStartTelemetryBuffer.add(() => onRawTelemetryEventCollected(event))\n}\n\nexport function startTelemetry(\n  telemetryService: TelemetryService,\n  configuration: Configuration,\n  reportError: (error: RawError) => void,\n  pageMayExitObservable: Observable<PageMayExitEvent>,\n  createEncoder: (streamId: DeflateEncoderStreamId) => Encoder\n): Telemetry {\n  const observable = new Observable<TelemetryEvent & Context>()\n\n  const { stop } = startTelemetryTransport(configuration, reportError, pageMayExitObservable, createEncoder, observable)\n\n  const { enabled, setContextProvider } = startTelemetryCollection(telemetryService, configuration, observable)\n\n  return {\n    setContextProvider,\n    stop,\n    enabled,\n  }\n}\n\nexport function startTelemetryCollection(\n  telemetryService: TelemetryService,\n  configuration: Configuration,\n  observable: Observable<TelemetryEvent & Context>\n) {\n  const alreadySentEvents = new Set<string>()\n  const contextProviders = new Map<string, () => ContextValue | undefined>()\n\n  const telemetryEnabled =\n    !TELEMETRY_EXCLUDED_SITES.includes(configuration.site) && performDraw(configuration.telemetrySampleRate)\n\n  const telemetryEnabledPerType = {\n    [TelemetryType.LOG]: telemetryEnabled,\n    [TelemetryType.CONFIGURATION]: telemetryEnabled && performDraw(configuration.telemetryConfigurationSampleRate),\n    [TelemetryType.USAGE]: telemetryEnabled && performDraw(configuration.telemetryUsageSampleRate),\n  }\n\n  const runtimeEnvInfo = getRuntimeEnvInfo()\n  onRawTelemetryEventCollected = (rawEvent: RawTelemetryEvent) => {\n    const stringifiedEvent = jsonStringify(rawEvent)!\n    if (\n      telemetryEnabledPerType[rawEvent.type!] &&\n      alreadySentEvents.size < configuration.maxTelemetryEventsPerPage &&\n      !alreadySentEvents.has(stringifiedEvent)\n    ) {\n      const event = toTelemetryEvent(telemetryService, rawEvent, runtimeEnvInfo)\n      observable.notify(event)\n      sendToExtension('telemetry', event)\n      alreadySentEvents.add(stringifiedEvent)\n    }\n  }\n  // need to be called after telemetry context is provided and observers are registered\n  preStartTelemetryBuffer.drain()\n  startMonitorErrorCollection(addTelemetryError)\n\n  return {\n    setContextProvider: (key: string, contextProvider: () => ContextValue | undefined) =>\n      contextProviders.set(key, contextProvider),\n    enabled: telemetryEnabled,\n  }\n\n  function toTelemetryEvent(\n    telemetryService: TelemetryService,\n    rawEvent: RawTelemetryEvent,\n    runtimeEnvInfo: RuntimeEnvInfo\n  ): TelemetryEvent & Context {\n    const event = {\n      type: 'telemetry' as const,\n      date: timeStampNow(),\n      service: telemetryService,\n      version: __BUILD_ENV__SDK_VERSION__,\n      source: 'browser' as const,\n      _dd: {\n        format_version: 2 as const,\n      },\n      telemetry: combine(rawEvent, {\n        runtime_env: runtimeEnvInfo,\n        connectivity: getConnectivity(),\n        sdk_setup: __BUILD_ENV__SDK_SETUP__,\n      }) as TelemetryEvent['telemetry'],\n      experimental_features: Array.from(getExperimentalFeatures()),\n    } as TelemetryEvent & Context\n\n    for (const [key, contextProvider] of contextProviders) {\n      event[key] = contextProvider()\n    }\n\n    return event\n  }\n}\n\nfunction startTelemetryTransport(\n  configuration: Configuration,\n  reportError: (error: RawError) => void,\n  pageMayExitObservable: Observable<PageMayExitEvent>,\n  createEncoder: (streamId: DeflateEncoderStreamId) => Encoder,\n  telemetryObservable: Observable<TelemetryEvent & Context>\n) {\n  const cleanupTasks: Array<() => void> = []\n  if (canUseEventBridge()) {\n    const bridge = getEventBridge<'internal_telemetry', TelemetryEvent>()!\n    const telemetrySubscription = telemetryObservable.subscribe((event) => bridge.send('internal_telemetry', event))\n    cleanupTasks.push(() => telemetrySubscription.unsubscribe())\n  } else {\n    const telemetryBatch = startBatchWithReplica(\n      configuration,\n      {\n        endpoint: configuration.rumEndpointBuilder,\n        encoder: createEncoder(DeflateEncoderStreamId.TELEMETRY),\n      },\n      configuration.replica && {\n        endpoint: configuration.replica.rumEndpointBuilder,\n        encoder: createEncoder(DeflateEncoderStreamId.TELEMETRY_REPLICA),\n      },\n      reportError,\n      pageMayExitObservable,\n\n      // We don't use an actual session expire observable here, to make telemetry collection\n      // independent of the session. This allows to start and send telemetry events ealier.\n      new Observable()\n    )\n    cleanupTasks.push(() => telemetryBatch.stop())\n    const telemetrySubscription = telemetryObservable.subscribe((event) =>\n      telemetryBatch.add(event, isTelemetryReplicationAllowed(configuration))\n    )\n    cleanupTasks.push(() => telemetrySubscription.unsubscribe())\n  }\n\n  return {\n    stop: () => cleanupTasks.forEach((task) => task()),\n  }\n}\n\nfunction getRuntimeEnvInfo(): RuntimeEnvInfo {\n  return {\n    is_local_file: window.location.protocol === 'file:',\n    is_worker: 'WorkerGlobalScope' in self,\n  }\n}\n\nexport function startFakeTelemetry() {\n  const events: RawTelemetryEvent[] = []\n\n  onRawTelemetryEventCollected = (event: RawTelemetryEvent) => {\n    events.push(event)\n  }\n\n  return events\n}\n\nexport function resetTelemetry() {\n  preStartTelemetryBuffer = createBoundedBuffer()\n  onRawTelemetryEventCollected = (event: RawTelemetryEvent) => {\n    preStartTelemetryBuffer.add(() => onRawTelemetryEventCollected(event))\n  }\n}\n\n/**\n * Avoid mixing telemetry events from different data centers\n * but keep replicating staging events for reliability\n */\nexport function isTelemetryReplicationAllowed(configuration: Configuration) {\n  return configuration.site === INTAKE_SITE_STAGING\n}\n\nexport function addTelemetryDebug(message: string, context?: Context) {\n  displayIfDebugEnabled(ConsoleApiName.debug, message, context)\n  onRawTelemetryEventCollected({\n    type: TelemetryType.LOG,\n    message,\n    status: StatusType.debug,\n    ...context,\n  })\n}\n\nexport function addTelemetryError(e: unknown, context?: Context) {\n  onRawTelemetryEventCollected({\n    type: TelemetryType.LOG,\n    status: StatusType.error,\n    ...formatError(e),\n    ...context,\n  })\n}\n\nexport function addTelemetryConfiguration(configuration: RawTelemetryConfiguration) {\n  onRawTelemetryEventCollected({\n    type: TelemetryType.CONFIGURATION,\n    configuration,\n  })\n}\n\nexport function addTelemetryUsage(usage: RawTelemetryUsage) {\n  onRawTelemetryEventCollected({\n    type: TelemetryType.USAGE,\n    usage,\n  })\n}\n\nexport function formatError(e: unknown) {\n  if (isError(e)) {\n    const stackTrace = computeStackTrace(e)\n    return {\n      error: {\n        kind: stackTrace.name,\n        stack: toStackTraceString(scrubCustomerFrames(stackTrace)),\n      },\n      message: stackTrace.message!,\n    }\n  }\n  return {\n    error: {\n      stack: NO_ERROR_STACK_PRESENT_MESSAGE,\n    },\n    message: `${NonErrorPrefix.UNCAUGHT} ${jsonStringify(e)!}`,\n  }\n}\n\nexport function scrubCustomerFrames(stackTrace: StackTrace) {\n  stackTrace.stack = stackTrace.stack.filter(\n    (frame) => !frame.url || ALLOWED_FRAME_URLS.some((allowedFrameUrl) => frame.url!.startsWith(allowedFrameUrl))\n  )\n  return stackTrace\n}\n", "import { display } from './display'\n\nexport function catchUserErrors<Args extends any[], R>(fn: (...args: Args) => R, errorMsg: string) {\n  return (...args: Args) => {\n    try {\n      return fn(...args)\n    } catch (err) {\n      display.error(errorMsg, err)\n    }\n  }\n}\n", "/**\n * UUID v4\n * from https://gist.github.com/jed/982883\n */\nexport function generateUUID(placeholder?: string): string {\n  return placeholder\n    ? // eslint-disable-next-line  no-bitwise\n      (parseInt(placeholder, 10) ^ ((Math.random() * 16) >> (parseInt(placeholder, 10) / 4))).toString(16)\n    : `${1e7}-${1e3}-${4e3}-${8e3}-${1e11}`.replace(/[018]/g, generateUUID)\n}\n\nconst COMMA_SEPARATED_KEY_VALUE = /([\\w-]+)\\s*=\\s*([^;]+)/g\n\nexport function findCommaSeparatedValue(rawString: string, name: string): string | undefined {\n  COMMA_SEPARATED_KEY_VALUE.lastIndex = 0\n  while (true) {\n    const match = COMMA_SEPARATED_KEY_VALUE.exec(rawString)\n    if (match) {\n      if (match[1] === name) {\n        return match[2]\n      }\n    } else {\n      break\n    }\n  }\n}\n\nexport function findCommaSeparatedValues(rawString: string): Map<string, string> {\n  const result = new Map<string, string>()\n  COMMA_SEPARATED_KEY_VALUE.lastIndex = 0\n  while (true) {\n    const match = COMMA_SEPARATED_KEY_VALUE.exec(rawString)\n    if (match) {\n      result.set(match[1], match[2])\n    } else {\n      break\n    }\n  }\n  return result\n}\n\nexport function safeTruncate(candidate: string, length: number, suffix = '') {\n  const lastChar = candidate.charCodeAt(length - 1)\n  const isLastCharSurrogatePair = lastChar >= 0xd800 && lastChar <= 0xdbff\n  const correctedLength = isLastCharSurrogatePair ? length + 1 : length\n\n  if (candidate.length <= correctedLength) {\n    return candidate\n  }\n\n  return `${candidate.slice(0, correctedLength)}${suffix}`\n}\n", "// Exported only for tests\nexport const enum Browser {\n  CHROMIUM,\n  SAFARI,\n  OTHER,\n}\n\nexport function isChromium() {\n  return detectBrowserCached() === Browser.CHROMIUM\n}\n\nexport function isSafari() {\n  return detectBrowserCached() === Browser.SAFARI\n}\n\nlet browserCache: Browser | undefined\nfunction detectBrowserCached() {\n  return browserCache ?? (browserCache = detectBrowser())\n}\n\n// Exported only for tests\nexport function detectBrowser(browserWindow: Window = window) {\n  const userAgent = browserWindow.navigator.userAgent\n  if ((browserWindow as any).chrome || /HeadlessChrome/.test(userAgent)) {\n    return Browser.CHROMIUM\n  }\n\n  if (\n    // navigator.vendor is deprecated, but it is the most resilient way we found to detect\n    // \"Apple maintained browsers\" (AKA Safari). If one day it gets removed, we still have the\n    // useragent test as a semi-working fallback.\n    browserWindow.navigator.vendor?.indexOf('Apple') === 0 ||\n    (/safari/i.test(userAgent) && !/chrome|android/i.test(userAgent))\n  ) {\n    return Browser.SAFARI\n  }\n\n  return Browser.OTHER\n}\n", "import { display } from '../tools/display'\nimport { ONE_MINUTE, ONE_SECOND } from '../tools/utils/timeUtils'\nimport { findCommaSeparatedValue, findCommaSeparatedValues, generateUUID } from '../tools/utils/stringUtils'\n\nexport interface CookieOptions {\n  secure?: boolean\n  crossSite?: boolean\n  partitioned?: boolean\n  domain?: string\n}\n\nexport function setCookie(name: string, value: string, expireDelay: number = 0, options?: CookieOptions) {\n  const date = new Date()\n  date.setTime(date.getTime() + expireDelay)\n  const expires = `expires=${date.toUTCString()}`\n  const sameSite = options && options.crossSite ? 'none' : 'strict'\n  const domain = options && options.domain ? `;domain=${options.domain}` : ''\n  const secure = options && options.secure ? ';secure' : ''\n  const partitioned = options && options.partitioned ? ';partitioned' : ''\n  document.cookie = `${name}=${value};${expires};path=/;samesite=${sameSite}${domain}${secure}${partitioned}`\n}\n\nexport function getCookie(name: string) {\n  return findCommaSeparatedValue(document.cookie, name)\n}\n\nlet initCookieParsed: Map<string, string> | undefined\n\n/**\n * Returns a cached value of the cookie. Use this during SDK initialization (and whenever possible)\n * to avoid accessing document.cookie multiple times.\n */\nexport function getInitCookie(name: string) {\n  if (!initCookieParsed) {\n    initCookieParsed = findCommaSeparatedValues(document.cookie)\n  }\n  return initCookieParsed.get(name)\n}\n\nexport function resetInitCookies() {\n  initCookieParsed = undefined\n}\n\nexport function deleteCookie(name: string, options?: CookieOptions) {\n  setCookie(name, '', 0, options)\n}\n\nexport function areCookiesAuthorized(options: CookieOptions): boolean {\n  if (document.cookie === undefined || document.cookie === null) {\n    return false\n  }\n  try {\n    // Use a unique cookie name to avoid issues when the SDK is initialized multiple times during\n    // the test cookie lifetime\n    const testCookieName = `dd_cookie_test_${generateUUID()}`\n    const testCookieValue = 'test'\n    setCookie(testCookieName, testCookieValue, ONE_MINUTE, options)\n    const isCookieCorrectlySet = getCookie(testCookieName) === testCookieValue\n    deleteCookie(testCookieName, options)\n    return isCookieCorrectlySet\n  } catch (error) {\n    display.error(error)\n    return false\n  }\n}\n\n/**\n * No API to retrieve it, number of levels for subdomain and suffix are unknown\n * strategy: find the minimal domain on which cookies are allowed to be set\n * https://web.dev/same-site-same-origin/#site\n */\nlet getCurrentSiteCache: string | undefined\nexport function getCurrentSite() {\n  if (getCurrentSiteCache === undefined) {\n    // Use a unique cookie name to avoid issues when the SDK is initialized multiple times during\n    // the test cookie lifetime\n    const testCookieName = `dd_site_test_${generateUUID()}`\n    const testCookieValue = 'test'\n\n    const domainLevels = window.location.hostname.split('.')\n    let candidateDomain = domainLevels.pop()!\n    while (domainLevels.length && !getCookie(testCookieName)) {\n      candidateDomain = `${domainLevels.pop()!}.${candidateDomain}`\n      setCookie(testCookieName, testCookieValue, ONE_SECOND, { domain: candidateDomain })\n    }\n    deleteCookie(testCookieName, { domain: candidateDomain })\n    getCurrentSiteCache = candidateDomain\n  }\n  return getCurrentSiteCache\n}\n", "import type { CookieOptions } from '../../../browser/cookie'\nimport type { SessionPersistence } from '../sessionConstants'\nimport type { SessionState } from '../sessionState'\n\nexport const SESSION_STORE_KEY = '_dd_s'\n\nexport type SessionStoreStrategyType =\n  | { type: typeof SessionPersistence.COOKIE; cookieOptions: CookieOptions }\n  | { type: typeof SessionPersistence.LOCAL_STORAGE }\n\nexport interface SessionStoreStrategy {\n  isLockEnabled: boolean\n  persistSession: (session: SessionState) => void\n  retrieveSession: () => SessionState\n  expireSession: (previousSessionState: SessionState) => void\n}\n", "import { ONE_HOUR, ONE_MINUTE, ONE_YEAR } from '../../tools/utils/timeUtils'\n\nexport const SESSION_TIME_OUT_DELAY = 4 * ONE_HOUR\nexport const SESSION_EXPIRATION_DELAY = 15 * ONE_MINUTE\nexport const SESSION_COOKIE_EXPIRATION_DELAY = ONE_YEAR\nexport const SESSION_NOT_TRACKED = '0'\n\nexport const SessionPersistence = {\n  COOKIE: 'cookie',\n  LOCAL_STORAGE: 'local-storage',\n} as const\nexport type SessionPersistence = (typeof SessionPersistence)[keyof typeof SessionPersistence]\n", "export const SESSION_ENTRY_REGEXP = /^([a-zA-Z]+)=([a-z0-9-]+)$/\nexport const SESSION_ENTRY_SEPARATOR = '&'\n\nexport function isValidSessionString(sessionString: string | undefined | null): sessionString is string {\n  return (\n    !!sessionString &&\n    (sessionString.indexOf(SESSION_ENTRY_SEPARATOR) !== -1 || SESSION_ENTRY_REGEXP.test(sessionString))\n  )\n}\n", "import { isEmptyObject } from '../../tools/utils/objectUtils'\nimport { objectEntries } from '../../tools/utils/polyfills'\nimport { dateNow } from '../../tools/utils/timeUtils'\nimport { generateUUID } from '../../tools/utils/stringUtils'\nimport type { Configuration } from '../configuration'\nimport { SESSION_EXPIRATION_DELAY, SESSION_TIME_OUT_DELAY } from './sessionConstants'\nimport { isValidSessionString, SESSION_ENTRY_REGEXP, SESSION_ENTRY_SEPARATOR } from './sessionStateValidation'\nexport const EXPIRED = '1'\n\nexport interface SessionState {\n  id?: string\n  created?: string\n  expire?: string\n  isExpired?: typeof EXPIRED\n\n  [key: string]: string | undefined\n}\n\nexport function getExpiredSessionState(\n  previousSessionState: SessionState | undefined,\n  configuration: Configuration\n): SessionState {\n  const expiredSessionState: SessionState = {\n    isExpired: EXPIRED,\n  }\n  if (configuration.trackAnonymousUser) {\n    if (previousSessionState?.anonymousId) {\n      expiredSessionState.anonymousId = previousSessionState?.anonymousId\n    } else {\n      expiredSessionState.anonymousId = generateUUID()\n    }\n  }\n  return expiredSessionState\n}\n\nexport function isSessionInNotStartedState(session: SessionState) {\n  return isEmptyObject(session)\n}\n\nexport function isSessionStarted(session: SessionState) {\n  return !isSessionInNotStartedState(session)\n}\n\nexport function isSessionInExpiredState(session: SessionState) {\n  return session.isExpired !== undefined || !isActiveSession(session)\n}\n\n// An active session is a session in either `Tracked` or `NotTracked` state\nfunction isActiveSession(sessionState: SessionState) {\n  // created and expire can be undefined for versions which was not storing them\n  // these checks could be removed when older versions will not be available/live anymore\n  return (\n    (sessionState.created === undefined || dateNow() - Number(sessionState.created) < SESSION_TIME_OUT_DELAY) &&\n    (sessionState.expire === undefined || dateNow() < Number(sessionState.expire))\n  )\n}\n\nexport function expandSessionState(session: SessionState) {\n  session.expire = String(dateNow() + SESSION_EXPIRATION_DELAY)\n}\n\nexport function toSessionString(session: SessionState) {\n  return (\n    objectEntries(session)\n      // we use `aid` as a key for anonymousId\n      .map(([key, value]) => (key === 'anonymousId' ? `aid=${value}` : `${key}=${value}`))\n      .join(SESSION_ENTRY_SEPARATOR)\n  )\n}\n\nexport function toSessionState(sessionString: string | undefined | null) {\n  const session: SessionState = {}\n  if (isValidSessionString(sessionString)) {\n    sessionString.split(SESSION_ENTRY_SEPARATOR).forEach((entry) => {\n      const matches = SESSION_ENTRY_REGEXP.exec(entry)\n      if (matches !== null) {\n        const [, key, value] = matches\n        if (key === 'aid') {\n          // we use `aid` as a key for anonymousId\n          session.anonymousId = value\n        } else {\n          session[key] = value\n        }\n      }\n    })\n  }\n  return session\n}\n", "import { getInitCookie } from '../../browser/cookie'\nimport type { SessionStoreStrategy } from './storeStrategies/sessionStoreStrategy'\nimport { SESSION_STORE_KEY } from './storeStrategies/sessionStoreStrategy'\nimport type { SessionState } from './sessionState'\nimport { expandSessionState, isSessionStarted } from './sessionState'\n\nexport const OLD_SESSION_COOKIE_NAME = '_dd'\nexport const OLD_RUM_COOKIE_NAME = '_dd_r'\nexport const OLD_LOGS_COOKIE_NAME = '_dd_l'\n\n// duplicate values to avoid dependency issues\nexport const RUM_SESSION_KEY = 'rum'\nexport const LOGS_SESSION_KEY = 'logs'\n\n/**\n * This migration should remain in the codebase as long as older versions are available/live\n * to allow older sdk versions to be upgraded to newer versions without compatibility issues.\n */\nexport function tryOldCookiesMigration(cookieStoreStrategy: SessionStoreStrategy) {\n  const sessionString = getInitCookie(SESSION_STORE_KEY)\n  if (!sessionString) {\n    const oldSessionId = getInitCookie(OLD_SESSION_COOKIE_NAME)\n    const oldRumType = getInitCookie(OLD_RUM_COOKIE_NAME)\n    const oldLogsType = getInitCookie(OLD_LOGS_COOKIE_NAME)\n    const session: SessionState = {}\n\n    if (oldSessionId) {\n      session.id = oldSessionId\n    }\n    if (oldLogsType && /^[01]$/.test(oldLogsType)) {\n      session[LOGS_SESSION_KEY] = oldLogsType\n    }\n    if (oldRumType && /^[012]$/.test(oldRumType)) {\n      session[RUM_SESSION_KEY] = oldRumType\n    }\n\n    if (isSessionStarted(session)) {\n      expandSessionState(session)\n      cookieStoreStrategy.persistSession(session)\n    }\n  }\n}\n", "import { isChromium } from '../../../tools/utils/browserDetection'\nimport type { CookieOptions } from '../../../browser/cookie'\nimport { getCurrentSite, areCookiesAuthorized, getCookie, setCookie } from '../../../browser/cookie'\nimport type { InitConfiguration, Configuration } from '../../configuration'\nimport { tryOldCookiesMigration } from '../oldCookiesMigration'\nimport {\n  SESSION_COOKIE_EXPIRATION_DELAY,\n  SESSION_EXPIRATION_DELAY,\n  SESSION_TIME_OUT_DELAY,\n  SessionPersistence,\n} from '../sessionConstants'\nimport type { SessionState } from '../sessionState'\nimport { toSessionString, toSessionState, getExpiredSessionState } from '../sessionState'\nimport type { SessionStoreStrategy, SessionStoreStrategyType } from './sessionStoreStrategy'\nimport { SESSION_STORE_KEY } from './sessionStoreStrategy'\n\nexport function selectCookieStrategy(initConfiguration: InitConfiguration): SessionStoreStrategyType | undefined {\n  const cookieOptions = buildCookieOptions(initConfiguration)\n  return areCookiesAuthorized(cookieOptions) ? { type: SessionPersistence.COOKIE, cookieOptions } : undefined\n}\n\nexport function initCookieStrategy(configuration: Configuration, cookieOptions: CookieOptions): SessionStoreStrategy {\n  const cookieStore = {\n    /**\n     * Lock strategy allows mitigating issues due to concurrent access to cookie.\n     * This issue concerns only chromium browsers and enabling this on firefox increases cookie write failures.\n     */\n    isLockEnabled: isChromium(),\n    persistSession: (sessionState: SessionState) =>\n      storeSessionCookie(cookieOptions, configuration, sessionState, SESSION_EXPIRATION_DELAY),\n    retrieveSession: retrieveSessionCookie,\n    expireSession: (sessionState: SessionState) =>\n      storeSessionCookie(\n        cookieOptions,\n        configuration,\n        getExpiredSessionState(sessionState, configuration),\n        SESSION_TIME_OUT_DELAY\n      ),\n  }\n\n  tryOldCookiesMigration(cookieStore)\n\n  return cookieStore\n}\n\nfunction storeSessionCookie(\n  options: CookieOptions,\n  configuration: Configuration,\n  sessionState: SessionState,\n  defaultTimeout: number\n) {\n  setCookie(\n    SESSION_STORE_KEY,\n    toSessionString(sessionState),\n    configuration.trackAnonymousUser ? SESSION_COOKIE_EXPIRATION_DELAY : defaultTimeout,\n    options\n  )\n}\n\nexport function retrieveSessionCookie(): SessionState {\n  const sessionString = getCookie(SESSION_STORE_KEY)\n  const sessionState = toSessionState(sessionString)\n  return sessionState\n}\n\nexport function buildCookieOptions(initConfiguration: InitConfiguration) {\n  const cookieOptions: CookieOptions = {}\n\n  cookieOptions.secure =\n    !!initConfiguration.useSecureSessionCookie || !!initConfiguration.usePartitionedCrossSiteSessionCookie\n  cookieOptions.crossSite = !!initConfiguration.usePartitionedCrossSiteSessionCookie\n  cookieOptions.partitioned = !!initConfiguration.usePartitionedCrossSiteSessionCookie\n\n  if (initConfiguration.trackSessionAcrossSubdomains) {\n    cookieOptions.domain = getCurrentSite()\n  }\n\n  return cookieOptions\n}\n", "import { generateUUID } from '../../../tools/utils/stringUtils'\nimport type { Configuration } from '../../configuration'\nimport { SessionPersistence } from '../sessionConstants'\nimport type { SessionState } from '../sessionState'\nimport { toSessionString, toSessionState, getExpiredSessionState } from '../sessionState'\nimport type { SessionStoreStrategy, SessionStoreStrategyType } from './sessionStoreStrategy'\nimport { SESSION_STORE_KEY } from './sessionStoreStrategy'\n\nconst LOCAL_STORAGE_TEST_KEY = '_dd_test_'\n\nexport function selectLocalStorageStrategy(): SessionStoreStrategyType | undefined {\n  try {\n    const id = generateUUID()\n    const testKey = `${LOCAL_STORAGE_TEST_KEY}${id}`\n    localStorage.setItem(testKey, id)\n    const retrievedId = localStorage.getItem(testKey)\n    localStorage.removeItem(testKey)\n    return id === retrievedId ? { type: SessionPersistence.LOCAL_STORAGE } : undefined\n  } catch {\n    return undefined\n  }\n}\n\nexport function initLocalStorageStrategy(configuration: Configuration): SessionStoreStrategy {\n  return {\n    isLockEnabled: false,\n    persistSession: persistInLocalStorage,\n    retrieveSession: retrieveSessionFromLocalStorage,\n    expireSession: (sessionState: SessionState) => expireSessionFromLocalStorage(sessionState, configuration),\n  }\n}\n\nfunction persistInLocalStorage(sessionState: SessionState) {\n  localStorage.setItem(SESSION_STORE_KEY, toSessionString(sessionState))\n}\n\nfunction retrieveSessionFromLocalStorage(): SessionState {\n  const sessionString = localStorage.getItem(SESSION_STORE_KEY)\n  return toSessionState(sessionString)\n}\n\nfunction expireSessionFromLocalStorage(previousSessionState: SessionState, configuration: Configuration) {\n  persistInLocalStorage(getExpiredSessionState(previousSessionState, configuration))\n}\n", "import { setTimeout } from '../../tools/timer'\nimport { generateUUID } from '../../tools/utils/stringUtils'\nimport type { TimeStamp } from '../../tools/utils/timeUtils'\nimport { elapsed, ONE_SECOND, timeStampNow } from '../../tools/utils/timeUtils'\nimport { addTelemetryDebug } from '../telemetry'\nimport type { SessionStoreStrategy } from './storeStrategies/sessionStoreStrategy'\nimport type { SessionState } from './sessionState'\nimport { expandSessionState, isSessionInExpiredState } from './sessionState'\n\ntype Operations = {\n  process: (sessionState: SessionState) => SessionState | undefined\n  after?: (sessionState: SessionState) => void\n}\n\nexport const LOCK_RETRY_DELAY = 10\nexport const LOCK_MAX_TRIES = 100\n\n// Locks should be hold for a few milliseconds top, just the time it takes to read and write a\n// cookie. Using one second should be enough in most situations.\nexport const LOCK_EXPIRATION_DELAY = ONE_SECOND\nconst LOCK_SEPARATOR = '--'\n\nconst bufferedOperations: Operations[] = []\nlet ongoingOperations: Operations | undefined\n\nexport function processSessionStoreOperations(\n  operations: Operations,\n  sessionStoreStrategy: SessionStoreStrategy,\n  numberOfRetries = 0\n) {\n  const { isLockEnabled, persistSession, expireSession } = sessionStoreStrategy\n  const persistWithLock = (session: SessionState) => persistSession({ ...session, lock: currentLock })\n  const retrieveStore = () => {\n    const { lock, ...session } = sessionStoreStrategy.retrieveSession()\n    return {\n      session,\n      lock: lock && !isLockExpired(lock) ? lock : undefined,\n    }\n  }\n\n  if (!ongoingOperations) {\n    ongoingOperations = operations\n  }\n  if (operations !== ongoingOperations) {\n    bufferedOperations.push(operations)\n    return\n  }\n  if (isLockEnabled && numberOfRetries >= LOCK_MAX_TRIES) {\n    addTelemetryDebug('Aborted session operation after max lock retries', {\n      currentStore: retrieveStore(),\n    })\n    next(sessionStoreStrategy)\n    return\n  }\n  let currentLock: string\n  let currentStore = retrieveStore()\n  if (isLockEnabled) {\n    // if someone has lock, retry later\n    if (currentStore.lock) {\n      retryLater(operations, sessionStoreStrategy, numberOfRetries)\n      return\n    }\n    // acquire lock\n    currentLock = createLock()\n    persistWithLock(currentStore.session)\n    // if lock is not acquired, retry later\n    currentStore = retrieveStore()\n    if (currentStore.lock !== currentLock) {\n      retryLater(operations, sessionStoreStrategy, numberOfRetries)\n      return\n    }\n  }\n  let processedSession = operations.process(currentStore.session)\n  if (isLockEnabled) {\n    // if lock corrupted after process, retry later\n    currentStore = retrieveStore()\n    if (currentStore.lock !== currentLock!) {\n      retryLater(operations, sessionStoreStrategy, numberOfRetries)\n      return\n    }\n  }\n  if (processedSession) {\n    if (isSessionInExpiredState(processedSession)) {\n      expireSession(processedSession)\n    } else {\n      expandSessionState(processedSession)\n      if (isLockEnabled) {\n        persistWithLock(processedSession)\n      } else {\n        persistSession(processedSession)\n      }\n    }\n  }\n  if (isLockEnabled) {\n    // correctly handle lock around expiration would require to handle this case properly at several levels\n    // since we don't have evidence of lock issues around expiration, let's just not do the corruption check for it\n    if (!(processedSession && isSessionInExpiredState(processedSession))) {\n      // if lock corrupted after persist, retry later\n      currentStore = retrieveStore()\n      if (currentStore.lock !== currentLock!) {\n        retryLater(operations, sessionStoreStrategy, numberOfRetries)\n        return\n      }\n      persistSession(currentStore.session)\n      processedSession = currentStore.session\n    }\n  }\n  // call after even if session is not persisted in order to perform operations on\n  // up-to-date session state value => the value could have been modified by another tab\n  operations.after?.(processedSession || currentStore.session)\n  next(sessionStoreStrategy)\n}\n\nfunction retryLater(operations: Operations, sessionStore: SessionStoreStrategy, currentNumberOfRetries: number) {\n  setTimeout(() => {\n    processSessionStoreOperations(operations, sessionStore, currentNumberOfRetries + 1)\n  }, LOCK_RETRY_DELAY)\n}\n\nfunction next(sessionStore: SessionStoreStrategy) {\n  ongoingOperations = undefined\n  const nextOperations = bufferedOperations.shift()\n  if (nextOperations) {\n    processSessionStoreOperations(nextOperations, sessionStore)\n  }\n}\n\nexport function createLock(): string {\n  return generateUUID() + LOCK_SEPARATOR + timeStampNow()\n}\n\nfunction isLockExpired(lock: string) {\n  const [, timeStamp] = lock.split(LOCK_SEPARATOR)\n  return !timeStamp || elapsed(Number(timeStamp) as TimeStamp, timeStampNow()) > LOCK_EXPIRATION_DELAY\n}\n", "import { clearInterval, setInterval } from '../../tools/timer'\nimport { Observable } from '../../tools/observable'\nimport { ONE_SECOND, dateNow } from '../../tools/utils/timeUtils'\nimport { throttle } from '../../tools/utils/functionUtils'\nimport { generateUUID } from '../../tools/utils/stringUtils'\nimport type { InitConfiguration, Configuration } from '../configuration'\nimport { display } from '../../tools/display'\nimport { selectCookieStrategy, initCookieStrategy } from './storeStrategies/sessionInCookie'\nimport type { SessionStoreStrategyType } from './storeStrategies/sessionStoreStrategy'\nimport type { SessionState } from './sessionState'\nimport {\n  getExpiredSessionState,\n  isSessionInExpiredState,\n  isSessionInNotStartedState,\n  isSessionStarted,\n} from './sessionState'\nimport { initLocalStorageStrategy, selectLocalStorageStrategy } from './storeStrategies/sessionInLocalStorage'\nimport { processSessionStoreOperations } from './sessionStoreOperations'\nimport { SESSION_NOT_TRACKED, SessionPersistence } from './sessionConstants'\n\nexport interface SessionStore {\n  expandOrRenewSession: () => void\n  expandSession: () => void\n  getSession: () => SessionState\n  restartSession: () => void\n  renewObservable: Observable<void>\n  expireObservable: Observable<void>\n  sessionStateUpdateObservable: Observable<{ previousState: SessionState; newState: SessionState }>\n  expire: () => void\n  stop: () => void\n  updateSessionState: (state: Partial<SessionState>) => void\n}\n\n/**\n * Every second, the storage will be polled to check for any change that can occur\n * to the session state in another browser tab, or another window.\n * This value has been determined from our previous cookie-only implementation.\n */\nexport const STORAGE_POLL_DELAY = ONE_SECOND\n\n/**\n * Selects the correct session store strategy type based on the configuration and storage\n * availability.\n */\nexport function selectSessionStoreStrategyType(\n  initConfiguration: InitConfiguration\n): SessionStoreStrategyType | undefined {\n  switch (initConfiguration.sessionPersistence) {\n    case SessionPersistence.COOKIE:\n      return selectCookieStrategy(initConfiguration)\n\n    case SessionPersistence.LOCAL_STORAGE:\n      return selectLocalStorageStrategy()\n\n    case undefined: {\n      let sessionStoreStrategyType = selectCookieStrategy(initConfiguration)\n      if (!sessionStoreStrategyType && initConfiguration.allowFallbackToLocalStorage) {\n        sessionStoreStrategyType = selectLocalStorageStrategy()\n      }\n      return sessionStoreStrategyType\n    }\n\n    default:\n      display.error(`Invalid session persistence '${String(initConfiguration.sessionPersistence)}'`)\n  }\n}\n\n/**\n * Different session concepts:\n * - tracked, the session has an id and is updated along the user navigation\n * - not tracked, the session does not have an id but it is updated along the user navigation\n * - inactive, no session in store or session expired, waiting for a renew session\n */\nexport function startSessionStore<TrackingType extends string>(\n  sessionStoreStrategyType: SessionStoreStrategyType,\n  configuration: Configuration,\n  productKey: string,\n  computeTrackingType: (rawTrackingType?: string) => TrackingType\n): SessionStore {\n  const renewObservable = new Observable<void>()\n  const expireObservable = new Observable<void>()\n  const sessionStateUpdateObservable = new Observable<{ previousState: SessionState; newState: SessionState }>()\n\n  const sessionStoreStrategy =\n    sessionStoreStrategyType.type === SessionPersistence.COOKIE\n      ? initCookieStrategy(configuration, sessionStoreStrategyType.cookieOptions)\n      : initLocalStorageStrategy(configuration)\n  const { expireSession } = sessionStoreStrategy\n\n  const watchSessionTimeoutId = setInterval(watchSession, STORAGE_POLL_DELAY)\n  let sessionCache: SessionState\n\n  startSession()\n\n  const { throttled: throttledExpandOrRenewSession, cancel: cancelExpandOrRenewSession } = throttle(() => {\n    processSessionStoreOperations(\n      {\n        process: (sessionState) => {\n          if (isSessionInNotStartedState(sessionState)) {\n            return\n          }\n\n          const synchronizedSession = synchronizeSession(sessionState)\n          expandOrRenewSessionState(synchronizedSession)\n          return synchronizedSession\n        },\n        after: (sessionState) => {\n          if (isSessionStarted(sessionState) && !hasSessionInCache()) {\n            renewSessionInCache(sessionState)\n          }\n          sessionCache = sessionState\n        },\n      },\n      sessionStoreStrategy\n    )\n  }, STORAGE_POLL_DELAY)\n\n  function expandSession() {\n    processSessionStoreOperations(\n      {\n        process: (sessionState) => (hasSessionInCache() ? synchronizeSession(sessionState) : undefined),\n      },\n      sessionStoreStrategy\n    )\n  }\n\n  /**\n   * allows two behaviors:\n   * - if the session is active, synchronize the session cache without updating the session store\n   * - if the session is not active, clear the session store and expire the session cache\n   */\n  function watchSession() {\n    processSessionStoreOperations(\n      {\n        process: (sessionState) =>\n          isSessionInExpiredState(sessionState) ? getExpiredSessionState(sessionState, configuration) : undefined,\n        after: synchronizeSession,\n      },\n      sessionStoreStrategy\n    )\n  }\n\n  function synchronizeSession(sessionState: SessionState) {\n    if (isSessionInExpiredState(sessionState)) {\n      sessionState = getExpiredSessionState(sessionState, configuration)\n    }\n    if (hasSessionInCache()) {\n      if (isSessionInCacheOutdated(sessionState)) {\n        expireSessionInCache()\n      } else {\n        sessionStateUpdateObservable.notify({ previousState: sessionCache, newState: sessionState })\n        sessionCache = sessionState\n      }\n    }\n    return sessionState\n  }\n\n  function startSession() {\n    processSessionStoreOperations(\n      {\n        process: (sessionState) => {\n          if (isSessionInNotStartedState(sessionState)) {\n            return getExpiredSessionState(sessionState, configuration)\n          }\n        },\n        after: (sessionState) => {\n          sessionCache = sessionState\n        },\n      },\n      sessionStoreStrategy\n    )\n  }\n\n  function expandOrRenewSessionState(sessionState: SessionState) {\n    if (isSessionInNotStartedState(sessionState)) {\n      return false\n    }\n\n    const trackingType = computeTrackingType(sessionState[productKey])\n    sessionState[productKey] = trackingType\n    delete sessionState.isExpired\n    if (trackingType !== SESSION_NOT_TRACKED && !sessionState.id) {\n      sessionState.id = generateUUID()\n      sessionState.created = String(dateNow())\n    }\n  }\n\n  function hasSessionInCache() {\n    return sessionCache?.[productKey] !== undefined\n  }\n\n  function isSessionInCacheOutdated(sessionState: SessionState) {\n    return sessionCache.id !== sessionState.id || sessionCache[productKey] !== sessionState[productKey]\n  }\n\n  function expireSessionInCache() {\n    sessionCache = getExpiredSessionState(sessionCache, configuration)\n    expireObservable.notify()\n  }\n\n  function renewSessionInCache(sessionState: SessionState) {\n    sessionCache = sessionState\n    renewObservable.notify()\n  }\n\n  function updateSessionState(partialSessionState: Partial<SessionState>) {\n    processSessionStoreOperations(\n      {\n        process: (sessionState) => ({ ...sessionState, ...partialSessionState }),\n        after: synchronizeSession,\n      },\n      sessionStoreStrategy\n    )\n  }\n\n  return {\n    expandOrRenewSession: throttledExpandOrRenewSession,\n    expandSession,\n    getSession: () => sessionCache,\n    renewObservable,\n    expireObservable,\n    sessionStateUpdateObservable,\n    restartSession: startSession,\n    expire: () => {\n      cancelExpandOrRenewSession()\n      expireSession(sessionCache)\n      synchronizeSession(getExpiredSessionState(sessionCache, configuration))\n    },\n    stop: () => {\n      clearInterval(watchSessionTimeoutId)\n    },\n    updateSessionState,\n  }\n}\n", "import { Observable } from '../tools/observable'\n\nexport const TrackingConsent = {\n  GRANTED: 'granted',\n  NOT_GRANTED: 'not-granted',\n} as const\nexport type TrackingConsent = (typeof TrackingConsent)[keyof typeof TrackingConsent]\n\nexport interface TrackingConsentState {\n  tryToInit: (trackingConsent: TrackingConsent) => void\n  update: (trackingConsent: TrackingConsent) => void\n  isGranted: () => boolean\n  observable: Observable<void>\n}\n\nexport function createTrackingConsentState(currentConsent?: TrackingConsent): TrackingConsentState {\n  const observable = new Observable<void>()\n\n  return {\n    tryToInit(trackingConsent: TrackingConsent) {\n      if (!currentConsent) {\n        currentConsent = trackingConsent\n      }\n    },\n    update(trackingConsent: TrackingConsent) {\n      currentConsent = trackingConsent\n      observable.notify()\n    },\n    isGranted() {\n      return currentConsent === TrackingConsent.GRANTED\n    },\n    observable,\n  }\n}\n", "import { display } from './display'\nimport { getType } from './utils/typeUtils'\n\nexport type MatchOption = string | RegExp | ((value: string) => boolean)\n\nexport function isMatchOption(item: unknown): item is MatchOption {\n  const itemType = getType(item)\n  return itemType === 'string' || itemType === 'function' || item instanceof RegExp\n}\n\n/**\n * Returns true if value can be matched by at least one of the provided MatchOptions.\n * When comparing strings, setting useStartsWith to true will compare the value with the start of\n * the option, instead of requiring an exact match.\n */\nexport function matchList(list: MatchOption[], value: string, useStartsWith = false): boolean {\n  return list.some((item) => {\n    try {\n      if (typeof item === 'function') {\n        return item(value)\n      } else if (item instanceof RegExp) {\n        return item.test(value)\n      } else if (typeof item === 'string') {\n        return useStartsWith ? value.startsWith(item) : item === value\n      }\n    } catch (e) {\n      display.error(e)\n    }\n    return false\n  })\n}\n", "export const EXTENSION_PREFIXES = ['chrome-extension://', 'moz-extension://']\n\nexport function containsExtensionUrl(str: string): boolean {\n  return EXTENSION_PREFIXES.some((prefix) => str.includes(prefix))\n}\n\n/**\n * Utility function to detect if the SDK is being initialized in an unsupported browser extension environment.\n * @param windowLocation The current window location to check\n * @param stack The error stack to check for extension URLs\n * @returns {boolean} true if running in an unsupported browser extension environment\n */\nexport function isUnsupportedExtensionEnvironment(windowLocation: string, stack = new Error().stack) {\n  // If we're on a regular web page but the error stack shows extension URLs,\n  // then an extension is injecting RUM.\n  return !containsExtensionUrl(windowLocation) && containsExtensionUrl(stack || '')\n}\n", "import { display } from '../tools/display'\nimport { matchList } from '../tools/matchOption'\nimport type { InitConfiguration } from './configuration'\nimport { isUnsupportedExtensionEnvironment } from './extension/extensionUtils'\n\nexport const WARN_DOES_NOT_HAVE_ALLOWED_TRACKING_ORIGIN =\n  'Running the Browser SDK in a Web extension content script is discouraged and will be forbidden in a future major release unless the `allowedTrackingOrigins` option is provided.'\nexport const ERROR_NOT_ALLOWED_TRACKING_ORIGIN = 'SDK initialized on a non-allowed domain.'\n\nexport function isAllowedTrackingOrigins(\n  configuration: InitConfiguration,\n  windowOrigin = typeof location !== 'undefined' ? location.origin : '',\n  errorStack?: string\n): boolean {\n  const allowedTrackingOrigins = configuration.allowedTrackingOrigins\n  if (!allowedTrackingOrigins) {\n    if (isUnsupportedExtensionEnvironment(windowOrigin, errorStack)) {\n      display.warn(WARN_DOES_NOT_HAVE_ALLOWED_TRACKING_ORIGIN)\n      // TODO(next major): make `allowedTrackingOrigins` required in unsupported extension environments\n    }\n    return true\n  }\n\n  const isAllowed = matchList(allowedTrackingOrigins, windowOrigin)\n  if (!isAllowed) {\n    display.error(ERROR_NOT_ALLOWED_TRACKING_ORIGIN)\n  }\n  return isAllowed\n}\n", "import { jsonStringify } from '../serialisation/jsonStringify'\n\nexport function normalizeUrl(url: string) {\n  return buildUrl(url, location.href).href\n}\n\nexport function isValidUrl(url: string) {\n  try {\n    return !!buildUrl(url)\n  } catch {\n    return false\n  }\n}\n\nexport function getPathName(url: string) {\n  const pathname = buildUrl(url).pathname\n  return pathname[0] === '/' ? pathname : `/${pathname}`\n}\n\nexport function buildUrl(url: string, base?: string) {\n  const supportedURL = getSupportedUrl()\n  if (supportedURL) {\n    try {\n      return base !== undefined ? new supportedURL(url, base) : new supportedURL(url)\n    } catch (error) {\n      throw new Error(`Failed to construct URL: ${String(error)} ${jsonStringify({ url, base })!}`)\n    }\n  }\n  if (base === undefined && !/:/.test(url)) {\n    throw new Error(`Invalid URL: '${url}'`)\n  }\n  let doc = document\n  const anchorElement = doc.createElement('a')\n  if (base !== undefined) {\n    doc = document.implementation.createHTMLDocument('')\n    const baseElement = doc.createElement('base')\n    baseElement.href = base\n    doc.head.appendChild(baseElement)\n    doc.body.appendChild(anchorElement)\n  }\n  anchorElement.href = url\n  return anchorElement\n}\n\nconst originalURL = URL\nlet isURLSupported: boolean | undefined\nfunction getSupportedUrl(): typeof URL | undefined {\n  if (isURLSupported === undefined) {\n    try {\n      const url = new originalURL('http://test/path')\n      isURLSupported = url.href === 'http://test/path'\n    } catch {\n      isURLSupported = false\n    }\n  }\n  return isURLSupported ? originalURL : undefined\n}\n", "import type { Payload } from '../../transport'\nimport { timeStampNow } from '../../tools/utils/timeUtils'\nimport { normalizeUrl } from '../../tools/utils/urlPolyfill'\nimport { generateUUID } from '../../tools/utils/stringUtils'\nimport { INTAKE_SITE_FED_STAGING, INTAKE_SITE_US1, PCI_INTAKE_HOST_US1 } from '../intakeSites'\nimport type { InitConfiguration } from './configuration'\n\n// replaced at build time\ndeclare const __BUILD_ENV__SDK_VERSION__: string\n\nexport type TrackType = 'logs' | 'rum' | 'replay' | 'profile'\nexport type ApiType =\n  | 'fetch-keepalive'\n  | 'fetch'\n  | 'beacon'\n  // 'manual' reflects that the request have been sent manually, outside of the SDK (ex: via curl or\n  // a Node.js script).\n  | 'manual'\n\nexport type EndpointBuilder = ReturnType<typeof createEndpointBuilder>\n\nexport function createEndpointBuilder(\n  initConfiguration: InitConfiguration,\n  trackType: TrackType,\n  configurationTags: string[]\n) {\n  const buildUrlWithParameters = createEndpointUrlWithParametersBuilder(initConfiguration, trackType)\n\n  return {\n    build(api: ApiType, payload: Payload) {\n      const parameters = buildEndpointParameters(initConfiguration, trackType, configurationTags, api, payload)\n      return buildUrlWithParameters(parameters)\n    },\n    tags: configurationTags,\n    urlPrefix: buildUrlWithParameters(''),\n    trackType,\n  }\n}\n\n/**\n * Create a function used to build a full endpoint url from provided parameters. The goal of this\n * function is to pre-compute some parts of the URL to avoid re-computing everything on every\n * request, as only parameters are changing.\n */\nfunction createEndpointUrlWithParametersBuilder(\n  initConfiguration: InitConfiguration,\n  trackType: TrackType\n): (parameters: string) => string {\n  const path = `/api/v2/${trackType}`\n  const proxy = initConfiguration.proxy\n  if (typeof proxy === 'string') {\n    const normalizedProxyUrl = normalizeUrl(proxy)\n    return (parameters) => `${normalizedProxyUrl}?ddforward=${encodeURIComponent(`${path}?${parameters}`)}`\n  }\n  if (typeof proxy === 'function') {\n    return (parameters) => proxy({ path, parameters })\n  }\n  const host = buildEndpointHost(trackType, initConfiguration)\n  return (parameters) => `https://${host}${path}?${parameters}`\n}\n\nexport function buildEndpointHost(\n  trackType: TrackType,\n  initConfiguration: InitConfiguration & { usePciIntake?: boolean }\n) {\n  const { site = INTAKE_SITE_US1, internalAnalyticsSubdomain } = initConfiguration\n\n  if (trackType === 'logs' && initConfiguration.usePciIntake && site === INTAKE_SITE_US1) {\n    return PCI_INTAKE_HOST_US1\n  }\n\n  if (internalAnalyticsSubdomain && site === INTAKE_SITE_US1) {\n    return `${internalAnalyticsSubdomain}.${INTAKE_SITE_US1}`\n  }\n\n  if (site === INTAKE_SITE_FED_STAGING) {\n    return `http-intake.logs.${site}`\n  }\n\n  const domainParts = site.split('.')\n  const extension = domainParts.pop()\n  return `browser-intake-${domainParts.join('-')}.${extension!}`\n}\n\n/**\n * Build parameters to be used for an intake request. Parameters should be re-built for each\n * request, as they change randomly.\n */\nfunction buildEndpointParameters(\n  { clientToken, internalAnalyticsSubdomain }: InitConfiguration,\n  trackType: TrackType,\n  configurationTags: string[],\n  api: ApiType,\n  { retry, encoding }: Payload\n) {\n  const tags = [`sdk_version:${__BUILD_ENV__SDK_VERSION__}`, `api:${api}`].concat(configurationTags)\n  if (retry) {\n    tags.push(`retry_count:${retry.count}`, `retry_after:${retry.lastFailureStatus}`)\n  }\n\n  const parameters = [\n    'ddsource=browser',\n    `ddtags=${encodeURIComponent(tags.join(','))}`,\n    `dd-api-key=${clientToken}`,\n    `dd-evp-origin-version=${encodeURIComponent(__BUILD_ENV__SDK_VERSION__)}`,\n    'dd-evp-origin=browser',\n    `dd-request-id=${generateUUID()}`,\n  ]\n\n  if (encoding) {\n    parameters.push(`dd-evp-encoding=${encoding}`)\n  }\n\n  if (trackType === 'rum') {\n    parameters.push(`batch_time=${timeStampNow()}`)\n  }\n\n  if (internalAnalyticsSubdomain) {\n    parameters.reverse()\n  }\n\n  return parameters.join('&')\n}\n", "import { DOCS_ORIGIN, MORE_DETAILS, display } from '../../tools/display'\nimport type { InitConfiguration } from './configuration'\n\nexport const TAG_SIZE_LIMIT = 200\n\nexport function buildTags(configuration: InitConfiguration): string[] {\n  const { env, service, version, datacenter } = configuration\n  const tags = []\n\n  if (env) {\n    tags.push(buildTag('env', env))\n  }\n  if (service) {\n    tags.push(buildTag('service', service))\n  }\n  if (version) {\n    tags.push(buildTag('version', version))\n  }\n  if (datacenter) {\n    tags.push(buildTag('datacenter', datacenter))\n  }\n\n  return tags\n}\n\nexport function buildTag(key: string, rawValue: string) {\n  // See https://docs.datadoghq.com/getting_started/tagging/#defining-tags for tags syntax. Note\n  // that the backend may not follow the exact same rules, so we only want to display an informal\n  // warning.\n  const valueSizeLimit = TAG_SIZE_LIMIT - key.length - 1\n\n  if (rawValue.length > valueSizeLimit || hasForbiddenCharacters(rawValue)) {\n    display.warn(\n      `${key} value doesn't meet tag requirements and will be sanitized. ${MORE_DETAILS} ${DOCS_ORIGIN}/getting_started/tagging/#defining-tags`\n    )\n  }\n\n  // Let the backend do most of the sanitization, but still make sure multiple tags can't be crafted\n  // by forging a value containing commas.\n  const sanitizedValue = rawValue.replace(/,/g, '_')\n\n  return `${key}:${sanitizedValue}`\n}\n\nfunction hasForbiddenCharacters(rawValue: string) {\n  // Unicode property escapes is not supported in all browsers, so we use a try/catch.\n  // Todo: Remove the try/catch when dropping support for Chrome 63 and Firefox 67\n  // see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Unicode_character_class_escape#browser_compatibility\n  if (!supportUnicodePropertyEscapes()) {\n    return false\n  }\n\n  // We use the Unicode property escapes to match any character that is a letter including other languages like Chinese, Japanese, etc.\n  // p{Ll} matches a lowercase letter.\n  // p{Lo} matches a letter that is neither uppercase nor lowercase (ex: Japanese characters).\n  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Unicode_character_class_escape#unicode_property_escapes_vs._character_classes\n  return new RegExp('[^\\\\p{Ll}\\\\p{Lo}0-9_:./-]', 'u').test(rawValue)\n}\n\nexport function supportUnicodePropertyEscapes() {\n  try {\n    new RegExp('[\\\\p{Ll}]', 'u')\n    return true\n  } catch {\n    return false\n  }\n}\n", "import type { Site } from '../intakeSites'\nimport { INTAKE_SITE_US1, INTAKE_URL_PARAMETERS } from '../intakeSites'\nimport type { InitConfiguration } from './configuration'\nimport type { EndpointBuilder } from './endpointBuilder'\nimport { createEndpointBuilder } from './endpointBuilder'\nimport { buildTags } from './tags'\n\nexport interface TransportConfiguration {\n  logsEndpointBuilder: EndpointBuilder\n  rumEndpointBuilder: EndpointBuilder\n  sessionReplayEndpointBuilder: EndpointBuilder\n  profilingEndpointBuilder: EndpointBuilder\n  replica?: ReplicaConfiguration\n  site: Site\n}\n\nexport interface ReplicaConfiguration {\n  applicationId?: string\n  logsEndpointBuilder: EndpointBuilder\n  rumEndpointBuilder: EndpointBuilder\n}\n\nexport function computeTransportConfiguration(initConfiguration: InitConfiguration): TransportConfiguration {\n  const site = initConfiguration.site || INTAKE_SITE_US1\n\n  const tags = buildTags(initConfiguration)\n\n  const endpointBuilders = computeEndpointBuilders(initConfiguration, tags)\n  const replicaConfiguration = computeReplicaConfiguration(initConfiguration, tags)\n\n  return {\n    replica: replicaConfiguration,\n    site,\n    ...endpointBuilders,\n  }\n}\n\nfunction computeEndpointBuilders(initConfiguration: InitConfiguration, tags: string[]) {\n  return {\n    logsEndpointBuilder: createEndpointBuilder(initConfiguration, 'logs', tags),\n    rumEndpointBuilder: createEndpointBuilder(initConfiguration, 'rum', tags),\n    profilingEndpointBuilder: createEndpointBuilder(initConfiguration, 'profile', tags),\n    sessionReplayEndpointBuilder: createEndpointBuilder(initConfiguration, 'replay', tags),\n  }\n}\n\nfunction computeReplicaConfiguration(\n  initConfiguration: InitConfiguration,\n  tags: string[]\n): ReplicaConfiguration | undefined {\n  if (!initConfiguration.replica) {\n    return\n  }\n\n  const replicaConfiguration: InitConfiguration = {\n    ...initConfiguration,\n    site: INTAKE_SITE_US1,\n    clientToken: initConfiguration.replica.clientToken,\n  }\n\n  const replicaEndpointBuilders = {\n    logsEndpointBuilder: createEndpointBuilder(replicaConfiguration, 'logs', tags),\n    rumEndpointBuilder: createEndpointBuilder(replicaConfiguration, 'rum', tags),\n  }\n\n  return { applicationId: initConfiguration.replica.applicationId, ...replicaEndpointBuilders }\n}\n\nexport function isIntakeUrl(url: string): boolean {\n  // check if tags is present in the query string\n  return INTAKE_URL_PARAMETERS.every((param) => url.includes(param))\n}\n", "import { catchUserErrors } from '../../tools/catchUserErrors'\nimport { DOCS_ORIGIN, MORE_DETAILS, display } from '../../tools/display'\nimport type { RawTelemetryConfiguration } from '../telemetry'\nimport type { Duration } from '../../tools/utils/timeUtils'\nimport { ONE_SECOND } from '../../tools/utils/timeUtils'\nimport { isPercentage } from '../../tools/utils/numberUtils'\nimport { ONE_KIBI_BYTE } from '../../tools/utils/byteUtils'\nimport { objectHasValue } from '../../tools/utils/objectUtils'\nimport { selectSessionStoreStrategyType } from '../session/sessionStore'\nimport type { SessionStoreStrategyType } from '../session/storeStrategies/sessionStoreStrategy'\nimport { TrackingConsent } from '../trackingConsent'\nimport type { SessionPersistence } from '../session/sessionConstants'\nimport type { MatchOption } from '../../tools/matchOption'\nimport { isAllowedTrackingOrigins } from '../allowedTrackingOrigins'\nimport type { Site } from '../intakeSites'\nimport type { TransportConfiguration } from './transportConfiguration'\nimport { computeTransportConfiguration } from './transportConfiguration'\n\nexport const DefaultPrivacyLevel = {\n  ALLOW: 'allow',\n  MASK: 'mask',\n  MASK_USER_INPUT: 'mask-user-input',\n} as const\nexport type DefaultPrivacyLevel = (typeof DefaultPrivacyLevel)[keyof typeof DefaultPrivacyLevel]\n\nexport const TraceContextInjection = {\n  ALL: 'all',\n  SAMPLED: 'sampled',\n} as const\n\nexport type TraceContextInjection = (typeof TraceContextInjection)[keyof typeof TraceContextInjection]\n\nexport interface InitConfiguration {\n  /**\n   * The client token for Datadog. Required for authenticating your application with Datadog.\n   */\n  clientToken: string\n  /**\n   * A callback function that can be used to modify events before they are sent to Datadog.\n   */\n  beforeSend?: GenericBeforeSendCallback | undefined\n  /**\n   * The percentage of sessions tracked. A value between 0 and 100.\n   * @default 100\n   */\n  sessionSampleRate?: number | undefined\n  /**\n   * The percentage of telemetry events sent. A value between 0 and 100.\n   * @default 20\n   */\n  telemetrySampleRate?: number | undefined\n  /**\n   * Initialization fails silently if the RUM Browser SDK is already initialized on the page.\n   * @default false\n   */\n  silentMultipleInit?: boolean | undefined\n\n  /**\n   * Which storage strategy to use for persisting sessions. Can be either 'cookie' or 'local-storage'.\n   *\n   * Important: If you are using the RUM and Logs Browser SDKs, this option must be configured with identical values\n   * @default \"cookie\"\n   */\n  sessionPersistence?: SessionPersistence | undefined\n\n  /**\n   * Allows the use of localStorage when cookies cannot be set. This enables the RUM Browser SDK to run in environments that do not provide cookie support.\n   *\n   * Important: If you are using the RUM and Logs Browser SDKs, this option must be configured with identical values\n   * See [Monitor Electron Applications Using the Browser SDK](https://docs.datadoghq.com/real_user_monitoring/guide/monitor-electron-applications-using-browser-sdk) for further information.\n   * @deprecated use `sessionPersistence: local-storage` where you want to use localStorage instead\n   */\n  allowFallbackToLocalStorage?: boolean | undefined\n\n  /**\n   * Allow listening to DOM events dispatched programmatically ([untrusted events](https://developer.mozilla.org/en-US/docs/Web/API/Event/isTrusted)). Enabling this option can be useful if you heavily rely on programmatic events, such as in an automated UI test environment.\n   * @default false\n   */\n  allowUntrustedEvents?: boolean | undefined\n  /**\n   * Store global context and user context in localStorage to preserve them along the user navigation.\n   * See [Contexts life cycle](https://docs.datadoghq.com/real_user_monitoring/browser/advanced_configuration/?tab=npm#contexts-life-cycle) for further information.\n   * @default false\n   */\n  storeContextsAcrossPages?: boolean | undefined\n  /**\n   * Set the initial user tracking consent state.\n   * See [User tracking consent](https://docs.datadoghq.com/real_user_monitoring/browser/advanced_configuration/?tab=npm#user-tracking-consent) for further information.\n   * @default granted\n   */\n  trackingConsent?: TrackingConsent | undefined\n\n  /**\n   * List of origins where the SDK is allowed to run when used in a browser extension context.\n   * Matches urls against the extensions origin.\n   * If not provided and the SDK is running in a browser extension, a warning will be displayed.\n   */\n  allowedTrackingOrigins?: MatchOption[] | undefined\n\n  // transport options\n  /**\n   * Optional proxy URL, for example: https://www.proxy.com/path.\n   * See [Proxy Your Browser RUM Data](https://docs.datadoghq.com/real_user_monitoring/guide/proxy-rum-data) for further information.\n   */\n  proxy?: string | ProxyFn | undefined\n  /**\n   * The Datadog [site](https://docs.datadoghq.com/getting_started/site) parameter of your organization.\n   * @default datadoghq.com\n   */\n  site?: Site | undefined\n\n  // tag and context options\n  /**\n   * The service name for your application. Follows the [tag syntax requirements](https://docs.datadoghq.com/getting_started/tagging/#define-tags).\n   */\n  service?: string | undefined | null\n  /**\n   * The application’s environment, for example: prod, pre-prod, and staging. Follows the [tag syntax requirements](https://docs.datadoghq.com/getting_started/tagging/#define-tags).\n   */\n  env?: string | undefined | null\n  /**\n   * The application’s version, for example: 1.2.3, 6c44da20, and 2020.02.13. Follows the [tag syntax requirements](https://docs.datadoghq.com/getting_started/tagging/#define-tags).\n   */\n  version?: string | undefined | null\n\n  // cookie options\n  /**\n   * Use a partitioned secure cross-site session cookie. This allows the RUM Browser SDK to run when the site is loaded from another one (iframe). Implies `useSecureSessionCookie`.\n   *\n   * Important: If you are using the RUM and Logs Browser SDKs, this option must be configured with identical values\n   * @default false\n   */\n  usePartitionedCrossSiteSessionCookie?: boolean | undefined\n  /**\n   * Use a secure session cookie. This disables RUM events sent on insecure (non-HTTPS) connections.\n   *\n   * Important: If you are using the RUM and Logs Browser SDKs, this option must be configured with identical values\n   * @default false\n   */\n  useSecureSessionCookie?: boolean | undefined\n  /**\n   * Preserve the session across subdomains for the same site.\n   *\n   * Important: If you are using the RUM and Logs Browser SDKs, this option must be configured with identical values\n   * @default false\n   */\n  trackSessionAcrossSubdomains?: boolean | undefined\n  /**\n   * Track anonymous user for the same site and extend cookie expiration date\n   * @default true\n   */\n  trackAnonymousUser?: boolean | undefined\n  // internal options\n  /**\n   * [Internal option] Enable experimental features\n   */\n  enableExperimentalFeatures?: string[] | undefined\n  /**\n   * [Internal option] Configure the dual chipping to another datacenter\n   */\n  replica?: ReplicaUserConfiguration | undefined\n  /**\n   * [Internal option] Set the datacenter from where the data is dual chipped\n   */\n  datacenter?: string\n  /**\n   * [Internal option] Datadog internal analytics subdomain\n   */\n  // TODO next major: remove this option and replace usages by proxyFn\n  internalAnalyticsSubdomain?: string\n  /**\n   * [Internal option] The percentage of telemetry configuration sent. A value between 0 and 100.\n   * @default 5\n   */\n  telemetryConfigurationSampleRate?: number\n  /**\n   * [Internal option] The percentage of telemetry usage sent. A value between 0 and 100.\n   * @default 5\n   */\n  telemetryUsageSampleRate?: number\n}\n\n// This type is only used to build the core configuration. Logs and RUM SDKs are using a proper type\n// for this option.\ntype GenericBeforeSendCallback = (event: any, context?: any) => unknown\n\n/**\n * path: /api/vX/product\n * parameters: xxx=yyy&zzz=aaa\n */\ntype ProxyFn = (options: { path: string; parameters: string }) => string\n\nexport interface ReplicaUserConfiguration {\n  applicationId?: string\n  clientToken: string\n}\n\nexport interface Configuration extends TransportConfiguration {\n  // Built from init configuration\n  beforeSend: GenericBeforeSendCallback | undefined\n  sessionStoreStrategyType: SessionStoreStrategyType | undefined\n  sessionSampleRate: number\n  telemetrySampleRate: number\n  telemetryConfigurationSampleRate: number\n  telemetryUsageSampleRate: number\n  service: string | undefined\n  silentMultipleInit: boolean\n  allowUntrustedEvents: boolean\n  trackingConsent: TrackingConsent\n  storeContextsAcrossPages: boolean\n  trackAnonymousUser?: boolean\n  // Event limits\n  eventRateLimiterThreshold: number // Limit the maximum number of actions, errors and logs per minutes\n  maxTelemetryEventsPerPage: number\n\n  // Batch configuration\n  batchBytesLimit: number\n  flushTimeout: Duration\n  batchMessagesLimit: number\n  messageBytesLimit: number\n}\n\nfunction isString(tag: unknown, tagName: string): tag is string | undefined | null {\n  if (tag !== undefined && tag !== null && typeof tag !== 'string') {\n    display.error(`${tagName} must be defined as a string`)\n    return false\n  }\n  return true\n}\n\nfunction isDatadogSite(site: unknown) {\n  if (site && typeof site === 'string' && !/(datadog|ddog|datad0g|dd0g)/.test(site)) {\n    display.error(`Site should be a valid Datadog site. ${MORE_DETAILS} ${DOCS_ORIGIN}/getting_started/site/.`)\n    return false\n  }\n  return true\n}\n\nexport function isSampleRate(sampleRate: unknown, name: string) {\n  if (sampleRate !== undefined && !isPercentage(sampleRate)) {\n    display.error(`${name} Sample Rate should be a number between 0 and 100`)\n    return false\n  }\n  return true\n}\n\nexport function validateAndBuildConfiguration(initConfiguration: InitConfiguration): Configuration | undefined {\n  if (!initConfiguration || !initConfiguration.clientToken) {\n    display.error('Client Token is not configured, we will not send any data.')\n    return\n  }\n\n  if (\n    initConfiguration.allowedTrackingOrigins !== undefined &&\n    !Array.isArray(initConfiguration.allowedTrackingOrigins)\n  ) {\n    display.error('Allowed Tracking Origins must be an array')\n    return\n  }\n\n  if (\n    !isDatadogSite(initConfiguration.site) ||\n    !isSampleRate(initConfiguration.sessionSampleRate, 'Session') ||\n    !isSampleRate(initConfiguration.telemetrySampleRate, 'Telemetry') ||\n    !isSampleRate(initConfiguration.telemetryConfigurationSampleRate, 'Telemetry Configuration') ||\n    !isSampleRate(initConfiguration.telemetryUsageSampleRate, 'Telemetry Usage') ||\n    !isString(initConfiguration.version, 'Version') ||\n    !isString(initConfiguration.env, 'Env') ||\n    !isString(initConfiguration.service, 'Service') ||\n    !isAllowedTrackingOrigins(initConfiguration)\n  ) {\n    return\n  }\n\n  if (\n    initConfiguration.trackingConsent !== undefined &&\n    !objectHasValue(TrackingConsent, initConfiguration.trackingConsent)\n  ) {\n    display.error('Tracking Consent should be either \"granted\" or \"not-granted\"')\n    return\n  }\n\n  return {\n    beforeSend:\n      initConfiguration.beforeSend && catchUserErrors(initConfiguration.beforeSend, 'beforeSend threw an error:'),\n    sessionStoreStrategyType: selectSessionStoreStrategyType(initConfiguration),\n    sessionSampleRate: initConfiguration.sessionSampleRate ?? 100,\n    telemetrySampleRate: initConfiguration.telemetrySampleRate ?? 20,\n    telemetryConfigurationSampleRate: initConfiguration.telemetryConfigurationSampleRate ?? 5,\n    telemetryUsageSampleRate: initConfiguration.telemetryUsageSampleRate ?? 5,\n    service: initConfiguration.service || undefined,\n    silentMultipleInit: !!initConfiguration.silentMultipleInit,\n    allowUntrustedEvents: !!initConfiguration.allowUntrustedEvents,\n    trackingConsent: initConfiguration.trackingConsent ?? TrackingConsent.GRANTED,\n    trackAnonymousUser: initConfiguration.trackAnonymousUser ?? true,\n    storeContextsAcrossPages: !!initConfiguration.storeContextsAcrossPages,\n    /**\n     * beacon payload max queue size implementation is 64kb\n     * ensure that we leave room for logs, rum and potential other users\n     */\n    batchBytesLimit: 16 * ONE_KIBI_BYTE,\n\n    eventRateLimiterThreshold: 3000,\n    maxTelemetryEventsPerPage: 15,\n\n    /**\n     * flush automatically, aim to be lower than ALB connection timeout\n     * to maximize connection reuse.\n     */\n    flushTimeout: (30 * ONE_SECOND) as Duration,\n\n    /**\n     * Logs intake limit\n     */\n    batchMessagesLimit: 50,\n    messageBytesLimit: 256 * ONE_KIBI_BYTE,\n    ...computeTransportConfiguration(initConfiguration),\n  }\n}\n\nexport function serializeConfiguration(initConfiguration: InitConfiguration) {\n  return {\n    session_sample_rate: initConfiguration.sessionSampleRate,\n    telemetry_sample_rate: initConfiguration.telemetrySampleRate,\n    telemetry_configuration_sample_rate: initConfiguration.telemetryConfigurationSampleRate,\n    telemetry_usage_sample_rate: initConfiguration.telemetryUsageSampleRate,\n    use_before_send: !!initConfiguration.beforeSend,\n    use_partitioned_cross_site_session_cookie: initConfiguration.usePartitionedCrossSiteSessionCookie,\n    use_secure_session_cookie: initConfiguration.useSecureSessionCookie,\n    use_proxy: !!initConfiguration.proxy,\n    silent_multiple_init: initConfiguration.silentMultipleInit,\n    track_session_across_subdomains: initConfiguration.trackSessionAcrossSubdomains,\n    track_anonymous_user: initConfiguration.trackAnonymousUser,\n    session_persistence: initConfiguration.sessionPersistence,\n    allow_fallback_to_local_storage: !!initConfiguration.allowFallbackToLocalStorage,\n    store_contexts_across_pages: !!initConfiguration.storeContextsAcrossPages,\n    allow_untrusted_events: !!initConfiguration.allowUntrustedEvents,\n    tracking_consent: initConfiguration.trackingConsent,\n    use_allowed_tracking_origins: Array.isArray(initConfiguration.allowedTrackingOrigins),\n  } satisfies RawTelemetryConfiguration\n}\n", "import { catchUserErrors } from '../tools/catchUserErrors'\nimport { setDebugMode } from '../tools/monitor'\nimport { display } from '../tools/display'\n\n// replaced at build time\ndeclare const __BUILD_ENV__SDK_VERSION__: string\n\nexport interface PublicApi {\n  /**\n   * Version of the Logs browser SDK\n   */\n  version: string\n\n  /**\n   * [For CDN async setup] Early RUM API calls must be wrapped in the `window.DD_RUM.onReady()` callback. This ensures the code only gets executed once the SDK is properly loaded.\n   *\n   * See [CDN async setup](https://docs.datadoghq.com/real_user_monitoring/browser/#cdn-async) for further information.\n   */\n  onReady: (callback: () => void) => void\n}\n\nexport function makePublicApi<T extends PublicApi>(stub: Omit<T, keyof PublicApi>): T {\n  const publicApi = {\n    version: __BUILD_ENV__SDK_VERSION__,\n    // This API method is intentionally not monitored, since the only thing executed is the\n    // user-provided 'callback'.  All SDK usages executed in the callback should be monitored, and\n    // we don't want to interfere with the user uncaught exceptions.\n    onReady(callback: () => void) {\n      callback()\n    },\n    ...stub,\n  }\n\n  // Add a \"hidden\" property to set debug mode. We define it that way to hide it\n  // as much as possible but of course it's not a real protection.\n  Object.defineProperty(publicApi, '_setDebug', {\n    get() {\n      return setDebugMode\n    },\n    enumerable: false,\n  })\n\n  return publicApi as T\n}\n\nexport function defineGlobal<Global, Name extends keyof Global>(global: Global, name: Name, api: Global[Name]) {\n  const existingGlobalVariable = global[name] as { q?: Array<() => void>; version?: string } | undefined\n  if (existingGlobalVariable && !existingGlobalVariable.q && existingGlobalVariable.version) {\n    display.warn('SDK is loaded more than once. This is unsupported and might have unexpected behavior.')\n  }\n  global[name] = api\n  if (existingGlobalVariable && existingGlobalVariable.q) {\n    existingGlobalVariable.q.forEach((fn) => catchUserErrors(fn, 'onReady callback threw an error:')())\n  }\n}\n", "import { setTimeout } from './timer'\nimport { callMonitored } from './monitor'\nimport { noop } from './utils/functionUtils'\nimport { createHandlingStack } from './stackTrace/handlingStack'\n\n/**\n * Object passed to the callback of an instrumented method call. See `instrumentMethod` for more\n * info.\n */\nexport type InstrumentedMethodCall<TARGET extends { [key: string]: any }, METHOD extends keyof TARGET> = {\n  /**\n   * The target object on which the method was called.\n   */\n  target: TARGET\n\n  /**\n   * The parameters with which the method was called.\n   *\n   * Note: if needed, parameters can be mutated by the instrumentation\n   */\n  parameters: Parameters<TARGET[METHOD]>\n\n  /**\n   * Registers a callback that will be called after the original method is called, with the method\n   * result passed as argument.\n   */\n  onPostCall: (callback: PostCallCallback<TARGET, METHOD>) => void\n\n  /**\n   * The stack trace of the method call.\n   */\n  handlingStack?: string\n}\n\ntype PostCallCallback<TARGET extends { [key: string]: any }, METHOD extends keyof TARGET> = (\n  result: ReturnType<TARGET[METHOD]>\n) => void\n\n/**\n * Instruments a method on a object, calling the given callback before the original method is\n * invoked. The callback receives an object with information about the method call.\n *\n * This function makes sure that we are \"good citizens\" regarding third party instrumentations: when\n * removing the instrumentation, the original method is usually restored, but if a third party\n * instrumentation was set after ours, we keep it in place and just replace our instrumentation with\n * a noop.\n *\n * Note: it is generally better to instrument methods that are \"owned\" by the object instead of ones\n * that are inherited from the prototype chain. Example:\n * * do:    `instrumentMethod(Array.prototype, 'push', ...)`\n * * don't: `instrumentMethod([], 'push', ...)`\n *\n * This method is also used to set event handler properties (ex: window.onerror = ...), as it has\n * the same requirements as instrumenting a method:\n * * if the event handler is already set by a third party, we need to call it and not just blindly\n * override it.\n * * if the event handler is set by a third party after us, we need to keep it in place when\n * removing ours.\n *\n * @example\n *\n *  instrumentMethod(window, 'fetch', ({ target, parameters, onPostCall }) => {\n *    console.log('Before calling fetch on', target, 'with parameters', parameters)\n *\n *    onPostCall((result) => {\n *      console.log('After fetch calling on', target, 'with parameters', parameters, 'and result', result)\n *    })\n *  })\n */\nexport function instrumentMethod<TARGET extends { [key: string]: any }, METHOD extends keyof TARGET & string>(\n  targetPrototype: TARGET,\n  method: METHOD,\n  onPreCall: (this: null, callInfos: InstrumentedMethodCall<TARGET, METHOD>) => void,\n  { computeHandlingStack }: { computeHandlingStack?: boolean } = {}\n) {\n  let original = targetPrototype[method]\n\n  if (typeof original !== 'function') {\n    if (method in targetPrototype && method.startsWith('on')) {\n      original = noop as TARGET[METHOD]\n    } else {\n      return { stop: noop }\n    }\n  }\n\n  let stopped = false\n\n  const instrumentation = function (this: TARGET): ReturnType<TARGET[METHOD]> | undefined {\n    if (stopped) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-call\n      return original.apply(this, arguments as unknown as Parameters<TARGET[METHOD]>)\n    }\n\n    const parameters = Array.from(arguments) as Parameters<TARGET[METHOD]>\n\n    let postCallCallback: PostCallCallback<TARGET, METHOD> | undefined\n\n    callMonitored(onPreCall, null, [\n      {\n        target: this,\n        parameters,\n        onPostCall: (callback) => {\n          postCallCallback = callback\n        },\n        handlingStack: computeHandlingStack ? createHandlingStack('instrumented method') : undefined,\n      },\n    ])\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n    const result = original.apply(this, parameters)\n\n    if (postCallCallback) {\n      callMonitored(postCallCallback, null, [result])\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return result\n  }\n\n  targetPrototype[method] = instrumentation as TARGET[METHOD]\n\n  return {\n    stop: () => {\n      stopped = true\n      // If the instrumentation has been removed by a third party, keep the last one\n      if (targetPrototype[method] === instrumentation) {\n        targetPrototype[method] = original\n      }\n    },\n  }\n}\n\nexport function instrumentSetter<TARGET extends { [key: string]: any }, PROPERTY extends keyof TARGET>(\n  targetPrototype: TARGET,\n  property: PROPERTY,\n  after: (target: TARGET, value: TARGET[PROPERTY]) => void\n) {\n  const originalDescriptor = Object.getOwnPropertyDescriptor(targetPrototype, property)\n  if (!originalDescriptor || !originalDescriptor.set || !originalDescriptor.configurable) {\n    return { stop: noop }\n  }\n\n  const stoppedInstrumentation = noop\n  let instrumentation = (target: TARGET, value: TARGET[PROPERTY]) => {\n    // put hooked setter into event loop to avoid of set latency\n    setTimeout(() => {\n      if (instrumentation !== stoppedInstrumentation) {\n        after(target, value)\n      }\n    }, 0)\n  }\n\n  const instrumentationWrapper = function (this: TARGET, value: TARGET[PROPERTY]) {\n    originalDescriptor.set!.call(this, value)\n    instrumentation(this, value)\n  }\n\n  Object.defineProperty(targetPrototype, property, {\n    set: instrumentationWrapper,\n  })\n\n  return {\n    stop: () => {\n      if (Object.getOwnPropertyDescriptor(targetPrototype, property)?.set === instrumentationWrapper) {\n        Object.defineProperty(targetPrototype, property, originalDescriptor)\n      }\n      instrumentation = stoppedInstrumentation\n    },\n  }\n}\n", "import { instrumentMethod } from '../../tools/instrumentMethod'\nimport type { Observable } from '../../tools/observable'\nimport { clocksNow } from '../../tools/utils/timeUtils'\nimport type { StackTrace } from '../../tools/stackTrace/computeStackTrace'\nimport { computeStackTraceFromOnErrorMessage } from '../../tools/stackTrace/computeStackTrace'\nimport { computeRawError, isError } from './error'\nimport type { RawError } from './error.types'\nimport { ErrorHandling, ErrorSource, NonErrorPrefix } from './error.types'\n\nexport type UnhandledErrorCallback = (originalError: unknown, stackTrace?: StackTrace) => any\n\nexport function trackRuntimeError(errorObservable: Observable<RawError>) {\n  const handleRuntimeError = (originalError: unknown, stackTrace?: StackTrace) => {\n    const rawError = computeRawError({\n      stackTrace,\n      originalError,\n      startClocks: clocksNow(),\n      nonErrorPrefix: NonErrorPrefix.UNCAUGHT,\n      source: ErrorSource.SOURCE,\n      handling: ErrorHandling.UNHANDLED,\n    })\n    errorObservable.notify(rawError)\n  }\n  const { stop: stopInstrumentingOnError } = instrumentOnError(handleRuntimeError)\n  const { stop: stopInstrumentingOnUnhandledRejection } = instrumentUnhandledRejection(handleRuntimeError)\n\n  return {\n    stop: () => {\n      stopInstrumentingOnError()\n      stopInstrumentingOnUnhandledRejection()\n    },\n  }\n}\n\nexport function instrumentOnError(callback: UnhandledErrorCallback) {\n  return instrumentMethod(window, 'onerror', ({ parameters: [messageObj, url, line, column, errorObj] }) => {\n    let stackTrace\n    if (!isError(errorObj)) {\n      stackTrace = computeStackTraceFromOnErrorMessage(messageObj, url, line, column)\n    }\n    callback(errorObj ?? messageObj, stackTrace)\n  })\n}\n\nexport function instrumentUnhandledRejection(callback: UnhandledErrorCallback) {\n  return instrumentMethod(window, 'onunhandledrejection', ({ parameters: [e] }) => {\n    callback(e.reason || 'Empty reason')\n  })\n}\n", "import type { InitConfiguration } from '../domain/configuration'\nimport { display } from '../tools/display'\n\nexport function displayAlreadyInitializedError(sdkName: 'DD_RUM' | 'DD_LOGS', initConfiguration: InitConfiguration) {\n  if (!initConfiguration.silentMultipleInit) {\n    display.error(`${sdkName} is already initialized.`)\n  }\n}\n", "import { toStackTraceString } from '../../tools/stackTrace/handlingStack'\nimport { monitor } from '../../tools/monitor'\nimport { mergeObservables, Observable } from '../../tools/observable'\nimport { addEventListener, DOM_EVENT } from '../../browser/addEventListener'\nimport { safeTruncate } from '../../tools/utils/stringUtils'\nimport type { Configuration } from '../configuration'\nimport type { RawError } from '../error/error.types'\nimport { ErrorHandling, ErrorSource } from '../error/error.types'\nimport { clocksNow } from '../../tools/utils/timeUtils'\nimport type { ReportType, InterventionReport, DeprecationReport } from './browser.types'\n\nexport const RawReportType = {\n  intervention: 'intervention',\n  deprecation: 'deprecation',\n  cspViolation: 'csp_violation',\n} as const\n\nexport type RawReportType = (typeof RawReportType)[keyof typeof RawReportType]\n\nexport type RawReportError = RawError & {\n  originalError: SecurityPolicyViolationEvent | DeprecationReport | InterventionReport\n}\n\nexport function initReportObservable(configuration: Configuration, apis: RawReportType[]) {\n  const observables: Array<Observable<RawReportError>> = []\n\n  if (apis.includes(RawReportType.cspViolation)) {\n    observables.push(createCspViolationReportObservable(configuration))\n  }\n\n  const reportTypes = apis.filter((api: RawReportType): api is ReportType => api !== RawReportType.cspViolation)\n  if (reportTypes.length) {\n    observables.push(createReportObservable(reportTypes))\n  }\n\n  return mergeObservables(...observables)\n}\n\nfunction createReportObservable(reportTypes: ReportType[]) {\n  return new Observable<RawReportError>((observable) => {\n    if (!window.ReportingObserver) {\n      return\n    }\n\n    const handleReports = monitor((reports: Array<DeprecationReport | InterventionReport>, _: ReportingObserver) =>\n      reports.forEach((report) => observable.notify(buildRawReportErrorFromReport(report)))\n    ) as ReportingObserverCallback\n\n    const observer = new window.ReportingObserver(handleReports, {\n      types: reportTypes,\n      buffered: true,\n    })\n\n    observer.observe()\n    return () => {\n      observer.disconnect()\n    }\n  })\n}\n\nfunction createCspViolationReportObservable(configuration: Configuration) {\n  return new Observable<RawReportError>((observable) => {\n    const { stop } = addEventListener(configuration, document, DOM_EVENT.SECURITY_POLICY_VIOLATION, (event) => {\n      observable.notify(buildRawReportErrorFromCspViolation(event))\n    })\n\n    return stop\n  })\n}\n\nfunction buildRawReportErrorFromReport(report: DeprecationReport | InterventionReport): RawReportError {\n  const { type, body } = report\n\n  return buildRawReportError({\n    type: body.id,\n    message: `${type}: ${body.message}`,\n    originalError: report,\n    stack: buildStack(body.id, body.message, body.sourceFile, body.lineNumber, body.columnNumber),\n  })\n}\n\nfunction buildRawReportErrorFromCspViolation(event: SecurityPolicyViolationEvent): RawReportError {\n  const message = `'${event.blockedURI}' blocked by '${event.effectiveDirective}' directive`\n  return buildRawReportError({\n    type: event.effectiveDirective,\n    message: `${RawReportType.cspViolation}: ${message}`,\n    originalError: event,\n    csp: {\n      disposition: event.disposition,\n    },\n    stack: buildStack(\n      event.effectiveDirective,\n      event.originalPolicy\n        ? `${message} of the policy \"${safeTruncate(event.originalPolicy, 100, '...')}\"`\n        : 'no policy',\n      event.sourceFile,\n      event.lineNumber,\n      event.columnNumber\n    ),\n  })\n}\n\nfunction buildRawReportError(partial: Omit<RawReportError, 'startClocks' | 'source' | 'handling'>): RawReportError {\n  return {\n    startClocks: clocksNow(),\n    source: ErrorSource.REPORT,\n    handling: ErrorHandling.UNHANDLED,\n    ...partial,\n  }\n}\n\nfunction buildStack(\n  name: string,\n  message: string,\n  sourceFile: string | null,\n  lineNumber: number | null,\n  columnNumber: number | null\n): string | undefined {\n  return sourceFile\n    ? toStackTraceString({\n        name,\n        message,\n        stack: [\n          {\n            func: '?',\n            url: sourceFile,\n            line: lineNumber ?? undefined,\n            column: columnNumber ?? undefined,\n          },\n        ],\n      })\n    : undefined\n}\n", "import { setInterval, clearInterval } from './timer'\nimport type { TimeoutId } from './timer'\nimport { removeItem } from './utils/arrayUtils'\nimport type { Duration, RelativeTime } from './utils/timeUtils'\nimport { addDuration, relativeNow, ONE_MINUTE } from './utils/timeUtils'\n\nconst END_OF_TIMES = Infinity as RelativeTime\n\nexport interface ValueHistoryEntry<T> {\n  startTime: RelativeTime\n  endTime: RelativeTime\n  value: T\n  remove(): void\n  close(endTime: RelativeTime): void\n}\n\nexport const CLEAR_OLD_VALUES_INTERVAL = ONE_MINUTE\n\n/**\n * Store and keep track of values spans. This whole cache assumes that values are added in\n * chronological order (i.e. all entries have an increasing start time).\n */\nexport interface ValueHistory<Value> {\n  add: (value: Value, startTime: RelativeTime) => ValueHistoryEntry<Value>\n  find: (startTime?: RelativeTime, options?: { returnInactive: boolean }) => Value | undefined\n\n  closeActive: (endTime: RelativeTime) => void\n  findAll: (startTime?: RelativeTime, duration?: Duration) => Value[]\n  reset: () => void\n  stop: () => void\n}\n\nlet cleanupHistoriesInterval: TimeoutId | null = null\n\nconst cleanupTasks: Set<() => void> = new Set()\n\nfunction cleanupHistories() {\n  cleanupTasks.forEach((task) => task())\n}\n\nexport function createValueHistory<Value>({\n  expireDelay,\n  maxEntries,\n}: {\n  expireDelay: number\n  maxEntries?: number\n}): ValueHistory<Value> {\n  let entries: Array<ValueHistoryEntry<Value>> = []\n\n  if (!cleanupHistoriesInterval) {\n    cleanupHistoriesInterval = setInterval(() => cleanupHistories(), CLEAR_OLD_VALUES_INTERVAL)\n  }\n\n  const clearExpiredValues = () => {\n    const oldTimeThreshold = relativeNow() - expireDelay\n    while (entries.length > 0 && entries[entries.length - 1].endTime < oldTimeThreshold) {\n      entries.pop()\n    }\n  }\n\n  cleanupTasks.add(clearExpiredValues)\n\n  /**\n   * Add a value to the history associated with a start time. Returns a reference to this newly\n   * added entry that can be removed or closed.\n   */\n  function add(value: Value, startTime: RelativeTime): ValueHistoryEntry<Value> {\n    const entry: ValueHistoryEntry<Value> = {\n      value,\n      startTime,\n      endTime: END_OF_TIMES,\n      remove: () => {\n        removeItem(entries, entry)\n      },\n      close: (endTime: RelativeTime) => {\n        entry.endTime = endTime\n      },\n    }\n\n    if (maxEntries && entries.length >= maxEntries) {\n      entries.pop()\n    }\n\n    entries.unshift(entry)\n\n    return entry\n  }\n\n  /**\n   * Return the latest value that was active during `startTime`, or the currently active value\n   * if no `startTime` is provided. This method assumes that entries are not overlapping.\n   *\n   * If `option.returnInactive` is true, returns the value at `startTime` (active or not).\n   */\n  function find(\n    startTime: RelativeTime = END_OF_TIMES,\n    options: { returnInactive: boolean } = { returnInactive: false }\n  ): Value | undefined {\n    for (const entry of entries) {\n      if (entry.startTime <= startTime) {\n        if (options.returnInactive || startTime <= entry.endTime) {\n          return entry.value\n        }\n        break\n      }\n    }\n  }\n\n  /**\n   * Helper function to close the currently active value, if any. This method assumes that entries\n   * are not overlapping.\n   */\n  function closeActive(endTime: RelativeTime) {\n    const latestEntry = entries[0]\n    if (latestEntry && latestEntry.endTime === END_OF_TIMES) {\n      latestEntry.close(endTime)\n    }\n  }\n\n  /**\n   * Return all values with an active period overlapping with the duration,\n   * or all values that were active during `startTime` if no duration is provided,\n   * or all currently active values if no `startTime` is provided.\n   */\n  function findAll(startTime: RelativeTime = END_OF_TIMES, duration = 0 as Duration): Value[] {\n    const endTime = addDuration(startTime, duration)\n    return entries\n      .filter((entry) => entry.startTime <= endTime && startTime <= entry.endTime)\n      .map((entry) => entry.value)\n  }\n\n  /**\n   * Remove all entries from this collection.\n   */\n  function reset() {\n    entries = []\n  }\n\n  /**\n   * Stop internal garbage collection of past entries.\n   */\n  function stop() {\n    cleanupTasks.delete(clearExpiredValues)\n    if (cleanupTasks.size === 0 && cleanupHistoriesInterval) {\n      clearInterval(cleanupHistoriesInterval)\n      cleanupHistoriesInterval = null\n    }\n  }\n\n  return { add, find, closeActive, findAll, reset, stop }\n}\n", "import { getInitCookie } from '../../browser/cookie'\n\nexport const SYNTHETICS_TEST_ID_COOKIE_NAME = 'datadog-synthetics-public-id'\nexport const SYNTHETICS_RESULT_ID_COOKIE_NAME = 'datadog-synthetics-result-id'\nexport const SYNTHETICS_INJECTS_RUM_COOKIE_NAME = 'datadog-synthetics-injects-rum'\n\nexport interface BrowserWindow extends Window {\n  _DATADOG_SYNTHETICS_PUBLIC_ID?: unknown\n  _DATADOG_SYNTHETICS_RESULT_ID?: unknown\n  _DATADOG_SYNTHETICS_INJECTS_RUM?: unknown\n}\n\nexport function willSyntheticsInjectRum(): boolean {\n  return Boolean(\n    (window as BrowserWindow)._DATADOG_SYNTHETICS_INJECTS_RUM || getInitCookie(SYNTHETICS_INJECTS_RUM_COOKIE_NAME)\n  )\n}\n\nexport function getSyntheticsTestId(): string | undefined {\n  const value = (window as BrowserWindow)._DATADOG_SYNTHETICS_PUBLIC_ID || getInitCookie(SYNTHETICS_TEST_ID_COOKIE_NAME)\n  return typeof value === 'string' ? value : undefined\n}\n\nexport function getSyntheticsResultId(): string | undefined {\n  const value =\n    (window as BrowserWindow)._DATADOG_SYNTHETICS_RESULT_ID || getInitCookie(SYNTHETICS_RESULT_ID_COOKIE_NAME)\n  return typeof value === 'string' ? value : undefined\n}\n\nexport function isSyntheticsTest(): boolean {\n  return Boolean(getSyntheticsTestId() && getSyntheticsResultId())\n}\n", "import { Observable } from '../../tools/observable'\nimport type { Context } from '../../tools/serialisation/context'\nimport { createValueHistory } from '../../tools/valueHistory'\nimport type { RelativeTime } from '../../tools/utils/timeUtils'\nimport { clocksOrigin, ONE_MINUTE, relativeNow } from '../../tools/utils/timeUtils'\nimport { addEventListener, addEventListeners, DOM_EVENT } from '../../browser/addEventListener'\nimport { clearInterval, setInterval } from '../../tools/timer'\nimport type { Configuration } from '../configuration'\nimport type { TrackingConsentState } from '../trackingConsent'\nimport { addTelemetryDebug } from '../telemetry'\nimport { isSyntheticsTest } from '../synthetics/syntheticsWorkerValues'\nimport { SESSION_NOT_TRACKED, SESSION_TIME_OUT_DELAY } from './sessionConstants'\nimport { startSessionStore } from './sessionStore'\nimport type { SessionState } from './sessionState'\nimport { retrieveSessionCookie } from './storeStrategies/sessionInCookie'\n\nexport interface SessionManager<TrackingType extends string> {\n  findSession: (\n    startTime?: RelativeTime,\n    options?: { returnInactive: boolean }\n  ) => SessionContext<TrackingType> | undefined\n  renewObservable: Observable<void>\n  expireObservable: Observable<void>\n  sessionStateUpdateObservable: Observable<{ previousState: SessionState; newState: SessionState }>\n  expire: () => void\n  updateSessionState: (state: Partial<SessionState>) => void\n}\n\nexport interface SessionContext<TrackingType extends string> extends Context {\n  id: string\n  trackingType: TrackingType\n  isReplayForced: boolean\n  anonymousId: string | undefined\n}\n\nexport const VISIBILITY_CHECK_DELAY = ONE_MINUTE\nconst SESSION_CONTEXT_TIMEOUT_DELAY = SESSION_TIME_OUT_DELAY\nlet stopCallbacks: Array<() => void> = []\n\nexport function startSessionManager<TrackingType extends string>(\n  configuration: Configuration,\n  productKey: string,\n  computeTrackingType: (rawTrackingType?: string) => TrackingType,\n  trackingConsentState: TrackingConsentState\n): SessionManager<TrackingType> {\n  const renewObservable = new Observable<void>()\n  const expireObservable = new Observable<void>()\n\n  // TODO - Improve configuration type and remove assertion\n  const sessionStore = startSessionStore(\n    configuration.sessionStoreStrategyType!,\n    configuration,\n    productKey,\n    computeTrackingType\n  )\n  stopCallbacks.push(() => sessionStore.stop())\n\n  const sessionContextHistory = createValueHistory<SessionContext<TrackingType>>({\n    expireDelay: SESSION_CONTEXT_TIMEOUT_DELAY,\n  })\n  stopCallbacks.push(() => sessionContextHistory.stop())\n\n  sessionStore.renewObservable.subscribe(() => {\n    sessionContextHistory.add(buildSessionContext(), relativeNow())\n    renewObservable.notify()\n  })\n  sessionStore.expireObservable.subscribe(() => {\n    expireObservable.notify()\n    sessionContextHistory.closeActive(relativeNow())\n  })\n\n  // We expand/renew session unconditionally as tracking consent is always granted when the session\n  // manager is started.\n  sessionStore.expandOrRenewSession()\n  sessionContextHistory.add(buildSessionContext(), clocksOrigin().relative)\n\n  trackingConsentState.observable.subscribe(() => {\n    if (trackingConsentState.isGranted()) {\n      sessionStore.expandOrRenewSession()\n    } else {\n      sessionStore.expire()\n    }\n  })\n\n  trackActivity(configuration, () => {\n    if (trackingConsentState.isGranted()) {\n      sessionStore.expandOrRenewSession()\n    }\n  })\n  trackVisibility(configuration, () => sessionStore.expandSession())\n  trackResume(configuration, () => sessionStore.restartSession())\n\n  function buildSessionContext() {\n    const session = sessionStore.getSession()\n\n    if (!session) {\n      const rawSession = retrieveSessionCookie()\n      const sessionCookies = document.cookie.split(/\\s*;\\s*/).filter((cookie) => cookie.startsWith('_dd_s'))\n\n      addTelemetryDebug('Unexpected session state', {\n        session: rawSession,\n        isSyntheticsTest: isSyntheticsTest(),\n        createdTimestamp: rawSession?.created,\n        expireTimestamp: rawSession?.expire,\n        cookie: {\n          count: sessionCookies.length,\n          ...sessionCookies,\n        },\n      })\n\n      return {\n        id: 'invalid',\n        trackingType: SESSION_NOT_TRACKED as TrackingType,\n        isReplayForced: false,\n        anonymousId: undefined,\n      }\n    }\n\n    return {\n      id: session.id!,\n      trackingType: session[productKey] as TrackingType,\n      isReplayForced: !!session.forcedReplay,\n      anonymousId: session.anonymousId,\n    }\n  }\n\n  return {\n    findSession: (startTime, options) => sessionContextHistory.find(startTime, options),\n    renewObservable,\n    expireObservable,\n    sessionStateUpdateObservable: sessionStore.sessionStateUpdateObservable,\n    expire: sessionStore.expire,\n    updateSessionState: sessionStore.updateSessionState,\n  }\n}\n\nexport function stopSessionManager() {\n  stopCallbacks.forEach((e) => e())\n  stopCallbacks = []\n}\n\nfunction trackActivity(configuration: Configuration, expandOrRenewSession: () => void) {\n  const { stop } = addEventListeners(\n    configuration,\n    window,\n    [DOM_EVENT.CLICK, DOM_EVENT.TOUCH_START, DOM_EVENT.KEY_DOWN, DOM_EVENT.SCROLL],\n    expandOrRenewSession,\n    { capture: true, passive: true }\n  )\n  stopCallbacks.push(stop)\n}\n\nfunction trackVisibility(configuration: Configuration, expandSession: () => void) {\n  const expandSessionWhenVisible = () => {\n    if (document.visibilityState === 'visible') {\n      expandSession()\n    }\n  }\n\n  const { stop } = addEventListener(configuration, document, DOM_EVENT.VISIBILITY_CHANGE, expandSessionWhenVisible)\n  stopCallbacks.push(stop)\n\n  const visibilityCheckInterval = setInterval(expandSessionWhenVisible, VISIBILITY_CHECK_DELAY)\n  stopCallbacks.push(() => {\n    clearInterval(visibilityCheckInterval)\n  })\n}\n\nfunction trackResume(configuration: Configuration, cb: () => void) {\n  const { stop } = addEventListener(configuration, window, DOM_EVENT.RESUME, cb, { capture: true })\n  stopCallbacks.push(stop)\n}\n", "import { computeBytesCount } from './utils/byteUtils'\n\nexport interface Encoder<Output extends string | Uint8Array = string | Uint8Array> {\n  /**\n   * Whether this encoder might call the provided callbacks asynchronously\n   */\n  isAsync: boolean\n\n  /**\n   * Whether some data has been written since the last finish() or finishSync() call\n   */\n  isEmpty: boolean\n\n  /**\n   * Write a string to be encoded.\n   *\n   * This operation can be synchronous or asynchronous depending on the encoder implementation.\n   *\n   * If specified, the callback will be invoked when the operation finishes, unless the operation is\n   * asynchronous and finish() or finishSync() is called in the meantime.\n   */\n  write(data: string, callback?: (additionalEncodedBytesCount: number) => void): void\n\n  /**\n   * Waits for pending data to be encoded and resets the encoder state.\n   *\n   * This operation can be synchronous or asynchronous depending on the encoder implementation.\n   *\n   * The callback will be invoked when the operation finishes, unless the operation is asynchronous\n   * and another call to finish() or finishSync() occurs in the meantime.\n   */\n  finish(callback: (result: EncoderResult<Output>) => void): void\n\n  /**\n   * Resets the encoder state then returns the encoded data and any potential pending data directly,\n   * discarding all pending write operations and finish() callbacks.\n   */\n  finishSync(): EncoderResult<Output> & { pendingData: string }\n\n  /**\n   * Returns a rough estimation of the bytes count if the data was encoded.\n   */\n  estimateEncodedBytesCount(data: string): number\n}\n\nexport interface EncoderResult<Output extends string | Uint8Array = string | Uint8Array> {\n  output: Output\n  outputBytesCount: number\n\n  /**\n   * An encoding type supported by HTTP Content-Encoding, if applicable.\n   * See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding#directives\n   */\n  encoding?: 'deflate'\n\n  /**\n   * Total bytes count of the input strings encoded to UTF-8.\n   */\n  rawBytesCount: number\n}\n\nexport function createIdentityEncoder(): Encoder<string> {\n  let output = ''\n  let outputBytesCount = 0\n\n  return {\n    isAsync: false,\n\n    get isEmpty() {\n      return !output\n    },\n\n    write(data, callback) {\n      const additionalEncodedBytesCount = computeBytesCount(data)\n      outputBytesCount += additionalEncodedBytesCount\n      output += data\n      if (callback) {\n        callback(additionalEncodedBytesCount)\n      }\n    },\n\n    finish(callback) {\n      callback(this.finishSync())\n    },\n\n    finishSync() {\n      const result = {\n        output,\n        outputBytesCount,\n        rawBytesCount: outputBytesCount,\n        pendingData: '',\n      }\n      output = ''\n      outputBytesCount = 0\n      return result\n    },\n\n    estimateEncodedBytesCount(data) {\n      return data.length\n    },\n  }\n}\n", "import type { Subscription } from './observable'\n\n/**\n * Type helper to extract event types that have \"void\" data. This allows to call `notify` without a\n * second argument. Ex:\n *\n * ```\n * interface EventMap {\n *   foo: void\n * }\n * const LifeCycle = AbstractLifeCycle<EventMap>\n * new LifeCycle().notify('foo')\n * ```\n */\ntype EventTypesWithoutData<EventMap> = {\n  [K in keyof EventMap]: EventMap[K] extends void ? K : never\n}[keyof EventMap]\n\n// eslint-disable-next-line no-restricted-syntax\nexport class AbstractLifeCycle<EventMap> {\n  private callbacks: { [key in keyof EventMap]?: Array<(data: any) => void> } = {}\n\n  notify<EventType extends EventTypesWithoutData<EventMap>>(eventType: EventType): void\n  notify<EventType extends keyof EventMap>(eventType: EventType, data: EventMap[EventType]): void\n  notify(eventType: keyof EventMap, data?: unknown) {\n    const eventCallbacks = this.callbacks[eventType]\n    if (eventCallbacks) {\n      eventCallbacks.forEach((callback) => callback(data))\n    }\n  }\n\n  subscribe<EventType extends keyof EventMap>(\n    eventType: EventType,\n    callback: (data: EventMap[EventType]) => void\n  ): Subscription {\n    if (!this.callbacks[eventType]) {\n      this.callbacks[eventType] = []\n    }\n    this.callbacks[eventType]!.push(callback)\n    return {\n      unsubscribe: () => {\n        this.callbacks[eventType] = this.callbacks[eventType]!.filter((other) => callback !== other)\n      },\n    }\n  }\n}\n", "import { setTimeout } from '../../tools/timer'\nimport { clocksNow, ONE_MINUTE } from '../../tools/utils/timeUtils'\nimport type { RawError } from '../error/error.types'\nimport { ErrorSource } from '../error/error.types'\n\nexport type EventRateLimiter = ReturnType<typeof createEventRateLimiter>\n\nexport function createEventRateLimiter(\n  eventType: string,\n  limit: number,\n  onLimitReached: (limitError: RawError) => void\n) {\n  let eventCount = 0\n  let allowNextEvent = false\n\n  return {\n    isLimitReached() {\n      if (eventCount === 0) {\n        setTimeout(() => {\n          eventCount = 0\n        }, ONE_MINUTE)\n      }\n\n      eventCount += 1\n      if (eventCount <= limit || allowNextEvent) {\n        allowNextEvent = false\n        return false\n      }\n\n      if (eventCount === limit + 1) {\n        allowNextEvent = true\n        try {\n          onLimitReached({\n            message: `Reached max number of ${eventType}s by minute: ${limit}`,\n            source: ErrorSource.AGENT,\n            startClocks: clocksNow(),\n          })\n        } finally {\n          allowNextEvent = false\n        }\n      }\n\n      return true\n    },\n  }\n}\n", "import type { Configuration } from '../domain/configuration'\nimport { noop } from '../tools/utils/functionUtils'\nimport { DOM_EVENT, addEventListener } from './addEventListener'\n\nexport function runOnReadyState(\n  configuration: Configuration,\n  expectedReadyState: 'complete' | 'interactive',\n  callback: () => void\n): { stop: () => void } {\n  if (document.readyState === expectedReadyState || document.readyState === 'complete') {\n    callback()\n    return { stop: noop }\n  }\n  const eventName = expectedReadyState === 'complete' ? DOM_EVENT.LOAD : DOM_EVENT.DOM_CONTENT_LOADED\n  return addEventListener(configuration, window, eventName, callback, { once: true })\n}\n\nexport function asyncRunOnReadyState(\n  configuration: Configuration,\n  expectedReadyState: 'complete' | 'interactive'\n): Promise<void> {\n  return new Promise((resolve) => {\n    runOnReadyState(configuration, expectedReadyState, resolve)\n  })\n}\n", "import type { InstrumentedMethodCall } from '../tools/instrumentMethod'\nimport { instrumentMethod } from '../tools/instrumentMethod'\nimport { Observable } from '../tools/observable'\nimport type { Duration, ClocksState } from '../tools/utils/timeUtils'\nimport { elapsed, clocksNow, timeStampNow } from '../tools/utils/timeUtils'\nimport { normalizeUrl } from '../tools/utils/urlPolyfill'\nimport { shallowClone } from '../tools/utils/objectUtils'\nimport type { Configuration } from '../domain/configuration'\nimport { addEventListener } from './addEventListener'\n\nexport interface XhrOpenContext {\n  state: 'open'\n  method: string\n  url: string\n}\n\nexport interface XhrStartContext extends Omit<XhrOpenContext, 'state'> {\n  state: 'start'\n  startClocks: ClocksState\n  isAborted: boolean\n  xhr: XMLHttpRequest\n  handlingStack?: string\n}\n\nexport interface XhrCompleteContext extends Omit<XhrStartContext, 'state'> {\n  state: 'complete'\n  duration: Duration\n  status: number\n}\n\nexport type XhrContext = XhrOpenContext | XhrStartContext | XhrCompleteContext\n\nlet xhrObservable: Observable<XhrContext> | undefined\nconst xhrContexts = new WeakMap<XMLHttpRequest, XhrContext>()\n\nexport function initXhrObservable(configuration: Configuration) {\n  if (!xhrObservable) {\n    xhrObservable = createXhrObservable(configuration)\n  }\n  return xhrObservable\n}\n\nfunction createXhrObservable(configuration: Configuration) {\n  return new Observable<XhrContext>((observable) => {\n    const { stop: stopInstrumentingStart } = instrumentMethod(XMLHttpRequest.prototype, 'open', openXhr)\n\n    const { stop: stopInstrumentingSend } = instrumentMethod(\n      XMLHttpRequest.prototype,\n      'send',\n      (call) => {\n        sendXhr(call, configuration, observable)\n      },\n      { computeHandlingStack: true }\n    )\n\n    const { stop: stopInstrumentingAbort } = instrumentMethod(XMLHttpRequest.prototype, 'abort', abortXhr)\n\n    return () => {\n      stopInstrumentingStart()\n      stopInstrumentingSend()\n      stopInstrumentingAbort()\n    }\n  })\n}\n\nfunction openXhr({ target: xhr, parameters: [method, url] }: InstrumentedMethodCall<XMLHttpRequest, 'open'>) {\n  xhrContexts.set(xhr, {\n    state: 'open',\n    method: String(method).toUpperCase(),\n    url: normalizeUrl(String(url)),\n  })\n}\n\nfunction sendXhr(\n  { target: xhr, handlingStack }: InstrumentedMethodCall<XMLHttpRequest, 'send'>,\n  configuration: Configuration,\n  observable: Observable<XhrContext>\n) {\n  const context = xhrContexts.get(xhr)\n  if (!context) {\n    return\n  }\n\n  const startContext = context as XhrStartContext\n  startContext.state = 'start'\n  startContext.startClocks = clocksNow()\n  startContext.isAborted = false\n  startContext.xhr = xhr\n  startContext.handlingStack = handlingStack\n\n  let hasBeenReported = false\n\n  const { stop: stopInstrumentingOnReadyStateChange } = instrumentMethod(xhr, 'onreadystatechange', () => {\n    if (xhr.readyState === XMLHttpRequest.DONE) {\n      // Try to report the XHR as soon as possible, because the XHR may be mutated by the\n      // application during a future event. For example, Angular is calling .abort() on\n      // completed requests during an onreadystatechange event, so the status becomes '0'\n      // before the request is collected.\n      onEnd()\n    }\n  })\n\n  const onEnd = () => {\n    unsubscribeLoadEndListener()\n    stopInstrumentingOnReadyStateChange()\n    if (hasBeenReported) {\n      return\n    }\n    hasBeenReported = true\n\n    const completeContext = context as XhrCompleteContext\n    completeContext.state = 'complete'\n    completeContext.duration = elapsed(startContext.startClocks.timeStamp, timeStampNow())\n    completeContext.status = xhr.status\n    observable.notify(shallowClone(completeContext))\n  }\n\n  const { stop: unsubscribeLoadEndListener } = addEventListener(configuration, xhr, 'loadend', onEnd)\n\n  observable.notify(startContext)\n}\n\nfunction abortXhr({ target: xhr }: InstrumentedMethodCall<XMLHttpRequest, 'abort'>) {\n  const context = xhrContexts.get(xhr) as XhrStartContext | undefined\n  if (context) {\n    context.isAborted = true\n  }\n}\n", "import type { InstrumentedMethodCall } from '../tools/instrumentMethod'\nimport { instrumentMethod } from '../tools/instrumentMethod'\nimport { monitor } from '../tools/monitor'\nimport { Observable } from '../tools/observable'\nimport type { ClocksState } from '../tools/utils/timeUtils'\nimport { clocksNow } from '../tools/utils/timeUtils'\nimport { normalizeUrl } from '../tools/utils/urlPolyfill'\n\ninterface FetchContextBase {\n  method: string\n  startClocks: ClocksState\n  input: unknown\n  init?: RequestInit\n  url: string\n  handlingStack?: string\n}\n\nexport interface FetchStartContext extends FetchContextBase {\n  state: 'start'\n}\n\nexport interface FetchResolveContext extends FetchContextBase {\n  state: 'resolve'\n  status: number\n  response?: Response\n  responseType?: string\n  isAborted: boolean\n  error?: Error\n}\n\nexport type FetchContext = FetchStartContext | FetchResolveContext\n\nlet fetchObservable: Observable<FetchContext> | undefined\n\nexport function initFetchObservable() {\n  if (!fetchObservable) {\n    fetchObservable = createFetchObservable()\n  }\n  return fetchObservable\n}\n\nexport function resetFetchObservable() {\n  fetchObservable = undefined\n}\n\nfunction createFetchObservable() {\n  return new Observable<FetchContext>((observable) => {\n    if (!window.fetch) {\n      return\n    }\n\n    const { stop } = instrumentMethod(window, 'fetch', (call) => beforeSend(call, observable), {\n      computeHandlingStack: true,\n    })\n\n    return stop\n  })\n}\n\nfunction beforeSend(\n  { parameters, onPostCall, handlingStack }: InstrumentedMethodCall<Window, 'fetch'>,\n  observable: Observable<FetchContext>\n) {\n  const [input, init] = parameters\n  let methodFromParams = init && init.method\n\n  if (methodFromParams === undefined && input instanceof Request) {\n    methodFromParams = input.method\n  }\n\n  const method = methodFromParams !== undefined ? String(methodFromParams).toUpperCase() : 'GET'\n  const url = input instanceof Request ? input.url : normalizeUrl(String(input))\n  const startClocks = clocksNow()\n\n  const context: FetchStartContext = {\n    state: 'start',\n    init,\n    input,\n    method,\n    startClocks,\n    url,\n    handlingStack,\n  }\n\n  observable.notify(context)\n\n  // Those properties can be changed by observable subscribers\n  parameters[0] = context.input as RequestInfo | URL\n  parameters[1] = context.init\n\n  onPostCall((responsePromise) => afterSend(observable, responsePromise, context))\n}\n\nfunction afterSend(\n  observable: Observable<FetchContext>,\n  responsePromise: Promise<Response>,\n  startContext: FetchStartContext\n) {\n  const context = startContext as unknown as FetchResolveContext\n\n  function reportFetch(partialContext: Partial<FetchResolveContext>) {\n    context.state = 'resolve'\n    Object.assign(context, partialContext)\n    observable.notify(context)\n  }\n\n  responsePromise.then(\n    monitor((response) => {\n      reportFetch({\n        response,\n        responseType: response.type,\n        status: response.status,\n        isAborted: false,\n      })\n    }),\n    monitor((error: Error) => {\n      reportFetch({\n        status: 0,\n        isAborted:\n          context.init?.signal?.aborted || (error instanceof DOMException && error.code === DOMException.ABORT_ERR),\n        error,\n      })\n    })\n  )\n}\n", "import { setTimeout, clearTimeout } from './timer'\nimport { monitor } from './monitor'\nimport { dateNow } from './utils/timeUtils'\n\n// This type is not yet supported in TS 3.8. Imported from the TS source until we upgrade the\n// minimum supported TS version.\n// https://github.com/microsoft/TypeScript/blob/13c374a868c926f6a907666a5599992c1351b773/src/lib/dom.generated.d.ts#L9513-L9516\nexport interface IdleDeadline {\n  readonly didTimeout: boolean\n  timeRemaining(): DOMHighResTimeStamp\n}\n\n/**\n * 'requestIdleCallback' with a shim.\n */\nexport function requestIdleCallback(callback: (deadline: IdleDeadline) => void, opts?: { timeout?: number }) {\n  // Note: check both 'requestIdleCallback' and 'cancelIdleCallback' existence because some polyfills only implement 'requestIdleCallback'.\n  if (window.requestIdleCallback && window.cancelIdleCallback) {\n    const id = window.requestIdleCallback(monitor(callback), opts)\n    return () => window.cancelIdleCallback(id)\n  }\n  return requestIdleCallbackShim(callback)\n}\n\nexport const MAX_TASK_TIME = 50\n\n/*\n * Shim from https://developer.chrome.com/blog/using-requestidlecallback#checking_for_requestidlecallback\n * Note: there is no simple way to support the \"timeout\" option, so we ignore it.\n */\nexport function requestIdleCallbackShim(callback: (deadline: IdleDeadline) => void) {\n  const start = dateNow()\n  const timeoutId = setTimeout(() => {\n    callback({\n      didTimeout: false,\n      timeRemaining: () => Math.max(0, MAX_TASK_TIME - (dateNow() - start)),\n    })\n  }, 0)\n  return () => clearTimeout(timeoutId)\n}\n", "import { ONE_SECOND } from './utils/timeUtils'\nimport { requestIdleCallback } from './requestIdleCallback'\n\n/**\n * Maximum delay before starting to execute tasks in the queue. We don't want to wait too long\n * before running tasks, as it might hurt reliability (ex: if the user navigates away, we might lose\n * the opportunity to send some data). We also don't want to run tasks too often, as it might hurt\n * performance.\n */\nconst IDLE_CALLBACK_TIMEOUT = ONE_SECOND\n\n/**\n * Maximum amount of time allocated to running tasks when a timeout (`IDLE_CALLBACK_TIMEOUT`) is\n * reached. We should not run tasks for too long as it will hurt performance, but we should still\n * run some tasks to avoid postponing them forever.\n *\n * Rational: Running tasks for 30ms every second (IDLE_CALLBACK_TIMEOUT) should be acceptable.\n */\nexport const MAX_EXECUTION_TIME_ON_TIMEOUT = 30\n\nexport interface TaskQueue {\n  push(task: Task): void\n}\n\ntype Task = () => void\n\nexport function createTaskQueue(): TaskQueue {\n  const pendingTasks: Task[] = []\n\n  function run(deadline: IdleDeadline) {\n    let executionTimeRemaining: () => number\n    if (deadline.didTimeout) {\n      const start = performance.now()\n      executionTimeRemaining = () => MAX_EXECUTION_TIME_ON_TIMEOUT - (performance.now() - start)\n    } else {\n      executionTimeRemaining = deadline.timeRemaining.bind(deadline)\n    }\n\n    while (executionTimeRemaining() > 0 && pendingTasks.length) {\n      pendingTasks.shift()!()\n    }\n\n    if (pendingTasks.length) {\n      scheduleNextRun()\n    }\n  }\n\n  function scheduleNextRun() {\n    requestIdleCallback(run, { timeout: IDLE_CALLBACK_TIMEOUT })\n  }\n\n  return {\n    push(task) {\n      if (pendingTasks.push(task) === 1) {\n        scheduleNextRun()\n      }\n    },\n  }\n}\n", "import { isError, computeRawError } from '../error/error'\nimport { mergeObservables, Observable } from '../../tools/observable'\nimport { ConsoleApiName, globalConsole } from '../../tools/display'\nimport { callMonitored } from '../../tools/monitor'\nimport { sanitize } from '../../tools/serialisation/sanitize'\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify'\nimport type { RawError } from '../error/error.types'\nimport { ErrorHandling, ErrorSource, NonErrorPrefix } from '../error/error.types'\nimport { computeStackTrace } from '../../tools/stackTrace/computeStackTrace'\nimport { createHandlingStack, formatErrorMessage } from '../../tools/stackTrace/handlingStack'\nimport { clocksNow } from '../../tools/utils/timeUtils'\n\nexport type ConsoleLog = NonErrorConsoleLog | ErrorConsoleLog\n\ninterface NonErrorConsoleLog extends ConsoleLogBase {\n  api: Exclude<ConsoleApiName, typeof ConsoleApiName.error>\n  error: undefined\n}\n\nexport interface ErrorConsoleLog extends ConsoleLogBase {\n  api: typeof ConsoleApiName.error\n  error: RawError\n}\n\ninterface ConsoleLogBase {\n  message: string\n  api: ConsoleApiName\n  handlingStack: string\n}\n\ntype ConsoleLogForApi<T extends ConsoleApiName> = T extends typeof ConsoleApiName.error\n  ? ErrorConsoleLog\n  : NonErrorConsoleLog\n\nlet consoleObservablesByApi: { [K in ConsoleApiName]?: Observable<ConsoleLogForApi<K>> } = {}\n\nexport function initConsoleObservable<T extends ConsoleApiName[]>(apis: T): Observable<ConsoleLogForApi<T[number]>> {\n  const consoleObservables = apis.map((api) => {\n    if (!consoleObservablesByApi[api]) {\n      consoleObservablesByApi[api] = createConsoleObservable(api) as any // we are sure that the observable created for this api will yield the expected ConsoleLog type\n    }\n    return consoleObservablesByApi[api] as unknown as Observable<ConsoleLogForApi<T[number]>>\n  })\n\n  return mergeObservables(...consoleObservables)\n}\n\nexport function resetConsoleObservable() {\n  consoleObservablesByApi = {}\n}\n\nfunction createConsoleObservable(api: ConsoleApiName) {\n  return new Observable<ConsoleLog>((observable) => {\n    const originalConsoleApi = globalConsole[api]\n\n    globalConsole[api] = (...params: unknown[]) => {\n      originalConsoleApi.apply(console, params)\n      const handlingStack = createHandlingStack('console error')\n\n      callMonitored(() => {\n        observable.notify(buildConsoleLog(params, api, handlingStack))\n      })\n    }\n\n    return () => {\n      globalConsole[api] = originalConsoleApi\n    }\n  })\n}\n\nfunction buildConsoleLog(params: unknown[], api: ConsoleApiName, handlingStack: string): ConsoleLog {\n  const message = params.map((param) => formatConsoleParameters(param)).join(' ')\n\n  if (api === ConsoleApiName.error) {\n    const firstErrorParam = params.find(isError)\n\n    const rawError = computeRawError({\n      originalError: firstErrorParam,\n      handlingStack,\n      startClocks: clocksNow(),\n      source: ErrorSource.CONSOLE,\n      handling: ErrorHandling.HANDLED,\n      nonErrorPrefix: NonErrorPrefix.PROVIDED,\n\n      // if no good stack is computed from the error, let's not use the fallback stack message\n      // advising the user to use an instance of Error, as console.error is commonly used without an\n      // Error instance.\n      useFallbackStack: false,\n    })\n\n    // Use the full log message as the error message instead of just the error instance message.\n    rawError.message = message\n\n    return {\n      api,\n      message,\n      handlingStack,\n      error: rawError,\n    }\n  }\n\n  return {\n    api,\n    message,\n    error: undefined,\n    handlingStack,\n  }\n}\n\nfunction formatConsoleParameters(param: unknown) {\n  if (typeof param === 'string') {\n    return sanitize(param)\n  }\n  if (isError(param)) {\n    return formatErrorMessage(computeStackTrace(param))\n  }\n  return jsonStringify(sanitize(param), undefined, 2)\n}\n", "import type { Context } from '../../tools/serialisation/context'\nimport { display } from '../../tools/display'\nimport { getType } from '../../tools/utils/typeUtils'\n\n/**\n * Simple check to ensure an object is a valid context\n */\nexport function checkContext(maybeContext: unknown): maybeContext is Context {\n  const isValid = getType(maybeContext) === 'object'\n  if (!isValid) {\n    display.error('Unsupported context:', maybeContext)\n  }\n  return isValid\n}\n", "import { deepClone } from '../../tools/mergeInto'\nimport { sanitize } from '../../tools/serialisation/sanitize'\nimport type { Context } from '../../tools/serialisation/context'\nimport { Observable } from '../../tools/observable'\nimport { display } from '../../tools/display'\nimport { checkContext } from './contextUtils'\n\nexport type ContextManager = ReturnType<typeof createContextManager>\n\nexport type PropertiesConfig = {\n  [key: string]: {\n    required?: boolean\n    type?: 'string'\n  }\n}\n\nfunction ensureProperties(context: Context, propertiesConfig: PropertiesConfig, name: string) {\n  const newContext = { ...context }\n\n  for (const [key, { required, type }] of Object.entries(propertiesConfig)) {\n    /**\n     * Ensure specified properties are strings as defined here:\n     * https://docs.datadoghq.com/logs/log_configuration/attributes_naming_convention/#user-related-attributes\n     */\n\n    if (type === 'string' && !isDefined(newContext[key])) {\n      /* eslint-disable @typescript-eslint/no-base-to-string */\n      newContext[key] = String(newContext[key])\n    }\n\n    if (required && isDefined(newContext[key])) {\n      display.warn(`The property ${key} of ${name} is required; context will not be sent to the intake.`)\n    }\n  }\n\n  return newContext\n}\n\nfunction isDefined(value: unknown) {\n  return value === undefined || value === null || value === ''\n}\n\nexport function createContextManager(\n  name: string = '',\n  {\n    propertiesConfig = {},\n  }: {\n    propertiesConfig?: PropertiesConfig\n  } = {}\n) {\n  let context: Context = {}\n  const changeObservable = new Observable<void>()\n\n  const contextManager = {\n    getContext: () => deepClone(context),\n\n    setContext: (newContext: unknown) => {\n      if (checkContext(newContext)) {\n        context = sanitize(ensureProperties(newContext, propertiesConfig, name))\n      } else {\n        contextManager.clearContext()\n      }\n      changeObservable.notify()\n    },\n\n    setContextProperty: (key: string, property: any) => {\n      context = sanitize(ensureProperties({ ...context, [key]: property }, propertiesConfig, name))\n      changeObservable.notify()\n    },\n\n    removeContextProperty: (key: string) => {\n      delete context[key]\n      ensureProperties(context, propertiesConfig, name)\n      changeObservable.notify()\n    },\n\n    clearContext: () => {\n      context = {}\n      changeObservable.notify()\n    },\n\n    changeObservable,\n  }\n  return contextManager\n}\n", "import type { RawTelemetryUsage, RawTelemetryUsageFeature } from '../telemetry'\nimport { addTelemetryUsage } from '../telemetry'\nimport { monitor } from '../../tools/monitor'\nimport type { BoundedBuffer } from '../../tools/boundedBuffer'\nimport type { ContextManager } from './contextManager'\nimport type { ContextManagerMethod, CustomerContextKey } from './contextConstants'\n\nexport function defineContextMethod<MethodName extends ContextManagerMethod, Key extends CustomerContextKey>(\n  getStrategy: () => Record<Key, ContextManager>,\n  contextName: Key,\n  methodName: MethodName,\n  usage?: RawTelemetryUsageFeature\n): ContextManager[MethodName] {\n  return monitor((...args: any[]) => {\n    if (usage) {\n      addTelemetryUsage({ feature: usage } as RawTelemetryUsage)\n    }\n    return (getStrategy()[contextName][methodName] as (...args: unknown[]) => unknown)(...args)\n  }) as ContextManager[MethodName]\n}\n\nexport function bufferContextCalls<Key extends string, StartResult extends Record<Key, ContextManager>>(\n  preStartContextManager: ContextManager,\n  name: Key,\n  bufferApiCalls: BoundedBuffer<StartResult>\n) {\n  preStartContextManager.changeObservable.subscribe(() => {\n    const context = preStartContextManager.getContext()\n    bufferApiCalls.add((startResult) => startResult[name].setContext(context))\n  })\n}\n", "import { addEventListener, DOM_EVENT } from '../../browser/addEventListener'\nimport type { Context } from '../../tools/serialisation/context'\nimport type { Configuration } from '../configuration'\nimport { combine } from '../../tools/mergeInto'\nimport { isEmptyObject } from '../../tools/utils/objectUtils'\nimport type { ContextManager } from './contextManager'\nimport type { CustomerDataType } from './contextConstants'\n\nconst CONTEXT_STORE_KEY_PREFIX = '_dd_c'\n\nconst storageListeners: Array<{ stop: () => void }> = []\n\nexport function storeContextManager(\n  configuration: Configuration,\n  contextManager: ContextManager,\n  productKey: string,\n  customerDataType: CustomerDataType\n) {\n  const storageKey = buildStorageKey(productKey, customerDataType)\n\n  storageListeners.push(\n    addEventListener(configuration, window, DOM_EVENT.STORAGE, ({ key }) => {\n      if (storageKey === key) {\n        synchronizeWithStorage()\n      }\n    })\n  )\n  contextManager.changeObservable.subscribe(dumpToStorage)\n\n  const contextFromStorage = combine(getFromStorage(), contextManager.getContext())\n  if (!isEmptyObject(contextFromStorage)) {\n    contextManager.setContext(contextFromStorage)\n  }\n\n  function synchronizeWithStorage() {\n    contextManager.setContext(getFromStorage())\n  }\n\n  function dumpToStorage() {\n    localStorage.setItem(storageKey, JSON.stringify(contextManager.getContext()))\n  }\n\n  function getFromStorage() {\n    const rawContext = localStorage.getItem(storageKey)\n    return rawContext ? (JSON.parse(rawContext) as Context) : {}\n  }\n}\n\nexport function buildStorageKey(productKey: string, customerDataType: CustomerDataType) {\n  return `${CONTEXT_STORE_KEY_PREFIX}_${productKey}_${customerDataType}`\n}\n\nexport function removeStorageListeners() {\n  storageListeners.map((listener) => listener.stop())\n}\n", "import { combine } from './mergeInto'\n\nexport const enum HookNames {\n  Assemble,\n}\n\n// This is a workaround for an issue occurring when the Browser SDK is included in a TypeScript\n// project configured with `isolatedModules: true`. Even if the const enum is declared in this\n// module, we cannot use it directly to define the EventMap interface keys (TS error: \"Cannot access\n// ambient const enums when the '--isolatedModules' flag is provided.\").\nexport declare const HookNamesAsConst: {\n  ASSEMBLE: HookNames.Assemble\n}\n\nexport type RecursivePartialExcept<T, K extends keyof T = never> = {\n  [P in keyof T]?: T[P] extends object ? RecursivePartialExcept<T[P], never> : T[P]\n} & {\n  [P in K]: T[P]\n}\n\n// Discards the event from being sent\nexport const DISCARDED = 'DISCARDED'\n// Skips from the assembly of the event\nexport const SKIPPED = 'SKIPPED'\n\nexport type DISCARDED = typeof DISCARDED\nexport type SKIPPED = typeof SKIPPED\n\nexport type AbstractHooks = ReturnType<typeof abstractHooks>\n\nexport function abstractHooks<T extends { [K in HookNames]: (...args: any[]) => any }, E>() {\n  const callbacks: { [K in HookNames]?: Array<T[K]> } = {}\n\n  return {\n    register<K extends HookNames>(hookName: K, callback: T[K]) {\n      if (!callbacks[hookName]) {\n        callbacks[hookName] = []\n      }\n      callbacks[hookName]!.push(callback)\n      return {\n        unregister: () => {\n          callbacks[hookName] = callbacks[hookName]!.filter((cb) => cb !== callback)\n        },\n      }\n    },\n    triggerHook<K extends HookNames>(hookName: K, param: Parameters<T[K]>[0]): E | DISCARDED | undefined {\n      const hookCallbacks = callbacks[hookName] || []\n      const results = []\n\n      for (const callback of hookCallbacks) {\n        const result = callback(param)\n        if (result === DISCARDED) {\n          return DISCARDED\n        }\n        if (result === SKIPPED) {\n          continue\n        }\n\n        results.push(result)\n      }\n\n      return combine(...(results as unknown as [object, object])) as E\n    },\n  }\n}\n", "import type { Configuration } from '../configuration'\nimport { CustomerDataType } from '../context/contextConstants'\nimport { storeContextManager } from '../context/storeContextManager'\nimport { HookNames, SKIPPED } from '../../tools/abstractHooks'\nimport type { AbstractHooks } from '../../tools/abstractHooks'\nimport { isEmptyObject } from '../../tools/utils/objectUtils'\nimport { createContextManager } from '../context/contextManager'\n\nexport interface Account {\n  id: string\n  name?: string | undefined\n  [key: string]: unknown\n}\n\nexport function startAccountContext(hooks: AbstractHooks, configuration: Configuration, productKey: string) {\n  const accountContextManager = buildAccountContextManager()\n\n  if (configuration.storeContextsAcrossPages) {\n    storeContextManager(configuration, accountContextManager, productKey, CustomerDataType.Account)\n  }\n\n  hooks.register(HookNames.Assemble, () => {\n    const account = accountContextManager.getContext() as Account\n\n    if (isEmptyObject(account) || !account.id) {\n      return SKIPPED\n    }\n\n    return {\n      account,\n    }\n  })\n\n  return accountContextManager\n}\n\nexport function buildAccountContextManager() {\n  return createContextManager('account', {\n    propertiesConfig: {\n      id: { type: 'string', required: true },\n      name: { type: 'string' },\n    },\n  })\n}\n", "import type { AbstractHooks } from '../../tools/abstractHooks'\nimport { CustomerDataType } from '../context/contextConstants'\nimport { storeContextManager } from '../context/storeContextManager'\nimport { HookNames } from '../../tools/abstractHooks'\nimport { createContextManager } from '../context/contextManager'\nimport type { Configuration } from '../configuration'\n\nexport function startGlobalContext(\n  hooks: AbstractHooks,\n  configuration: Configuration,\n  productKey: string,\n  useContextNamespace: boolean\n) {\n  const globalContextManager = buildGlobalContextManager()\n\n  if (configuration.storeContextsAcrossPages) {\n    storeContextManager(configuration, globalContextManager, productKey, CustomerDataType.GlobalContext)\n  }\n\n  hooks.register(HookNames.Assemble, () => {\n    const context = globalContextManager.getContext()\n    return useContextNamespace ? { context } : context\n  })\n\n  return globalContextManager\n}\n\nexport function buildGlobalContextManager() {\n  return createContextManager('global context')\n}\n", "import type { AbstractHooks } from '../../tools/abstractHooks'\nimport { CustomerDataType } from '../context/contextConstants'\nimport { storeContextManager } from '../context/storeContextManager'\nimport { HookNames, SKIPPED } from '../../tools/abstractHooks'\nimport { createContextManager } from '../context/contextManager'\nimport type { Configuration } from '../configuration'\nimport { isEmptyObject } from '../../tools/utils/objectUtils'\nimport type { RelativeTime } from '../../tools/utils/timeUtils'\n\nexport interface User {\n  id?: string | undefined\n  email?: string | undefined\n  name?: string | undefined\n  [key: string]: unknown\n}\n\nexport function startUserContext(\n  hooks: AbstractHooks,\n  configuration: Configuration,\n  sessionManager: {\n    findTrackedSession: (startTime?: RelativeTime) => { anonymousId?: string } | undefined\n  },\n  productKey: string\n) {\n  const userContextManager = buildUserContextManager()\n\n  if (configuration.storeContextsAcrossPages) {\n    storeContextManager(configuration, userContextManager, productKey, CustomerDataType.User)\n  }\n\n  hooks.register(HookNames.Assemble, ({ eventType, startTime }) => {\n    const user = userContextManager.getContext()\n    const session = sessionManager.findTrackedSession(startTime)\n\n    if (session && session.anonymousId && !user.anonymous_id && !!configuration.trackAnonymousUser) {\n      user.anonymous_id = session.anonymousId\n    }\n\n    if (isEmptyObject(user)) {\n      return SKIPPED\n    }\n\n    return {\n      type: eventType,\n      usr: user,\n    }\n  })\n\n  return userContextManager\n}\n\nexport function buildUserContextManager() {\n  return createContextManager('user', {\n    propertiesConfig: {\n      id: { type: 'string' },\n      name: { type: 'string' },\n      email: { type: 'string' },\n    },\n  })\n}\n", "export const enum CustomerDataType {\n  FeatureFlag,\n  User,\n  GlobalContext,\n  View,\n  Account,\n}\n\n// Use a const instead of const enum to avoid inlining the enum values in the bundle and save bytes\nexport const CustomerContextKey = {\n  userContext: 'userContext',\n  globalContext: 'globalContext',\n  accountContext: 'accountContext',\n} as const\n\nexport type CustomerContextKey = (typeof CustomerContextKey)[keyof typeof CustomerContextKey]\n\n// Use a const instead of const enum to avoid inlining the enum values in the bundle and save bytes\nexport const ContextManagerMethod = {\n  getContext: 'getContext',\n  setContext: 'setContext',\n  setContextProperty: 'setContextProperty',\n  removeContextProperty: 'removeContextProperty',\n  clearContext: 'clearContext',\n} as const\n\nexport type ContextManagerMethod = (typeof ContextManagerMethod)[keyof typeof ContextManagerMethod]\n", "import { monitor } from './monitor'\nimport { noop } from './utils/functionUtils'\n\ntype Options = {\n  bytesLimit: number\n  collectStreamBody?: boolean\n}\n/**\n * Read bytes from a ReadableStream until at least `limit` bytes have been read (or until the end of\n * the stream). The callback is invoked with the at most `limit` bytes, and indicates that the limit\n * has been exceeded if more bytes were available.\n */\nexport function readBytesFromStream(\n  stream: ReadableStream<Uint8Array>,\n  callback: (error?: Error, bytes?: Uint8Array, limitExceeded?: boolean) => void,\n  options: Options\n) {\n  const reader = stream.getReader()\n  const chunks: Uint8Array[] = []\n  let readBytesCount = 0\n\n  readMore()\n\n  function readMore() {\n    reader.read().then(\n      monitor((result: ReadableStreamReadResult<Uint8Array>) => {\n        if (result.done) {\n          onDone()\n          return\n        }\n\n        if (options.collectStreamBody) {\n          chunks.push(result.value)\n        }\n        readBytesCount += result.value.length\n\n        if (readBytesCount > options.bytesLimit) {\n          onDone()\n        } else {\n          readMore()\n        }\n      }),\n      monitor((error) => callback(error))\n    )\n  }\n\n  function onDone() {\n    reader.cancel().catch(\n      // we don't care if cancel fails, but we still need to catch the error to avoid reporting it\n      // as an unhandled rejection\n      noop\n    )\n\n    let bytes: Uint8Array | undefined\n    let limitExceeded: boolean | undefined\n    if (options.collectStreamBody) {\n      let completeBuffer: Uint8Array\n      if (chunks.length === 1) {\n        // optimization: if the response is small enough to fit in a single buffer (provided by the browser), just\n        // use it directly.\n        completeBuffer = chunks[0]\n      } else {\n        // else, we need to copy buffers into a larger buffer to concatenate them.\n        completeBuffer = new Uint8Array(readBytesCount)\n        let offset = 0\n        chunks.forEach((chunk) => {\n          completeBuffer.set(chunk, offset)\n          offset += chunk.length\n        })\n      }\n      bytes = completeBuffer.slice(0, options.bytesLimit)\n      limitExceeded = completeBuffer.length > options.bytesLimit\n    }\n\n    callback(undefined, bytes, limitExceeded)\n  }\n}\n", "export const ResourceType = {\n  DOCUMENT: 'document',\n  XHR: 'xhr',\n  BEACON: 'beacon',\n  FETCH: 'fetch',\n  CSS: 'css',\n  JS: 'js',\n  IMAGE: 'image',\n  FONT: 'font',\n  MEDIA: 'media',\n  OTHER: 'other',\n} as const\n\nexport type ResourceType = (typeof ResourceType)[keyof typeof ResourceType]\n\nexport const RequestType = {\n  FETCH: ResourceType.FETCH,\n  XHR: ResourceType.XHR,\n} as const\n\nexport type RequestType = (typeof RequestType)[keyof typeof RequestType]\n", "import type {\n  Duration,\n  ErrorSource,\n  ErrorHandling,\n  ResourceType,\n  ServerDuration,\n  TimeStamp,\n  RawErrorCause,\n  DefaultPrivacyLevel,\n  Csp,\n} from '@datadog/browser-core'\nimport type { PageState } from './domain/contexts/pageStateHistory'\n\nexport const RumEventType = {\n  ACTION: 'action',\n  ERROR: 'error',\n  LONG_TASK: 'long_task',\n  VIEW: 'view',\n  RESOURCE: 'resource',\n  VITAL: 'vital',\n} as const\n\nexport type RumEventType = (typeof RumEventType)[keyof typeof RumEventType]\n\nexport const RumLongTaskEntryType = {\n  LONG_TASK: 'long-task',\n  LONG_ANIMATION_FRAME: 'long-animation-frame',\n} as const\n\nexport type RumLongTaskEntryType = (typeof RumLongTaskEntryType)[keyof typeof RumLongTaskEntryType]\n\nexport interface RawRumResourceEvent {\n  date: TimeStamp\n  type: typeof RumEventType.RESOURCE\n  resource: {\n    type: ResourceType\n    id: string\n    duration?: ServerDuration\n    url: string\n    method?: string\n    status_code?: number\n    size?: number\n    encoded_body_size?: number\n    decoded_body_size?: number\n    transfer_size?: number\n    render_blocking_status?: string\n    redirect?: ResourceEntryDetailsElement\n    dns?: ResourceEntryDetailsElement\n    connect?: ResourceEntryDetailsElement\n    ssl?: ResourceEntryDetailsElement\n    worker?: ResourceEntryDetailsElement\n    first_byte?: ResourceEntryDetailsElement\n    download?: ResourceEntryDetailsElement\n    protocol?: string\n    delivery_type?: DeliveryType\n  }\n  _dd: {\n    trace_id?: string\n    span_id?: string // not available for initial document tracing\n    rule_psr?: number\n    discarded: boolean\n    page_states?: PageStateServerEntry[]\n  }\n}\n\nexport interface ResourceEntryDetailsElement {\n  duration: ServerDuration\n  start: ServerDuration\n}\n\nexport interface RawRumErrorEvent {\n  date: TimeStamp\n  type: typeof RumEventType.ERROR\n  error: {\n    id: string\n    type?: string\n    stack?: string\n    handling_stack?: string\n    component_stack?: string\n    fingerprint?: string\n    source: ErrorSource\n    message: string\n    handling?: ErrorHandling\n    causes?: RawErrorCause[]\n    source_type: 'browser'\n    csp?: Csp\n  }\n  view?: {\n    in_foreground: boolean\n  }\n}\n\nexport interface RawRumViewEvent {\n  date: TimeStamp\n  type: typeof RumEventType.VIEW\n  view: {\n    loading_type: ViewLoadingType\n    first_byte?: ServerDuration\n    first_contentful_paint?: ServerDuration\n    first_input_delay?: ServerDuration\n    first_input_time?: ServerDuration\n    first_input_target_selector?: string\n    interaction_to_next_paint?: ServerDuration\n    interaction_to_next_paint_time?: ServerDuration\n    interaction_to_next_paint_target_selector?: string\n    cumulative_layout_shift?: number\n    cumulative_layout_shift_time?: ServerDuration\n    cumulative_layout_shift_target_selector?: string\n    custom_timings?: {\n      [key: string]: ServerDuration\n    }\n    largest_contentful_paint?: ServerDuration\n    largest_contentful_paint_target_selector?: string\n    dom_interactive?: ServerDuration\n    dom_content_loaded?: ServerDuration\n    dom_complete?: ServerDuration\n    load_event?: ServerDuration\n    loading_time?: ServerDuration\n    time_spent: ServerDuration\n    is_active: boolean\n    name?: string\n    error: Count\n    action: Count\n    long_task: Count\n    resource: Count\n    frustration: Count\n    performance?: ViewPerformanceData\n  }\n  display?: ViewDisplay\n  privacy?: {\n    replay_level: DefaultPrivacyLevel\n  }\n  _dd: {\n    document_version: number\n    replay_stats?: ReplayStats\n    page_states?: PageStateServerEntry[]\n    cls?: {\n      device_pixel_ratio: number\n    }\n    configuration: {\n      start_session_replay_recording_manually: boolean\n    }\n  }\n}\n\ninterface ViewDisplay {\n  scroll: {\n    max_depth?: number\n    max_depth_scroll_top?: number\n    max_scroll_height?: number\n    max_scroll_height_time?: ServerDuration\n  }\n}\n\nexport interface ViewPerformanceData {\n  cls?: {\n    score: number\n    timestamp?: ServerDuration\n    target_selector?: string\n    previous_rect?: RumRect\n    current_rect?: RumRect\n  }\n  fcp?: {\n    timestamp: number\n  }\n  fid?: {\n    duration: ServerDuration\n    timestamp: ServerDuration\n    target_selector?: string\n  }\n  inp?: {\n    duration: ServerDuration\n    timestamp?: ServerDuration\n    target_selector?: string\n  }\n  lcp?: {\n    timestamp: ServerDuration\n    target_selector?: string\n    resource_url?: string\n  }\n}\n\nexport interface RumRect {\n  x: number\n  y: number\n  width: number\n  height: number\n}\n\nexport type PageStateServerEntry = { state: PageState; start: ServerDuration }\n\nexport const ViewLoadingType = {\n  INITIAL_LOAD: 'initial_load',\n  ROUTE_CHANGE: 'route_change',\n  BF_CACHE: 'bf_cache',\n} as const\n\nexport type ViewLoadingType = (typeof ViewLoadingType)[keyof typeof ViewLoadingType]\n\nexport interface ViewCustomTimings {\n  [key: string]: Duration\n}\n\nexport interface ReplayStats {\n  records_count: number\n  segments_count: number\n  segments_total_raw_size: number\n}\n\ninterface Count {\n  count: number\n}\n\nexport interface RawRumLongTaskEvent {\n  date: TimeStamp\n  type: typeof RumEventType.LONG_TASK\n  long_task: {\n    id: string\n    entry_type: typeof RumLongTaskEntryType.LONG_TASK\n    duration: ServerDuration\n  }\n  _dd: {\n    discarded: boolean\n  }\n}\n\nexport type DeliveryType = 'cache' | 'navigational-prefetch' | 'other'\n\nexport type InvokerType =\n  | 'user-callback'\n  | 'event-listener'\n  | 'resolve-promise'\n  | 'reject-promise'\n  | 'classic-script'\n  | 'module-script'\n\nexport interface RawRumLongAnimationFrameEvent {\n  date: TimeStamp\n  type: typeof RumEventType.LONG_TASK // LoAF are ingested as Long Task\n  long_task: {\n    id: string\n    entry_type: typeof RumLongTaskEntryType.LONG_ANIMATION_FRAME\n    duration: ServerDuration\n    blocking_duration: ServerDuration\n    first_ui_event_timestamp: ServerDuration\n    render_start: ServerDuration\n    style_and_layout_start: ServerDuration\n    start_time: ServerDuration\n    scripts: Array<{\n      duration: ServerDuration\n      pause_duration: ServerDuration\n      forced_style_and_layout_duration: ServerDuration\n      start_time: ServerDuration\n      execution_start: ServerDuration\n      source_url: string\n      source_function_name: string\n      source_char_position: number\n      invoker: string\n      invoker_type: InvokerType\n      window_attribution: string\n    }>\n  }\n  _dd: {\n    discarded: boolean\n  }\n}\n\nexport interface RawRumActionEvent {\n  date: TimeStamp\n  type: typeof RumEventType.ACTION\n  action: {\n    id: string\n    type: ActionType\n    loading_time?: ServerDuration\n    frustration?: {\n      type: FrustrationType[]\n    }\n    error?: Count\n    long_task?: Count\n    resource?: Count\n    target: {\n      name: string\n    }\n  }\n  view?: {\n    in_foreground: boolean\n  }\n  _dd?: {\n    action?: {\n      target?: {\n        selector?: string\n        width?: number\n        height?: number\n      }\n      name_source?: string\n      position?: {\n        x: number\n        y: number\n      }\n      pointer_up_delay?: Duration\n    }\n  }\n}\n\nexport const ActionType = {\n  CLICK: 'click',\n  CUSTOM: 'custom',\n} as const\n\nexport type ActionType = (typeof ActionType)[keyof typeof ActionType]\n\nexport const FrustrationType = {\n  RAGE_CLICK: 'rage_click',\n  ERROR_CLICK: 'error_click',\n  DEAD_CLICK: 'dead_click',\n} as const\n\nexport type FrustrationType = (typeof FrustrationType)[keyof typeof FrustrationType]\n\nexport interface RawRumVitalEvent {\n  date: TimeStamp\n  type: typeof RumEventType.VITAL\n  vital: {\n    id: string\n    name: string\n    type: VitalType\n    description?: string\n    duration: number\n  }\n  _dd?: {\n    vital: {\n      computed_value: true\n    }\n  }\n}\n\nexport const VitalType = {\n  DURATION: 'duration',\n} as const\n\nexport type VitalType = (typeof VitalType)[keyof typeof VitalType]\n\nexport type RawRumEvent =\n  | RawRumErrorEvent\n  | RawRumResourceEvent\n  | RawRumViewEvent\n  | RawRumLongTaskEvent\n  | RawRumLongAnimationFrameEvent\n  | RawRumActionEvent\n  | RawRumVitalEvent\n", "import type { ClocksState, Duration, Context } from '@datadog/browser-core'\nimport { clocksNow, combine, elapsed, generateUUID, toServerDuration } from '@datadog/browser-core'\nimport type { LifeCycle, RawRumEventCollectedData } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\nimport type { RawRumVitalEvent } from '../../rawRumEvent.types'\nimport { RumEventType, VitalType } from '../../rawRumEvent.types'\nimport type { PageStateHistory } from '../contexts/pageStateHistory'\nimport { PageState } from '../contexts/pageStateHistory'\n\nexport interface DurationVitalOptions {\n  context?: Context\n  description?: string\n}\n\nexport interface DurationVitalReference {\n  __dd_vital_reference: true\n}\n\nexport interface DurationVitalStart {\n  name: string\n  startClocks: ClocksState\n  context?: Context\n  description?: string\n}\n\nexport interface DurationVital {\n  name: string\n  type: typeof VitalType.DURATION\n  startClocks: ClocksState\n  duration: Duration\n  description?: string\n  context?: Context\n}\n\nexport interface CustomVitalsState {\n  vitalsByName: Map<string, DurationVitalStart>\n  vitalsByReference: WeakMap<DurationVitalReference, DurationVitalStart>\n}\n\nexport function createCustomVitalsState() {\n  const vitalsByName = new Map<string, DurationVitalStart>()\n  const vitalsByReference = new WeakMap<DurationVitalReference, DurationVitalStart>()\n  return { vitalsByName, vitalsByReference }\n}\n\nexport function startVitalCollection(\n  lifeCycle: LifeCycle,\n  pageStateHistory: PageStateHistory,\n  customVitalsState: CustomVitalsState\n) {\n  function isValid(vital: DurationVital) {\n    return !pageStateHistory.wasInPageStateDuringPeriod(PageState.FROZEN, vital.startClocks.relative, vital.duration)\n  }\n\n  function addDurationVital(vital: DurationVital) {\n    if (isValid(vital)) {\n      lifeCycle.notify(LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, processVital(vital, true))\n    }\n  }\n\n  return {\n    addDurationVital,\n    startDurationVital: (name: string, options: DurationVitalOptions = {}) =>\n      startDurationVital(customVitalsState, name, options),\n    stopDurationVital: (nameOrRef: string | DurationVitalReference, options: DurationVitalOptions = {}) => {\n      stopDurationVital(addDurationVital, customVitalsState, nameOrRef, options)\n    },\n  }\n}\n\nexport function startDurationVital(\n  { vitalsByName, vitalsByReference }: CustomVitalsState,\n  name: string,\n  options: DurationVitalOptions = {}\n) {\n  const vital = {\n    name,\n    startClocks: clocksNow(),\n    context: options.context,\n    description: options.description,\n  }\n\n  // To avoid leaking implementation details of the vital, we return a reference to it.\n  const reference: DurationVitalReference = { __dd_vital_reference: true }\n\n  vitalsByName.set(name, vital)\n\n  // To avoid memory leaks caused by the creation of numerous references (e.g., from improper useEffect implementations), we use a WeakMap.\n  vitalsByReference.set(reference, vital)\n\n  return reference\n}\n\nexport function stopDurationVital(\n  stopCallback: (vital: DurationVital) => void,\n  { vitalsByName, vitalsByReference }: CustomVitalsState,\n  nameOrRef: string | DurationVitalReference,\n  options: DurationVitalOptions = {}\n) {\n  const vitalStart = typeof nameOrRef === 'string' ? vitalsByName.get(nameOrRef) : vitalsByReference.get(nameOrRef)\n\n  if (!vitalStart) {\n    return\n  }\n\n  stopCallback(buildDurationVital(vitalStart, vitalStart.startClocks, options, clocksNow()))\n\n  if (typeof nameOrRef === 'string') {\n    vitalsByName.delete(nameOrRef)\n  } else {\n    vitalsByReference.delete(nameOrRef)\n  }\n}\n\nfunction buildDurationVital(\n  vitalStart: DurationVitalStart,\n  startClocks: ClocksState,\n  stopOptions: DurationVitalOptions,\n  stopClocks: ClocksState\n): DurationVital {\n  return {\n    name: vitalStart.name,\n    type: VitalType.DURATION,\n    startClocks,\n    duration: elapsed(startClocks.timeStamp, stopClocks.timeStamp),\n    context: combine(vitalStart.context, stopOptions.context),\n    description: stopOptions.description ?? vitalStart.description,\n  }\n}\n\nfunction processVital(vital: DurationVital, valueComputedBySdk: boolean): RawRumEventCollectedData<RawRumVitalEvent> {\n  const rawRumEvent: RawRumVitalEvent = {\n    date: vital.startClocks.timeStamp,\n    vital: {\n      id: generateUUID(),\n      type: vital.type,\n      name: vital.name,\n      duration: toServerDuration(vital.duration),\n      description: vital.description,\n    },\n    type: RumEventType.VITAL,\n  }\n\n  if (valueComputedBySdk) {\n    rawRumEvent._dd = {\n      vital: {\n        computed_value: true,\n      },\n    }\n  }\n\n  return {\n    rawRumEvent,\n    startTime: vital.startClocks.relative,\n    duration: vital.duration,\n    customerContext: vital.context,\n    domainContext: {},\n  }\n}\n", "import type { RumPublicApi, Strategy } from '../boot/rumPublicApi'\nimport type { StartRumResult } from '../boot/startRum'\nimport type { RumInitConfiguration } from './configuration'\n\ntype OnRumStartOptions = {\n  /**\n   * @deprecated Use `addEvent` instead.\n   */\n  strategy?: Strategy\n  addEvent?: StartRumResult['addEvent']\n}\n\nexport interface RumPlugin {\n  name: string\n  getConfigurationTelemetry?(): Record<string, unknown>\n  onInit?(options: { initConfiguration: RumInitConfiguration; publicApi: RumPublicApi }): void\n  onRumStart?(options: OnRumStartOptions): void\n}\n\ntype MethodNames = 'onInit' | 'onRumStart'\ntype MethodParameter<MethodName extends MethodNames> = Parameters<NonNullable<RumPlugin[MethodName]>>[0]\n\nexport function callPluginsMethod<MethodName extends MethodNames>(\n  plugins: RumPlugin[] | undefined,\n  methodName: MethodName,\n  parameter: MethodParameter<MethodName>\n): void\nexport function callPluginsMethod<MethodName extends MethodNames>(\n  plugins: RumPlugin[] | undefined,\n  methodName: MethodName,\n  parameter: any\n) {\n  if (!plugins) {\n    return\n  }\n  for (const plugin of plugins) {\n    const method = plugin[methodName]\n    if (method) {\n      method(parameter)\n    }\n  }\n}\n", "import { performDraw } from '@datadog/browser-core'\n\nconst sampleDecisionCache: Map<number, { sessionId: string; decision: boolean }> = new Map()\n\nexport function isSampled(sessionId: string, sampleRate: number) {\n  // Shortcuts for common cases. This is not strictly necessary, but it makes the code faster for\n  // customers willing to ingest all traces.\n  if (sampleRate === 100) {\n    return true\n  }\n\n  if (sampleRate === 0) {\n    return false\n  }\n\n  const cachedDecision = sampleDecisionCache.get(sampleRate)\n  if (cachedDecision && sessionId === cachedDecision.sessionId) {\n    return cachedDecision.decision\n  }\n\n  let decision: boolean\n  // @ts-expect-error BigInt might not be defined in every browser we support\n  if (window.BigInt) {\n    decision = sampleUsingKnuthFactor(BigInt(`0x${sessionId.split('-')[4]}`), sampleRate)\n  } else {\n    // For simplicity, we don't use consistent sampling for browser without BigInt support\n    // TODO: remove this when all browser we support have BigInt support\n    decision = performDraw(sampleRate)\n  }\n  sampleDecisionCache.set(sampleRate, { sessionId, decision })\n  return decision\n}\n\n// Exported for tests\nexport function resetSampleDecisionCache() {\n  sampleDecisionCache.clear()\n}\n\n/**\n * Perform sampling using the Knuth factor method. This method offer consistent sampling result\n * based on the provided identifier.\n *\n * @param identifier The identifier to use for sampling.\n * @param sampleRate The sample rate in percentage between 0 and 100.\n */\nexport function sampleUsingKnuthFactor(identifier: bigint, sampleRate: number) {\n  // The formula is:\n  //\n  //   (identifier * knuthFactor) % 2^64 < sampleRate * 2^64\n  //\n  // Because JavaScript numbers are 64-bit floats, we can't represent 64-bit integers, and the\n  // modulo would be incorrect. Thus, we are using BigInts here.\n  //\n  // Implementation in other languages:\n  // * Go     https://github.com/DataDog/dd-trace-go/blob/ec6fbb1f2d517b7b8e69961052adf7136f3af773/ddtrace/tracer/sampler.go#L86-L91\n  // * Python https://github.com/DataDog/dd-trace-py/blob/0cee2f066fb6e79aa15947c1514c0f406dea47c5/ddtrace/sampling_rule.py#L197\n  // * Ruby   https://github.com/DataDog/dd-trace-rb/blob/1a6e255cdcb7e7e22235ea5955f90f6dfa91045d/lib/datadog/tracing/sampling/rate_sampler.rb#L42\n  // * C++    https://github.com/DataDog/dd-trace-cpp/blob/159629edc438ae45f2bb318eb7bd51abd05e94b5/src/datadog/trace_sampler.cpp#L58\n  // * Java   https://github.com/DataDog/dd-trace-java/blob/896dd6b380533216e0bdee59614606c8272d313e/dd-trace-core/src/main/java/datadog/trace/common/sampling/DeterministicSampler.java#L48\n  //\n  // Note: All implementations have slight variations. Some of them use '<=' instead of '<', and\n  // use `sampleRate * 2^64 - 1` instead of `sampleRate * 2^64`. The following implementation\n  // should adhere to the spec and is a bit simpler than using a 2^64-1 limit as there are less\n  // BigInt arithmetic to write. In practice this does not matter, as we are using floating point\n  // numbers in the end, and Number(2n**64n-1n) === Number(2n**64n).\n  const knuthFactor = BigInt('1111111111111111111')\n  const twoPow64 = BigInt('0x10000000000000000') // 2n ** 64n\n  const hash = (identifier * knuthFactor) % twoPow64\n  return Number(hash) <= (sampleRate / 100) * Number(twoPow64)\n}\n", "interface BaseIdentifier {\n  toString(radix?: number): string\n}\n\nexport interface TraceIdentifier extends BaseIdentifier {\n  // We use a brand to distinguish between TraceIdentifier and SpanIdentifier, else TypeScript\n  // considers them as the same type\n  __brand: 'traceIdentifier'\n}\n\nexport interface SpanIdentifier extends BaseIdentifier {\n  __brand: 'spanIdentifier'\n}\n\nexport function createTraceIdentifier() {\n  return createIdentifier(64) as TraceIdentifier\n}\n\nexport function createSpanIdentifier() {\n  return createIdentifier(63) as SpanIdentifier\n}\n\nfunction createIdentifier(bits: 63 | 64): BaseIdentifier {\n  const buffer = crypto.getRandomValues(new Uint32Array(2))\n  if (bits === 63) {\n    // eslint-disable-next-line no-bitwise\n    buffer[buffer.length - 1] >>>= 1 // force 63-bit\n  }\n\n  // The `.toString` function is intentionally similar to Number and BigInt `.toString` method.\n  //\n  // JavaScript numbers can represent integers up to 48 bits, this is why we need two of them to\n  // represent a 64 bits identifier. But BigInts don't have this limitation and can represent larger\n  // integer values.\n  //\n  // In the future, when we drop browsers without BigInts support, we could use BigInts directly\n  // represent identifiers by simply returning a BigInt from this function (as all we need is a\n  // value with a `.toString` method).\n  //\n  // Examples:\n  //   const buffer = getCrypto().getRandomValues(new Uint32Array(2))\n  //   return BigInt(buffer[0]) + BigInt(buffer[1]) << 32n\n  //\n  //   // Alternative with BigUint64Array (different Browser support than plain bigints!):\n  //   return crypto.getRandomValues(new BigUint64Array(1))[0]\n  //\n  // For now, let's keep using two plain numbers as having two different implementations (one for\n  // browsers with BigInt support and one for older browsers) don't bring much value.\n  return {\n    toString(radix = 10) {\n      let high = buffer[1]\n      let low = buffer[0]\n      let str = ''\n\n      do {\n        const mod = (high % radix) * 4294967296 + low\n        high = Math.floor(high / radix)\n        low = Math.floor(mod / radix)\n        str = (mod % radix).toString(radix) + str\n      } while (high || low)\n\n      return str\n    },\n  }\n}\n\nexport function toPaddedHexadecimalString(id: BaseIdentifier) {\n  return id.toString(16).padStart(16, '0')\n}\n", "import type { ContextManager } from '@datadog/browser-core'\nimport {\n  objectEntries,\n  shallowClone,\n  getType,\n  isMatchOption,\n  matchList,\n  TraceContextInjection,\n} from '@datadog/browser-core'\nimport type { RumConfiguration } from '../configuration'\nimport type {\n  RumFetchResolveContext,\n  RumFetchStartContext,\n  RumXhrCompleteContext,\n  RumXhrStartContext,\n} from '../requestCollection'\nimport type { RumSessionManager } from '../rumSessionManager'\nimport { isSampled } from '../sampler/sampler'\nimport type { PropagatorType, TracingOption } from './tracer.types'\nimport type { SpanIdentifier, TraceIdentifier } from './identifier'\nimport { createSpanIdentifier, createTraceIdentifier, toPaddedHexadecimalString } from './identifier'\n\nexport interface Tracer {\n  traceFetch: (context: Partial<RumFetchStartContext>) => void\n  traceXhr: (context: Partial<RumXhrStartContext>, xhr: XMLHttpRequest) => void\n  clearTracingIfNeeded: (context: RumFetchResolveContext | RumXhrCompleteContext) => void\n}\n\ninterface TracingHeaders {\n  [key: string]: string\n}\n\nexport function isTracingOption(item: unknown): item is TracingOption {\n  const expectedItem = item as TracingOption\n  return (\n    getType(expectedItem) === 'object' &&\n    isMatchOption(expectedItem.match) &&\n    Array.isArray(expectedItem.propagatorTypes)\n  )\n}\n\n/**\n * Clear tracing information to avoid incomplete traces. Ideally, we should do it when the\n * request did not reach the server, but the browser does not expose this. So, we clear tracing\n * information if the request ended with status 0 without being aborted by the application.\n *\n * Reasoning:\n *\n * * Applications are usually aborting requests after a bit of time, for example when the user is\n * typing (autocompletion) or navigating away (in a SPA). With a performant device and good\n * network conditions, the request is likely to reach the server before being canceled.\n *\n * * Requests aborted otherwise (ex: lack of internet, CORS issue, blocked by a privacy extension)\n * are likely to finish quickly and without reaching the server.\n *\n * Of course, it might not be the case every time, but it should limit having incomplete traces a\n * bit.\n * */\nexport function clearTracingIfNeeded(context: RumFetchResolveContext | RumXhrCompleteContext) {\n  if (context.status === 0 && !context.isAborted) {\n    context.traceId = undefined\n    context.spanId = undefined\n    context.traceSampled = undefined\n  }\n}\n\nexport function startTracer(\n  configuration: RumConfiguration,\n  sessionManager: RumSessionManager,\n  userContext: ContextManager,\n  accountContext: ContextManager\n): Tracer {\n  return {\n    clearTracingIfNeeded,\n    traceFetch: (context) =>\n      injectHeadersIfTracingAllowed(\n        configuration,\n        context,\n        sessionManager,\n        userContext,\n        accountContext,\n        (tracingHeaders: TracingHeaders) => {\n          if (context.input instanceof Request && !context.init?.headers) {\n            context.input = new Request(context.input)\n            Object.keys(tracingHeaders).forEach((key) => {\n              ;(context.input as Request).headers.append(key, tracingHeaders[key])\n            })\n          } else {\n            context.init = shallowClone(context.init)\n            const headers: Array<[string, string]> = []\n            if (context.init.headers instanceof Headers) {\n              context.init.headers.forEach((value, key) => {\n                headers.push([key, value])\n              })\n            } else if (Array.isArray(context.init.headers)) {\n              context.init.headers.forEach((header) => {\n                headers.push(header)\n              })\n            } else if (context.init.headers) {\n              Object.keys(context.init.headers).forEach((key) => {\n                headers.push([key, (context.init!.headers as Record<string, string>)[key]])\n              })\n            }\n            context.init.headers = headers.concat(objectEntries(tracingHeaders))\n          }\n        }\n      ),\n    traceXhr: (context, xhr) =>\n      injectHeadersIfTracingAllowed(\n        configuration,\n        context,\n        sessionManager,\n        userContext,\n        accountContext,\n        (tracingHeaders: TracingHeaders) => {\n          Object.keys(tracingHeaders).forEach((name) => {\n            xhr.setRequestHeader(name, tracingHeaders[name])\n          })\n        }\n      ),\n  }\n}\n\nfunction injectHeadersIfTracingAllowed(\n  configuration: RumConfiguration,\n  context: Partial<RumFetchStartContext | RumXhrStartContext>,\n  sessionManager: RumSessionManager,\n  userContext: ContextManager,\n  accountContext: ContextManager,\n  inject: (tracingHeaders: TracingHeaders) => void\n) {\n  const session = sessionManager.findTrackedSession()\n  if (!session) {\n    return\n  }\n\n  const tracingOption = configuration.allowedTracingUrls.find((tracingOption) =>\n    matchList([tracingOption.match], context.url!, true)\n  )\n  if (!tracingOption) {\n    return\n  }\n\n  const traceSampled = isSampled(session.id, configuration.traceSampleRate)\n\n  const shouldInjectHeaders = traceSampled || configuration.traceContextInjection === TraceContextInjection.ALL\n  if (!shouldInjectHeaders) {\n    return\n  }\n\n  context.traceSampled = traceSampled\n  context.traceId = createTraceIdentifier()\n  context.spanId = createSpanIdentifier()\n\n  inject(\n    makeTracingHeaders(\n      context.traceId,\n      context.spanId,\n      context.traceSampled,\n      session.id,\n      tracingOption.propagatorTypes,\n      userContext,\n      accountContext,\n      configuration\n    )\n  )\n}\n\n/**\n * When trace is not sampled, set priority to '0' instead of not adding the tracing headers\n * to prepare the implementation for sampling delegation.\n */\nfunction makeTracingHeaders(\n  traceId: TraceIdentifier,\n  spanId: SpanIdentifier,\n  traceSampled: boolean,\n  sessionId: string,\n  propagatorTypes: PropagatorType[],\n  userContext: ContextManager,\n  accountContext: ContextManager,\n  configuration: RumConfiguration\n): TracingHeaders {\n  const tracingHeaders: TracingHeaders = {}\n\n  propagatorTypes.forEach((propagatorType) => {\n    switch (propagatorType) {\n      case 'datadog': {\n        Object.assign(tracingHeaders, {\n          'x-datadog-origin': 'rum',\n          'x-datadog-parent-id': spanId.toString(),\n          'x-datadog-sampling-priority': traceSampled ? '1' : '0',\n          'x-datadog-trace-id': traceId.toString(),\n        })\n        break\n      }\n      // https://www.w3.org/TR/trace-context/\n      case 'tracecontext': {\n        Object.assign(tracingHeaders, {\n          traceparent: `00-0000000000000000${toPaddedHexadecimalString(traceId)}-${toPaddedHexadecimalString(spanId)}-0${\n            traceSampled ? '1' : '0'\n          }`,\n          tracestate: `dd=s:${traceSampled ? '1' : '0'};o:rum`,\n        })\n        break\n      }\n      // https://github.com/openzipkin/b3-propagation\n      case 'b3': {\n        Object.assign(tracingHeaders, {\n          b3: `${toPaddedHexadecimalString(traceId)}-${toPaddedHexadecimalString(spanId)}-${traceSampled ? '1' : '0'}`,\n        })\n        break\n      }\n      case 'b3multi': {\n        Object.assign(tracingHeaders, {\n          'X-B3-TraceId': toPaddedHexadecimalString(traceId),\n          'X-B3-SpanId': toPaddedHexadecimalString(spanId),\n          'X-B3-Sampled': traceSampled ? '1' : '0',\n        })\n        break\n      }\n    }\n  })\n\n  if (configuration.propagateTraceBaggage) {\n    const baggageItems: Record<string, string> = {\n      'session.id': sessionId,\n    }\n\n    const userId = userContext.getContext().id\n    if (typeof userId === 'string') {\n      baggageItems['user.id'] = userId\n    }\n\n    const accountId = accountContext.getContext().id\n    if (typeof accountId === 'string') {\n      baggageItems['account.id'] = accountId\n    }\n\n    const baggageHeader = Object.entries(baggageItems)\n      .map(([key, value]) => `${key}=${encodeURIComponent(value)}`)\n      .join(',')\n    if (baggageHeader) {\n      tracingHeaders['baggage'] = baggageHeader\n    }\n  }\n\n  return tracingHeaders\n}\n", "import type { Configuration, InitConfiguration, MatchOption, RawTelemetryConfiguration } from '@datadog/browser-core'\nimport {\n  getType,\n  isMatchOption,\n  serializeConfiguration,\n  DefaultPrivacyLevel,\n  TraceContextInjection,\n  display,\n  objectHasValue,\n  validateAndBuildConfiguration,\n  isSampleRate,\n  isNumber,\n} from '@datadog/browser-core'\nimport type { RumEventDomainContext } from '../../domainContext.types'\nimport type { RumEvent } from '../../rumEvent.types'\nimport type { RumPlugin } from '../plugins'\nimport { isTracingOption } from '../tracing/tracer'\nimport type { PropagatorType, TracingOption } from '../tracing/tracer.types'\n\nexport const DEFAULT_PROPAGATOR_TYPES: PropagatorType[] = ['tracecontext', 'datadog']\n\nexport interface RumInitConfiguration extends InitConfiguration {\n  // global options\n  /**\n   * The RUM application ID.\n   */\n  applicationId: string\n  /**\n   * Whether to propagate user and account IDs in the baggage header of trace requests.\n   * @default false\n   */\n  propagateTraceBaggage?: boolean | undefined\n  /**\n   * Access to every event collected by the RUM SDK before they are sent to Datadog.\n   * It allows:\n   * - Enrich your RUM events with additional context attributes\n   * - Modify your RUM events to modify their content, or redact sensitive sequences (see the list of editable properties)\n   * - Discard selected RUM events\n   *\n   * See [Enrich And Control Browser RUM Data With beforeSend](https://docs.datadoghq.com/real_user_monitoring/guide/enrich-and-control-rum-data) for further information.\n   */\n  beforeSend?: ((event: RumEvent, context: RumEventDomainContext) => boolean) | undefined\n  /**\n   * A list of request origins ignored when computing the page activity.\n   * See [How page activity is calculated](https://docs.datadoghq.com/real_user_monitoring/browser/monitoring_page_performance/#how-page-activity-is-calculated) for further information.\n   */\n  excludedActivityUrls?: MatchOption[] | undefined\n  /**\n   * URL pointing to the Datadog Browser SDK Worker JavaScript file. The URL can be relative or absolute, but is required to have the same origin as the web application.\n   * See [Content Security Policy guidelines](https://docs.datadoghq.com/integrations/content_security_policy_logs/?tab=firefox#use-csp-with-real-user-monitoring-and-session-replay) for further information.\n   */\n  workerUrl?: string\n  /**\n   * Compress requests sent to the Datadog intake to reduce bandwidth usage when sending large amounts of data. The compression is done in a Worker thread.\n   * See [Content Security Policy guidelines](https://docs.datadoghq.com/integrations/content_security_policy_logs/?tab=firefox#use-csp-with-real-user-monitoring-and-session-replay) for further information.\n   */\n  compressIntakeRequests?: boolean | undefined\n  remoteConfigurationId?: string | undefined\n\n  // tracing options\n  /**\n   * A list of request URLs used to inject tracing headers.\n   * See [Connect RUM and Traces](https://docs.datadoghq.com/real_user_monitoring/platform/connect_rum_and_traces/?tab=browserrum) for further information.\n   */\n  allowedTracingUrls?: Array<MatchOption | TracingOption> | undefined\n\n  /**\n   * The percentage of requests to trace: 100 for all, 0 for none.\n   * See [Connect RUM and Traces](https://docs.datadoghq.com/real_user_monitoring/platform/connect_rum_and_traces/?tab=browserrum) for further information.\n   */\n  traceSampleRate?: number | undefined\n  /**\n   * If you set a `traceSampleRate`, to ensure backend services' sampling decisions are still applied, configure the `traceContextInjection` initialization parameter to sampled.\n   * @default sampled\n   * See [Connect RUM and Traces](https://docs.datadoghq.com/real_user_monitoring/platform/connect_rum_and_traces/?tab=browserrum) for further information.\n   */\n  traceContextInjection?: TraceContextInjection | undefined\n\n  // replay options\n  /**\n   * Allow to protect end user privacy and prevent sensitive organizational information from being collected.\n   * @default mask\n   * See [Replay Privacy Options](https://docs.datadoghq.com/real_user_monitoring/session_replay/browser/privacy_options) for further information.\n   */\n  defaultPrivacyLevel?: DefaultPrivacyLevel | undefined\n  /**\n   * If you are accessing Datadog through a custom subdomain, you can set `subdomain` to include your custom domain in the `getSessionReplayLink()` returned URL .\n   * See [Connect Session Replay To Your Third-Party Tools](https://docs.datadoghq.com/real_user_monitoring/guide/connect-session-replay-to-your-third-party-tools) for further information.\n   */\n  subdomain?: string\n  /**\n   * The percentage of tracked sessions with [Browser RUM & Session Replay pricing](https://www.datadoghq.com/pricing/?product=real-user-monitoring--session-replay#real-user-monitoring--session-replay) features: 100 for all, 0 for none.\n   * See [Configure Your Setup For Browser RUM and Browser RUM & Session Replay Sampling](https://docs.datadoghq.com/real_user_monitoring/guide/sampling-browser-plans) for further information.\n   */\n  sessionReplaySampleRate?: number | undefined\n  /**\n   * If the session is sampled for Session Replay, only start the recording when `startSessionReplayRecording()` is called, instead of at the beginning of the session. Default: if startSessionReplayRecording is 0, true; otherwise, false.\n   * See [Session Replay Usage](https://docs.datadoghq.com/real_user_monitoring/session_replay/browser/#usage) for further information.\n   */\n  startSessionReplayRecordingManually?: boolean | undefined\n\n  /**\n   * Enables privacy control for action names.\n   */\n  enablePrivacyForActionName?: boolean | undefined // TODO next major: remove this option and make privacy for action name the default behavior\n  /**\n   * Enables automatic collection of users actions.\n   * See [Tracking User Actions](https://docs.datadoghq.com/real_user_monitoring/browser/tracking_user_actions) for further information.\n   * @default true\n   */\n  trackUserInteractions?: boolean | undefined\n  /**\n   * Specify your own attribute to use to name actions.\n   * See [Declare a name for click actions](https://docs.datadoghq.com/real_user_monitoring/browser/tracking_user_actions/#declare-a-name-for-click-actions) for further information.\n   */\n  actionNameAttribute?: string | undefined\n\n  // view options\n  /**\n   * Allows you to control RUM views creation. See [Override default RUM view names](https://docs.datadoghq.com/real_user_monitoring/browser/advanced_configuration/?tab=npm#override-default-rum-view-names) for further information.\n   */\n  trackViewsManually?: boolean | undefined\n  /**\n   * Enable the creation of dedicated views for pages restored from the Back-Forward cache.\n   * @default false\n   */\n  trackBfcacheViews?: boolean | undefined\n  /**\n   * Enables collection of resource events.\n   * @default true\n   */\n  trackResources?: boolean | undefined\n  /**\n   * Enables collection of long task events.\n   * @default true\n   */\n  trackLongTasks?: boolean | undefined\n\n  /**\n   * List of plugins to enable. The plugins API is unstable and experimental, and may change without\n   * notice. Please use only plugins provided by Datadog matching the version of the SDK you are\n   * using.\n   */\n  plugins?: RumPlugin[] | undefined\n\n  /**\n   * Enables collection of features flags in chosen events.\n   */\n  trackFeatureFlagsForEvents?: FeatureFlagsForEvents[]\n\n  /**\n   * @experimental Not ready for production.\n   * The percentage of users profiled. A value between 0 and 100.\n   * @default 0\n   */\n  profilingSampleRate?: number | undefined\n}\n\nexport type HybridInitConfiguration = Omit<RumInitConfiguration, 'applicationId' | 'clientToken'>\n\nexport type FeatureFlagsForEvents = 'vital' | 'action' | 'long_task' | 'resource'\n\nexport interface RumConfiguration extends Configuration {\n  // Built from init configuration\n  actionNameAttribute: string | undefined\n  traceSampleRate: number\n  rulePsr: number | undefined\n  allowedTracingUrls: TracingOption[]\n  excludedActivityUrls: MatchOption[]\n  workerUrl: string | undefined\n  compressIntakeRequests: boolean\n  applicationId: string\n  defaultPrivacyLevel: DefaultPrivacyLevel\n  enablePrivacyForActionName: boolean\n  sessionReplaySampleRate: number\n  startSessionReplayRecordingManually: boolean\n  trackUserInteractions: boolean\n  trackViewsManually: boolean\n  trackResources: boolean\n  trackLongTasks: boolean\n  trackBfcacheViews: boolean\n  version?: string\n  subdomain?: string\n  customerDataTelemetrySampleRate: number\n  traceContextInjection: TraceContextInjection\n  plugins: RumPlugin[]\n  trackFeatureFlagsForEvents: FeatureFlagsForEvents[]\n  profilingSampleRate: number\n  propagateTraceBaggage: boolean\n}\n\nexport function validateAndBuildRumConfiguration(\n  initConfiguration: RumInitConfiguration\n): RumConfiguration | undefined {\n  if (\n    initConfiguration.trackFeatureFlagsForEvents !== undefined &&\n    !Array.isArray(initConfiguration.trackFeatureFlagsForEvents)\n  ) {\n    display.warn('trackFeatureFlagsForEvents should be an array')\n  }\n\n  if (!initConfiguration.applicationId) {\n    display.error('Application ID is not configured, no RUM data will be collected.')\n    return\n  }\n\n  if (\n    !isSampleRate(initConfiguration.sessionReplaySampleRate, 'Session Replay') ||\n    !isSampleRate(initConfiguration.traceSampleRate, 'Trace')\n  ) {\n    return\n  }\n\n  if (initConfiguration.excludedActivityUrls !== undefined && !Array.isArray(initConfiguration.excludedActivityUrls)) {\n    display.error('Excluded Activity Urls should be an array')\n    return\n  }\n\n  const allowedTracingUrls = validateAndBuildTracingOptions(initConfiguration)\n  if (!allowedTracingUrls) {\n    return\n  }\n\n  const baseConfiguration = validateAndBuildConfiguration(initConfiguration)\n  if (!baseConfiguration) {\n    return\n  }\n\n  const sessionReplaySampleRate = initConfiguration.sessionReplaySampleRate ?? 0\n\n  return {\n    applicationId: initConfiguration.applicationId,\n    version: initConfiguration.version || undefined,\n    actionNameAttribute: initConfiguration.actionNameAttribute,\n    sessionReplaySampleRate,\n    startSessionReplayRecordingManually:\n      initConfiguration.startSessionReplayRecordingManually !== undefined\n        ? !!initConfiguration.startSessionReplayRecordingManually\n        : sessionReplaySampleRate === 0,\n    traceSampleRate: initConfiguration.traceSampleRate ?? 100,\n    rulePsr: isNumber(initConfiguration.traceSampleRate) ? initConfiguration.traceSampleRate / 100 : undefined,\n    allowedTracingUrls,\n    excludedActivityUrls: initConfiguration.excludedActivityUrls ?? [],\n    workerUrl: initConfiguration.workerUrl,\n    compressIntakeRequests: !!initConfiguration.compressIntakeRequests,\n    trackUserInteractions: !!(initConfiguration.trackUserInteractions ?? true),\n    trackViewsManually: !!initConfiguration.trackViewsManually,\n    trackResources: !!(initConfiguration.trackResources ?? true),\n    trackLongTasks: !!(initConfiguration.trackLongTasks ?? true),\n    trackBfcacheViews: !!initConfiguration.trackBfcacheViews,\n    subdomain: initConfiguration.subdomain,\n    defaultPrivacyLevel: objectHasValue(DefaultPrivacyLevel, initConfiguration.defaultPrivacyLevel)\n      ? initConfiguration.defaultPrivacyLevel\n      : DefaultPrivacyLevel.MASK,\n    enablePrivacyForActionName: !!initConfiguration.enablePrivacyForActionName,\n    customerDataTelemetrySampleRate: 1,\n    traceContextInjection: objectHasValue(TraceContextInjection, initConfiguration.traceContextInjection)\n      ? initConfiguration.traceContextInjection\n      : TraceContextInjection.SAMPLED,\n    plugins: initConfiguration.plugins || [],\n    trackFeatureFlagsForEvents: initConfiguration.trackFeatureFlagsForEvents || [],\n    profilingSampleRate: initConfiguration.profilingSampleRate ?? 0,\n    propagateTraceBaggage: !!initConfiguration.propagateTraceBaggage,\n    ...baseConfiguration,\n  }\n}\n\n/**\n * Validates allowedTracingUrls and converts match options to tracing options\n */\nfunction validateAndBuildTracingOptions(initConfiguration: RumInitConfiguration): TracingOption[] | undefined {\n  if (initConfiguration.allowedTracingUrls === undefined) {\n    return []\n  }\n  if (!Array.isArray(initConfiguration.allowedTracingUrls)) {\n    display.error('Allowed Tracing URLs should be an array')\n    return\n  }\n  if (initConfiguration.allowedTracingUrls.length !== 0 && initConfiguration.service === undefined) {\n    display.error('Service needs to be configured when tracing is enabled')\n    return\n  }\n  // Convert from (MatchOption | TracingOption) to TracingOption, remove unknown properties\n  const tracingOptions: TracingOption[] = []\n  initConfiguration.allowedTracingUrls.forEach((option) => {\n    if (isMatchOption(option)) {\n      tracingOptions.push({ match: option, propagatorTypes: DEFAULT_PROPAGATOR_TYPES })\n    } else if (isTracingOption(option)) {\n      tracingOptions.push(option)\n    } else {\n      display.warn(\n        'Allowed Tracing Urls parameters should be a string, RegExp, function, or an object. Ignoring parameter',\n        option\n      )\n    }\n  })\n\n  return tracingOptions\n}\n\n/**\n * Combines the selected tracing propagators from the different options in allowedTracingUrls\n */\nfunction getSelectedTracingPropagators(configuration: RumInitConfiguration): PropagatorType[] {\n  const usedTracingPropagators = new Set<PropagatorType>()\n\n  if (Array.isArray(configuration.allowedTracingUrls) && configuration.allowedTracingUrls.length > 0) {\n    configuration.allowedTracingUrls.forEach((option) => {\n      if (isMatchOption(option)) {\n        DEFAULT_PROPAGATOR_TYPES.forEach((propagatorType) => usedTracingPropagators.add(propagatorType))\n      } else if (getType(option) === 'object' && Array.isArray(option.propagatorTypes)) {\n        // Ensure we have an array, as we cannot rely on types yet (configuration is provided by users)\n        option.propagatorTypes.forEach((propagatorType) => usedTracingPropagators.add(propagatorType))\n      }\n    })\n  }\n\n  return Array.from(usedTracingPropagators)\n}\n\nexport function serializeRumConfiguration(configuration: RumInitConfiguration) {\n  const baseSerializedConfiguration = serializeConfiguration(configuration)\n\n  return {\n    session_replay_sample_rate: configuration.sessionReplaySampleRate,\n    start_session_replay_recording_manually: configuration.startSessionReplayRecordingManually,\n    trace_sample_rate: configuration.traceSampleRate,\n    trace_context_injection: configuration.traceContextInjection,\n    action_name_attribute: configuration.actionNameAttribute,\n    use_allowed_tracing_urls:\n      Array.isArray(configuration.allowedTracingUrls) && configuration.allowedTracingUrls.length > 0,\n    selected_tracing_propagators: getSelectedTracingPropagators(configuration),\n    default_privacy_level: configuration.defaultPrivacyLevel,\n    enable_privacy_for_action_name: configuration.enablePrivacyForActionName,\n    use_excluded_activity_urls:\n      Array.isArray(configuration.excludedActivityUrls) && configuration.excludedActivityUrls.length > 0,\n    use_worker_url: !!configuration.workerUrl,\n    compress_intake_requests: configuration.compressIntakeRequests,\n    track_views_manually: configuration.trackViewsManually,\n    track_user_interactions: configuration.trackUserInteractions,\n    track_resources: configuration.trackResources,\n    track_long_task: configuration.trackLongTasks,\n    track_bfcache_views: configuration.trackBfcacheViews,\n    plugins: configuration.plugins?.map((plugin) => ({\n      name: plugin.name,\n      ...plugin.getConfigurationTelemetry?.(),\n    })),\n    track_feature_flags_for_events: configuration.trackFeatureFlagsForEvents,\n    ...baseSerializedConfiguration,\n  } satisfies RawTelemetryConfiguration\n}\n", "import { display, addEventListener, buildEndpointHost } from '@datadog/browser-core'\nimport type { RumInitConfiguration } from './configuration'\n\nconst REMOTE_CONFIGURATION_VERSION = 'v1'\n\nexport function fetchAndApplyRemoteConfiguration(\n  initConfiguration: RumInitConfiguration,\n  callback: (initConfiguration: RumInitConfiguration) => void\n) {\n  fetchRemoteConfiguration(initConfiguration, (remoteInitConfiguration) => {\n    callback(applyRemoteConfiguration(initConfiguration, remoteInitConfiguration))\n  })\n}\n\nexport function applyRemoteConfiguration(\n  initConfiguration: RumInitConfiguration,\n  remoteInitConfiguration: Partial<RumInitConfiguration>\n) {\n  return { ...initConfiguration, ...remoteInitConfiguration }\n}\n\nexport function fetchRemoteConfiguration(\n  configuration: RumInitConfiguration,\n  callback: (remoteConfiguration: Partial<RumInitConfiguration>) => void\n) {\n  const xhr = new XMLHttpRequest()\n\n  addEventListener(configuration, xhr, 'load', function () {\n    if (xhr.status === 200) {\n      const remoteConfiguration = JSON.parse(xhr.responseText)\n      callback(remoteConfiguration.rum)\n    } else {\n      displayRemoteConfigurationFetchingError()\n    }\n  })\n\n  addEventListener(configuration, xhr, 'error', function () {\n    displayRemoteConfigurationFetchingError()\n  })\n\n  xhr.open('GET', buildEndpoint(configuration))\n  xhr.send()\n}\n\nexport function buildEndpoint(configuration: RumInitConfiguration) {\n  return `https://sdk-configuration.${buildEndpointHost('rum', configuration)}/${REMOTE_CONFIGURATION_VERSION}/${encodeURIComponent(configuration.remoteConfigurationId!)}.json`\n}\n\nfunction displayRemoteConfigurationFetchingError() {\n  display.error('Error fetching the remote configuration.')\n}\n", "import type { TrackingConsentState, DeflateWorker, Context, ContextManager, BoundedBuffer } from '@datadog/browser-core'\nimport {\n  createBoundedBuffer,\n  display,\n  canUseEventBridge,\n  displayAlreadyInitializedError,\n  willSyntheticsInjectRum,\n  noop,\n  timeStampNow,\n  clocksNow,\n  getEventBridge,\n  initFeatureFlags,\n  addTelemetryConfiguration,\n  initFetchObservable,\n  CustomerContextKey,\n  buildAccountContextManager,\n  buildGlobalContextManager,\n  buildUserContextManager,\n  setTimeout,\n} from '@datadog/browser-core'\nimport {\n  validateAndBuildRumConfiguration,\n  type RumConfiguration,\n  type RumInitConfiguration,\n} from '../domain/configuration'\nimport type { ViewOptions } from '../domain/view/trackViews'\nimport type { DurationVital, CustomVitalsState } from '../domain/vital/vitalCollection'\nimport { startDurationVital, stopDurationVital } from '../domain/vital/vitalCollection'\nimport { fetchAndApplyRemoteConfiguration, serializeRumConfiguration } from '../domain/configuration'\nimport { callPluginsMethod } from '../domain/plugins'\nimport type { StartRumResult } from './startRum'\nimport type { RumPublicApiOptions, Strategy } from './rumPublicApi'\n\nexport function createPreStartStrategy(\n  { ignoreInitIfSyntheticsWillInjectRum = true, startDeflateWorker }: RumPublicApiOptions,\n  trackingConsentState: TrackingConsentState,\n  customVitalsState: CustomVitalsState,\n  doStartRum: (\n    configuration: RumConfiguration,\n    deflateWorker: DeflateWorker | undefined,\n    initialViewOptions?: ViewOptions\n  ) => StartRumResult\n): Strategy {\n  const bufferApiCalls = createBoundedBuffer<StartRumResult>()\n\n  // TODO next major: remove the globalContextManager, userContextManager and accountContextManager from preStartStrategy and use an empty context instead\n  const globalContext = buildGlobalContextManager()\n  bufferContextCalls(globalContext, CustomerContextKey.globalContext, bufferApiCalls)\n\n  const userContext = buildUserContextManager()\n  bufferContextCalls(userContext, CustomerContextKey.userContext, bufferApiCalls)\n\n  const accountContext = buildAccountContextManager()\n  bufferContextCalls(accountContext, CustomerContextKey.accountContext, bufferApiCalls)\n\n  let firstStartViewCall:\n    | { options: ViewOptions | undefined; callback: (startRumResult: StartRumResult) => void }\n    | undefined\n  let deflateWorker: DeflateWorker | undefined\n\n  let cachedInitConfiguration: RumInitConfiguration | undefined\n  let cachedConfiguration: RumConfiguration | undefined\n\n  const trackingConsentStateSubscription = trackingConsentState.observable.subscribe(tryStartRum)\n\n  const emptyContext: Context = {}\n\n  function tryStartRum() {\n    if (!cachedInitConfiguration || !cachedConfiguration || !trackingConsentState.isGranted()) {\n      return\n    }\n\n    trackingConsentStateSubscription.unsubscribe()\n\n    let initialViewOptions: ViewOptions | undefined\n\n    if (cachedConfiguration.trackViewsManually) {\n      if (!firstStartViewCall) {\n        return\n      }\n      // An initial view is always created when starting RUM.\n      // When tracking views automatically, any startView call before RUM start creates an extra\n      // view.\n      // When tracking views manually, we use the ViewOptions from the first startView call as the\n      // initial view options, and we remove the actual startView call so we don't create an extra\n      // view.\n      bufferApiCalls.remove(firstStartViewCall.callback)\n      initialViewOptions = firstStartViewCall.options\n    }\n\n    const startRumResult = doStartRum(cachedConfiguration, deflateWorker, initialViewOptions)\n\n    bufferApiCalls.drain(startRumResult)\n  }\n\n  function doInit(initConfiguration: RumInitConfiguration) {\n    const eventBridgeAvailable = canUseEventBridge()\n    if (eventBridgeAvailable) {\n      initConfiguration = overrideInitConfigurationForBridge(initConfiguration)\n    }\n\n    // Update the exposed initConfiguration to reflect the bridge and remote configuration overrides\n    cachedInitConfiguration = initConfiguration\n    // FIXME temporary hack to avoid sending configuration without all the context data\n    setTimeout(() => {\n      addTelemetryConfiguration(serializeRumConfiguration(initConfiguration))\n    })\n\n    if (cachedConfiguration) {\n      displayAlreadyInitializedError('DD_RUM', initConfiguration)\n      return\n    }\n\n    const configuration = validateAndBuildRumConfiguration(initConfiguration)\n    if (!configuration) {\n      return\n    }\n\n    if (!eventBridgeAvailable && !configuration.sessionStoreStrategyType) {\n      display.warn('No storage available for session. We will not send any data.')\n      return\n    }\n\n    if (configuration.compressIntakeRequests && !eventBridgeAvailable && startDeflateWorker) {\n      deflateWorker = startDeflateWorker(\n        configuration,\n        'Datadog RUM',\n        // Worker initialization can fail asynchronously, especially in Firefox where even CSP\n        // issues are reported asynchronously. For now, the SDK will continue its execution even if\n        // data won't be sent to Datadog. We could improve this behavior in the future.\n        noop\n      )\n      if (!deflateWorker) {\n        // `startDeflateWorker` should have logged an error message explaining the issue\n        return\n      }\n    }\n\n    cachedConfiguration = configuration\n    // Instrument fetch to track network requests\n    // This is needed in case the consent is not granted and some customer\n    // library (Apollo Client) is storing uninstrumented fetch to be used later\n    // The subscription is needed so that the instrumentation process is completed\n    initFetchObservable().subscribe(noop)\n\n    trackingConsentState.tryToInit(configuration.trackingConsent)\n    tryStartRum()\n  }\n\n  const addDurationVital = (vital: DurationVital) => {\n    bufferApiCalls.add((startRumResult) => startRumResult.addDurationVital(vital))\n  }\n\n  const strategy: Strategy = {\n    init(initConfiguration, publicApi) {\n      if (!initConfiguration) {\n        display.error('Missing configuration')\n        return\n      }\n      // Set the experimental feature flags as early as possible, so we can use them in most places\n      initFeatureFlags(initConfiguration.enableExperimentalFeatures)\n\n      // Expose the initial configuration regardless of initialization success.\n      cachedInitConfiguration = initConfiguration\n\n      // If we are in a Synthetics test configured to automatically inject a RUM instance, we want\n      // to completely discard the customer application RUM instance by ignoring their init() call.\n      // But, we should not ignore the init() call from the Synthetics-injected RUM instance, so the\n      // internal `ignoreInitIfSyntheticsWillInjectRum` option is here to bypass this condition.\n      if (ignoreInitIfSyntheticsWillInjectRum && willSyntheticsInjectRum()) {\n        return\n      }\n\n      callPluginsMethod(initConfiguration.plugins, 'onInit', { initConfiguration, publicApi })\n\n      if (initConfiguration.remoteConfigurationId) {\n        fetchAndApplyRemoteConfiguration(initConfiguration, doInit)\n      } else {\n        doInit(initConfiguration)\n      }\n    },\n\n    get initConfiguration() {\n      return cachedInitConfiguration\n    },\n\n    getInternalContext: noop as () => undefined,\n\n    stopSession: noop,\n\n    addTiming(name, time = timeStampNow()) {\n      bufferApiCalls.add((startRumResult) => startRumResult.addTiming(name, time))\n    },\n\n    startView(options, startClocks = clocksNow()) {\n      const callback = (startRumResult: StartRumResult) => {\n        startRumResult.startView(options, startClocks)\n      }\n      bufferApiCalls.add(callback)\n\n      if (!firstStartViewCall) {\n        firstStartViewCall = { options, callback }\n        tryStartRum()\n      }\n    },\n\n    setViewName(name) {\n      bufferApiCalls.add((startRumResult) => startRumResult.setViewName(name))\n    },\n\n    // View context APIs\n\n    setViewContext(context) {\n      bufferApiCalls.add((startRumResult) => startRumResult.setViewContext(context))\n    },\n\n    setViewContextProperty(key, value) {\n      bufferApiCalls.add((startRumResult) => startRumResult.setViewContextProperty(key, value))\n    },\n\n    getViewContext: () => emptyContext,\n\n    globalContext,\n    userContext,\n    accountContext,\n\n    addAction(action) {\n      bufferApiCalls.add((startRumResult) => startRumResult.addAction(action))\n    },\n\n    addError(providedError) {\n      bufferApiCalls.add((startRumResult) => startRumResult.addError(providedError))\n    },\n\n    addFeatureFlagEvaluation(key, value) {\n      bufferApiCalls.add((startRumResult) => startRumResult.addFeatureFlagEvaluation(key, value))\n    },\n\n    startDurationVital(name, options) {\n      return startDurationVital(customVitalsState, name, options)\n    },\n\n    stopDurationVital(name, options) {\n      stopDurationVital(addDurationVital, customVitalsState, name, options)\n    },\n\n    addDurationVital,\n  }\n\n  return strategy\n}\n\nfunction overrideInitConfigurationForBridge(initConfiguration: RumInitConfiguration): RumInitConfiguration {\n  return {\n    ...initConfiguration,\n    applicationId: '00000000-aaaa-0000-aaaa-000000000000',\n    clientToken: 'empty',\n    sessionSampleRate: 100,\n    defaultPrivacyLevel: initConfiguration.defaultPrivacyLevel ?? getEventBridge()?.getPrivacyLevel(),\n  }\n}\n\nfunction bufferContextCalls(\n  preStartContextManager: ContextManager,\n  name: CustomerContextKey,\n  bufferApiCalls: BoundedBuffer<StartRumResult>\n) {\n  preStartContextManager.changeObservable.subscribe(() => {\n    const context = preStartContextManager.getContext()\n    bufferApiCalls.add((startRumResult) => startRumResult[name].setContext(context))\n  })\n}\n", "import type {\n  Context,\n  TimeStamp,\n  RelativeTime,\n  User,\n  Account,\n  DeflateWorker,\n  DeflateEncoderStreamId,\n  DeflateEncoder,\n  TrackingConsent,\n  PublicApi,\n  Duration,\n  ContextManager,\n} from '@datadog/browser-core'\nimport {\n  ContextManagerMethod,\n  addTelemetryUsage,\n  deepClone,\n  makePublicApi,\n  monitor,\n  clocksNow,\n  callMonitored,\n  createHandlingStack,\n  sanitize,\n  createIdentityEncoder,\n  displayAlreadyInitializedError,\n  createTrackingConsentState,\n  timeStampToClocks,\n  CustomerContextKey,\n  defineContextMethod,\n} from '@datadog/browser-core'\n\nimport type { LifeCycle } from '../domain/lifeCycle'\nimport type { ViewHistory } from '../domain/contexts/viewHistory'\nimport type { RumSessionManager } from '../domain/rumSessionManager'\nimport type { ReplayStats } from '../rawRumEvent.types'\nimport { ActionType, VitalType } from '../rawRumEvent.types'\nimport type { RumConfiguration, RumInitConfiguration } from '../domain/configuration'\nimport type { ViewOptions } from '../domain/view/trackViews'\nimport type { InternalContext } from '../domain/contexts/internalContext'\nimport type { DurationVitalReference } from '../domain/vital/vitalCollection'\nimport { createCustomVitalsState } from '../domain/vital/vitalCollection'\nimport { callPluginsMethod } from '../domain/plugins'\nimport type { Hooks } from '../domain/hooks'\nimport { createPreStartStrategy } from './preStartRum'\nimport type { StartRum, StartRumResult } from './startRum'\n\nexport interface StartRecordingOptions {\n  force: boolean\n}\nexport interface RumPublicApi extends PublicApi {\n  /**\n   * Init the RUM browser SDK.\n   * @param initConfiguration Configuration options of the SDK\n   *\n   * See [RUM Browser Monitoring Setup](https://docs.datadoghq.com/real_user_monitoring/browser) for further information.\n   */\n  init: (initConfiguration: RumInitConfiguration) => void\n\n  /**\n   * Set the tracking consent of the current user.\n   *\n   * @param {\"granted\" | \"not-granted\"} trackingConsent The user tracking consent\n   *\n   * Data will be sent only if it is set to \"granted\". This value won't be stored by the library\n   * across page loads: you will need to call this method or set the appropriate `trackingConsent`\n   * field in the init() method at each page load.\n   *\n   * If this method is called before the init() method, the provided value will take precedence\n   * over the one provided as initialization parameter.\n   *\n   * See [User tracking consent](https://docs.datadoghq.com/real_user_monitoring/browser/advanced_configuration/#user-tracking-consent) for further information.\n   */\n  setTrackingConsent: (trackingConsent: TrackingConsent) => void\n\n  /**\n   * Set View Name.\n   *\n   * Enable to manually change the name of the current view.\n   * @param name name of the view\n   * See [Override default RUM view names](https://docs.datadoghq.com/real_user_monitoring/browser/advanced_configuration/#override-default-rum-view-names) for further information.\n   */\n  setViewName: (name: string) => void\n\n  /**\n   * Set View Context.\n   *\n   * Enable to manually set the context of the current view.\n   * @param context context of the view\n   */\n  setViewContext: (context: Context) => void\n  /**\n   * Set View Context Property.\n   *\n   * Enable to manually set a property of the context of the current view.\n   * @param key key of the property\n   * @param value value of the property\n   */\n  setViewContextProperty: (key: string, value: any) => void\n\n  /**\n   * Get View Context.\n   */\n  getViewContext: () => Context\n\n  /**\n   * Set the global context information to all events, stored in `@context`\n   *\n   * @param context Global context\n   *\n   * See [Global context](https://docs.datadoghq.com/real_user_monitoring/browser/advanced_configuration/#global-context) for further information.\n   */\n  setGlobalContext: (context: any) => void\n\n  /**\n   * Get the global Context\n   *\n   * See [Global context](https://docs.datadoghq.com/real_user_monitoring/browser/advanced_configuration/#global-context) for further information.\n   */\n  getGlobalContext: () => Context\n\n  /**\n   * Set or update a global context property, stored in `@context.<key>`\n   *\n   * @param key Key of the property\n   * @param property Value of the property\n   *\n   * See [Global context](https://docs.datadoghq.com/real_user_monitoring/browser/advanced_configuration/#global-context) for further information.\n   */\n  setGlobalContextProperty: (key: any, value: any) => void\n\n  /**\n   * Remove a global context property\n   *\n   * See [Global context](https://docs.datadoghq.com/real_user_monitoring/browser/advanced_configuration/#global-context) for further information.\n   */\n  removeGlobalContextProperty: (key: any) => void\n\n  /**\n   * Clear the global context\n   *\n   * See [Global context](https://docs.datadoghq.com/real_user_monitoring/browser/advanced_configuration/#global-context) for further information.\n   */\n  clearGlobalContext: () => void\n\n  /**\n   * [Internal API] Get the internal SDK context\n   */\n  getInternalContext: (startTime?: number) => InternalContext | undefined\n\n  /**\n   * Get the init configuration\n   */\n  getInitConfiguration: () => RumInitConfiguration | undefined\n\n  /**\n   * Add a custom action, stored in `@action`\n   * @param name Name of the action\n   * @param context Context of the action\n   *\n   * See [Send RUM Custom Actions](https://docs.datadoghq.com/real_user_monitoring/guide/send-rum-custom-actions) for further information.\n   */\n  addAction: (name: string, context?: object) => void\n\n  /**\n   * Add a custom error, stored in `@error`.\n   * @param error Error. Favor sending a [Javascript Error](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) to have a stack trace attached to the error event.\n   * @param context Context of the error\n   *\n   * See [Send RUM Custom Actions](https://docs.datadoghq.com/real_user_monitoring/guide/send-rum-custom-actions) for further information.\n   */\n  addError: (error: unknown, context?: object) => void\n\n  /**\n   * Add a custom timing relative to the start of the current view,\n   * stored in `@view.custom_timings.<timing_name>`\n   *\n   * @param name Name of the custom timing\n   * @param [time] Epoch timestamp of the custom timing (if not set, will use current time)\n   *\n   * Note: passing a relative time is discouraged since it is actually used as-is but displayed relative to the view start.\n   * We currently don't provide a way to retrieve the view start time, so it can be challenging to provide a timing relative to the view start.\n   * see https://github.com/DataDog/browser-sdk/issues/2552\n   */\n  addTiming: (name: string, time?: number) => void\n\n  /**\n   * Set user information to all events, stored in `@usr`\n   *\n   * See [User session](https://docs.datadoghq.com/real_user_monitoring/browser/advanced_configuration/#user-session) for further information.\n   */\n  setUser(newUser: User & { id: string }): void\n\n  /**\n   * Set user information to all events, stored in `@usr`\n   *\n   * @deprecated You must specify a user id\n   * @see {@link setUser}\n   */\n  setUser(newUser: User): void\n  /**\n   * Get user information\n   *\n   * See [User session](https://docs.datadoghq.com/real_user_monitoring/browser/advanced_configuration/#user-session) for further information.\n   */\n  getUser: () => Context\n\n  /**\n   * Set or update the user property, stored in `@usr.<key>`\n   *\n   * @param key Key of the property\n   * @param property Value of the property\n   *\n   * See [User session](https://docs.datadoghq.com/real_user_monitoring/browser/advanced_configuration/#user-session) for further information.\n   */\n  setUserProperty: (key: any, property: any) => void\n\n  /**\n   * Remove a user property\n   *\n   * See [User session](https://docs.datadoghq.com/real_user_monitoring/browser/advanced_configuration/#user-session) for further information.\n   */\n  removeUserProperty: (key: any) => void\n\n  /**\n   * Clear all user information\n   *\n   * See [User session](https://docs.datadoghq.com/real_user_monitoring/browser/advanced_configuration/#user-session) for further information.\n   */\n  clearUser: () => void\n\n  /**\n   * Set account information to all events, stored in `@account`\n   */\n  setAccount: (newAccount: Account) => void\n\n  /**\n   * Get account information\n   */\n  getAccount: () => Context\n\n  /**\n   * Set or update the account property, stored in `@account.<key>`\n   *\n   * @param key Key of the property\n   * @param property Value of the property\n   */\n  setAccountProperty: (key: string, property: any) => void\n\n  /**\n   * Remove an account property\n   */\n  removeAccountProperty: (key: string) => void\n\n  /**\n   * Clear all account information\n   */\n  clearAccount: () => void\n\n  /**\n   * Start a view manually.\n   * Enable to manual start a view, use `trackViewsManually: true` init parameter and call `startView()` to create RUM views and be aligned with how you’ve defined them in your SPA application routing.\n   *\n   * @param options.name name of the view\n   * @param options.service service of the view\n   * @param options.version version of the view\n   *\n   * See [Override default RUM view names](https://docs.datadoghq.com/real_user_monitoring/browser/advanced_configuration/#override-default-rum-view-names) for further information.\n   */\n  startView: {\n    (name?: string): void\n    (options: ViewOptions): void\n  }\n\n  /**\n   * Stop the session. A new session will start at the next user interaction with the page.\n   */\n  stopSession: () => void\n\n  /**\n   * Add a feature flag evaluation,\n   * stored in `@feature_flags.<feature_flag_key>`\n   *\n   * @param {string} key The key of the feature flag.\n   * @param {any} value The value of the feature flag.\n   *\n   * We recommend enabling the intake request compression when using feature flags `compressIntakeRequests: true`.\n   *\n   * See [Feature Flag Tracking](https://docs.datadoghq.com/real_user_monitoring/feature_flag_tracking/) for further information.\n   */\n  addFeatureFlagEvaluation: (key: string, value: any) => void\n\n  /**\n   * Get the Session Replay Link.\n   *\n   * See [Connect Session Replay To Your Third-Party Tools](https://docs.datadoghq.com/real_user_monitoring/guide/connect-session-replay-to-your-third-party-tools) for further information.\n   */\n  getSessionReplayLink: () => string | undefined\n\n  /**\n   * Start Session Replay recording.\n   * Enable to conditionally start the recording, use the `startSessionReplayRecordingManually:true` init parameter and call `startSessionReplayRecording()`\n   *\n   * See [Browser Session Replay](https://docs.datadoghq.com/real_user_monitoring/session_replay/browser) for further information.\n   */\n  startSessionReplayRecording: (options?: StartRecordingOptions) => void\n\n  /**\n   * Stop Session Replay recording.\n   *\n   * See [Browser Session Replay](https://docs.datadoghq.com/real_user_monitoring/session_replay/browser) for further information.\n   */\n  stopSessionReplayRecording: () => void\n\n  /**\n   * Add a custom duration vital\n   *\n   * @param name name of the custom vital\n   * @param options.startTime epoch timestamp of the start of the custom vital\n   * @param options.duration duration of the custom vital in millisecond\n   * @param options.context custom context attached to the vital\n   * @param options.description  Description of the vital\n   */\n  addDurationVital: (\n    name: string,\n    options: { startTime: number; duration: number; context?: object; description?: string }\n  ) => void\n\n  /**\n   * Start a custom duration vital.\n   *\n   * If you plan to have multiple durations for the same vital, you should use the reference returned by this method.\n   *\n   * @param name name of the custom vital\n   * @param options.context custom context attached to the vital\n   * @param options.description Description of the vital\n   * @returns reference to the custom vital\n   */\n  startDurationVital: (name: string, options?: { context?: object; description?: string }) => DurationVitalReference\n\n  /**\n   * Stop a custom duration vital\n   *\n   * @param nameOrRef name of the custom vital or the reference to it\n   * @param options.context custom context attached to the vital\n   * @param options.description Description of the vital\n   */\n  stopDurationVital: (\n    nameOrRef: string | DurationVitalReference,\n    options?: { context?: object; description?: string }\n  ) => void\n}\n\nexport interface RecorderApi {\n  start: (options?: StartRecordingOptions) => void\n  stop: () => void\n  onRumStart: (\n    lifeCycle: LifeCycle,\n    configuration: RumConfiguration,\n    sessionManager: RumSessionManager,\n    viewHistory: ViewHistory,\n    deflateWorker: DeflateWorker | undefined\n  ) => void\n  isRecording: () => boolean\n  getReplayStats: (viewId: string) => ReplayStats | undefined\n  getSessionReplayLink: () => string | undefined\n}\n\nexport interface ProfilerApi {\n  stop: () => void\n  onRumStart: (\n    lifeCycle: LifeCycle,\n    hooks: Hooks,\n    configuration: RumConfiguration,\n    sessionManager: RumSessionManager,\n    viewHistory: ViewHistory\n  ) => void\n}\n\nexport interface RumPublicApiOptions {\n  ignoreInitIfSyntheticsWillInjectRum?: boolean\n  startDeflateWorker?: (\n    configuration: RumConfiguration,\n    source: string,\n    onInitializationFailure: () => void\n  ) => DeflateWorker | undefined\n  createDeflateEncoder?: (\n    configuration: RumConfiguration,\n    worker: DeflateWorker,\n    streamId: DeflateEncoderStreamId\n  ) => DeflateEncoder\n  sdkName?: 'rum' | 'rum-slim' | 'rum-synthetics'\n}\n\nexport interface Strategy {\n  init: (initConfiguration: RumInitConfiguration, publicApi: RumPublicApi) => void\n  initConfiguration: RumInitConfiguration | undefined\n  getInternalContext: StartRumResult['getInternalContext']\n  stopSession: StartRumResult['stopSession']\n  addTiming: StartRumResult['addTiming']\n  startView: StartRumResult['startView']\n  setViewName: StartRumResult['setViewName']\n\n  setViewContext: StartRumResult['setViewContext']\n  setViewContextProperty: StartRumResult['setViewContextProperty']\n  getViewContext: StartRumResult['getViewContext']\n\n  globalContext: ContextManager\n  userContext: ContextManager\n  accountContext: ContextManager\n\n  addAction: StartRumResult['addAction']\n  addError: StartRumResult['addError']\n  addFeatureFlagEvaluation: StartRumResult['addFeatureFlagEvaluation']\n  startDurationVital: StartRumResult['startDurationVital']\n  stopDurationVital: StartRumResult['stopDurationVital']\n  addDurationVital: StartRumResult['addDurationVital']\n}\n\nexport function makeRumPublicApi(\n  startRumImpl: StartRum,\n  recorderApi: RecorderApi,\n  profilerApi: ProfilerApi,\n  options: RumPublicApiOptions = {}\n): RumPublicApi {\n  const trackingConsentState = createTrackingConsentState()\n  const customVitalsState = createCustomVitalsState()\n\n  let strategy = createPreStartStrategy(\n    options,\n    trackingConsentState,\n    customVitalsState,\n    (configuration, deflateWorker, initialViewOptions) => {\n      const startRumResult = startRumImpl(\n        configuration,\n        recorderApi,\n        profilerApi,\n        initialViewOptions,\n        deflateWorker && options.createDeflateEncoder\n          ? (streamId) => options.createDeflateEncoder!(configuration, deflateWorker, streamId)\n          : createIdentityEncoder,\n        trackingConsentState,\n        customVitalsState,\n        options.sdkName\n      )\n\n      recorderApi.onRumStart(\n        startRumResult.lifeCycle,\n        configuration,\n        startRumResult.session,\n        startRumResult.viewHistory,\n        deflateWorker\n      )\n\n      profilerApi.onRumStart(\n        startRumResult.lifeCycle,\n        startRumResult.hooks,\n        configuration,\n        startRumResult.session,\n        startRumResult.viewHistory\n      )\n\n      strategy = createPostStartStrategy(strategy, startRumResult)\n\n      callPluginsMethod(configuration.plugins, 'onRumStart', {\n        strategy, // TODO: remove this in the next major release\n        addEvent: startRumResult.addEvent,\n      })\n\n      return startRumResult\n    }\n  )\n  const getStrategy = () => strategy\n\n  const startView: {\n    (name?: string): void\n    (options: ViewOptions): void\n  } = monitor((options?: string | ViewOptions) => {\n    const sanitizedOptions = typeof options === 'object' ? options : { name: options }\n    strategy.startView(sanitizedOptions)\n    addTelemetryUsage({ feature: 'start-view' })\n  })\n\n  const rumPublicApi: RumPublicApi = makePublicApi<RumPublicApi>({\n    init: monitor((initConfiguration) => {\n      strategy.init(initConfiguration, rumPublicApi)\n    }),\n\n    setTrackingConsent: monitor((trackingConsent) => {\n      trackingConsentState.update(trackingConsent)\n      addTelemetryUsage({ feature: 'set-tracking-consent', tracking_consent: trackingConsent })\n    }),\n\n    setViewName: monitor((name: string) => {\n      strategy.setViewName(name)\n      addTelemetryUsage({ feature: 'set-view-name' })\n    }),\n\n    setViewContext: monitor((context: Context) => {\n      strategy.setViewContext(context)\n      addTelemetryUsage({ feature: 'set-view-context' })\n    }),\n\n    setViewContextProperty: monitor((key: string, value: any) => {\n      strategy.setViewContextProperty(key, value)\n      addTelemetryUsage({ feature: 'set-view-context-property' })\n    }),\n\n    getViewContext: monitor(() => {\n      addTelemetryUsage({ feature: 'set-view-context-property' })\n      return strategy.getViewContext()\n    }),\n\n    getInternalContext: monitor((startTime) => strategy.getInternalContext(startTime)),\n\n    getInitConfiguration: monitor(() => deepClone(strategy.initConfiguration)),\n\n    addAction: (name, context) => {\n      const handlingStack = createHandlingStack('action')\n\n      callMonitored(() => {\n        strategy.addAction({\n          name: sanitize(name)!,\n          context: sanitize(context) as Context,\n          startClocks: clocksNow(),\n          type: ActionType.CUSTOM,\n          handlingStack,\n        })\n        addTelemetryUsage({ feature: 'add-action' })\n      })\n    },\n\n    addError: (error, context) => {\n      const handlingStack = createHandlingStack('error')\n      callMonitored(() => {\n        strategy.addError({\n          error, // Do not sanitize error here, it is needed unserialized by computeRawError()\n          handlingStack,\n          context: sanitize(context) as Context,\n          startClocks: clocksNow(),\n        })\n        addTelemetryUsage({ feature: 'add-error' })\n      })\n    },\n\n    addTiming: monitor((name, time) => {\n      // TODO: next major decide to drop relative time support or update its behaviour\n      strategy.addTiming(sanitize(name)!, time as RelativeTime | TimeStamp | undefined)\n    }),\n\n    setGlobalContext: defineContextMethod(\n      getStrategy,\n      CustomerContextKey.globalContext,\n      ContextManagerMethod.setContext,\n      'set-global-context'\n    ),\n    getGlobalContext: defineContextMethod(\n      getStrategy,\n      CustomerContextKey.globalContext,\n      ContextManagerMethod.getContext,\n      'get-global-context'\n    ),\n    setGlobalContextProperty: defineContextMethod(\n      getStrategy,\n      CustomerContextKey.globalContext,\n      ContextManagerMethod.setContextProperty,\n      'set-global-context-property'\n    ),\n    removeGlobalContextProperty: defineContextMethod(\n      getStrategy,\n      CustomerContextKey.globalContext,\n      ContextManagerMethod.removeContextProperty,\n      'remove-global-context-property'\n    ),\n    clearGlobalContext: defineContextMethod(\n      getStrategy,\n      CustomerContextKey.globalContext,\n      ContextManagerMethod.clearContext,\n      'clear-global-context'\n    ),\n\n    setUser: defineContextMethod(\n      getStrategy,\n      CustomerContextKey.userContext,\n      ContextManagerMethod.setContext,\n      'set-user'\n    ),\n    getUser: defineContextMethod(\n      getStrategy,\n      CustomerContextKey.userContext,\n      ContextManagerMethod.getContext,\n      'get-user'\n    ),\n    setUserProperty: defineContextMethod(\n      getStrategy,\n      CustomerContextKey.userContext,\n      ContextManagerMethod.setContextProperty,\n      'set-user-property'\n    ),\n    removeUserProperty: defineContextMethod(\n      getStrategy,\n      CustomerContextKey.userContext,\n      ContextManagerMethod.removeContextProperty,\n      'remove-user-property'\n    ),\n    clearUser: defineContextMethod(\n      getStrategy,\n      CustomerContextKey.userContext,\n      ContextManagerMethod.clearContext,\n      'clear-user'\n    ),\n\n    setAccount: defineContextMethod(\n      getStrategy,\n      CustomerContextKey.accountContext,\n      ContextManagerMethod.setContext,\n      'set-account'\n    ),\n    getAccount: defineContextMethod(\n      getStrategy,\n      CustomerContextKey.accountContext,\n      ContextManagerMethod.getContext,\n      'get-account'\n    ),\n    setAccountProperty: defineContextMethod(\n      getStrategy,\n      CustomerContextKey.accountContext,\n      ContextManagerMethod.setContextProperty,\n      'set-account-property'\n    ),\n    removeAccountProperty: defineContextMethod(\n      getStrategy,\n      CustomerContextKey.accountContext,\n      ContextManagerMethod.removeContextProperty,\n      'remove-account-property'\n    ),\n    clearAccount: defineContextMethod(\n      getStrategy,\n      CustomerContextKey.accountContext,\n      ContextManagerMethod.clearContext,\n      'clear-account'\n    ),\n\n    startView,\n\n    stopSession: monitor(() => {\n      strategy.stopSession()\n      addTelemetryUsage({ feature: 'stop-session' })\n    }),\n\n    addFeatureFlagEvaluation: monitor((key, value) => {\n      strategy.addFeatureFlagEvaluation(sanitize(key)!, sanitize(value))\n      addTelemetryUsage({ feature: 'add-feature-flag-evaluation' })\n    }),\n\n    getSessionReplayLink: monitor(() => recorderApi.getSessionReplayLink()),\n\n    startSessionReplayRecording: monitor((options?: StartRecordingOptions) => {\n      recorderApi.start(options)\n      addTelemetryUsage({ feature: 'start-session-replay-recording', force: options && options.force })\n    }),\n\n    stopSessionReplayRecording: monitor(() => recorderApi.stop()),\n\n    addDurationVital: monitor((name, options) => {\n      addTelemetryUsage({ feature: 'add-duration-vital' })\n      strategy.addDurationVital({\n        name: sanitize(name)!,\n        type: VitalType.DURATION,\n        startClocks: timeStampToClocks(options.startTime as TimeStamp),\n        duration: options.duration as Duration,\n        context: sanitize(options && options.context) as Context,\n        description: sanitize(options && options.description) as string | undefined,\n      })\n    }),\n\n    startDurationVital: monitor((name, options) => {\n      addTelemetryUsage({ feature: 'start-duration-vital' })\n      return strategy.startDurationVital(sanitize(name)!, {\n        context: sanitize(options && options.context) as Context,\n        description: sanitize(options && options.description) as string | undefined,\n      })\n    }),\n\n    stopDurationVital: monitor((nameOrRef, options) => {\n      addTelemetryUsage({ feature: 'stop-duration-vital' })\n      strategy.stopDurationVital(typeof nameOrRef === 'string' ? sanitize(nameOrRef)! : nameOrRef, {\n        context: sanitize(options && options.context) as Context,\n        description: sanitize(options && options.description) as string | undefined,\n      })\n    }),\n  })\n\n  return rumPublicApi\n}\n\nfunction createPostStartStrategy(preStartStrategy: Strategy, startRumResult: StartRumResult): Strategy {\n  return {\n    init: (initConfiguration: RumInitConfiguration) => {\n      displayAlreadyInitializedError('DD_RUM', initConfiguration)\n    },\n    initConfiguration: preStartStrategy.initConfiguration,\n    ...startRumResult,\n  }\n}\n", "import type { Duration, RelativeTime } from '@datadog/browser-core'\nimport {\n  addTelemetryDebug,\n  elapsed,\n  getPathName,\n  isValidUrl,\n  ResourceType,\n  toServerDuration,\n  isIntakeUrl,\n  isExperimentalFeatureEnabled,\n  ExperimentalFeature,\n} from '@datadog/browser-core'\n\nimport type { RumPerformanceResourceTiming } from '../../browser/performanceObservable'\n\nimport type { ResourceEntryDetailsElement, DeliveryType } from '../../rawRumEvent.types'\n\nexport interface ResourceEntryDetails {\n  worker?: ResourceEntryDetailsElement\n  redirect?: ResourceEntryDetailsElement\n  dns?: ResourceEntryDetailsElement\n  connect?: ResourceEntryDetailsElement\n  ssl?: ResourceEntryDetailsElement\n  first_byte?: ResourceEntryDetailsElement\n  download?: ResourceEntryDetailsElement\n}\n\nexport const FAKE_INITIAL_DOCUMENT = 'initial_document'\n\nconst RESOURCE_TYPES: Array<[ResourceType, (initiatorType: string, path: string) => boolean]> = [\n  [ResourceType.DOCUMENT, (initiatorType: string) => FAKE_INITIAL_DOCUMENT === initiatorType],\n  [ResourceType.XHR, (initiatorType: string) => 'xmlhttprequest' === initiatorType],\n  [ResourceType.FETCH, (initiatorType: string) => 'fetch' === initiatorType],\n  [ResourceType.BEACON, (initiatorType: string) => 'beacon' === initiatorType],\n  [ResourceType.CSS, (_: string, path: string) => /\\.css$/i.test(path)],\n  [ResourceType.JS, (_: string, path: string) => /\\.js$/i.test(path)],\n  [\n    ResourceType.IMAGE,\n    (initiatorType: string, path: string) =>\n      ['image', 'img', 'icon'].includes(initiatorType) || /\\.(gif|jpg|jpeg|tiff|png|svg|ico)$/i.exec(path) !== null,\n  ],\n  [ResourceType.FONT, (_: string, path: string) => /\\.(woff|eot|woff2|ttf)$/i.exec(path) !== null],\n  [\n    ResourceType.MEDIA,\n    (initiatorType: string, path: string) =>\n      ['audio', 'video'].includes(initiatorType) || /\\.(mp3|mp4)$/i.exec(path) !== null,\n  ],\n]\n\nexport function computeResourceEntryType(entry: RumPerformanceResourceTiming) {\n  const url = entry.name\n  if (!isValidUrl(url)) {\n    addTelemetryDebug(`Failed to construct URL for \"${entry.name}\"`)\n    return ResourceType.OTHER\n  }\n  const path = getPathName(url)\n  for (const [type, isType] of RESOURCE_TYPES) {\n    if (isType(entry.initiatorType, path)) {\n      return type\n    }\n  }\n  return ResourceType.OTHER\n}\n\nfunction areInOrder(...numbers: number[]) {\n  for (let i = 1; i < numbers.length; i += 1) {\n    if (numbers[i - 1] > numbers[i]) {\n      return false\n    }\n  }\n  return true\n}\n\nexport function isResourceEntryRequestType(entry: RumPerformanceResourceTiming) {\n  return entry.initiatorType === 'xmlhttprequest' || entry.initiatorType === 'fetch'\n}\n\nexport function computeResourceEntryDuration(entry: RumPerformanceResourceTiming): Duration {\n  const { duration, startTime, responseEnd } = entry\n\n  // Safari duration is always 0 on timings blocked by cross origin policies.\n  if (duration === 0 && startTime < responseEnd) {\n    return elapsed(startTime, responseEnd)\n  }\n\n  return duration\n}\n\nexport function computeResourceEntryDetails(entry: RumPerformanceResourceTiming): ResourceEntryDetails | undefined {\n  if (!hasValidResourceEntryTimings(entry)) {\n    return undefined\n  }\n  const {\n    startTime,\n    fetchStart,\n    workerStart,\n    redirectStart,\n    redirectEnd,\n    domainLookupStart,\n    domainLookupEnd,\n    connectStart,\n    secureConnectionStart,\n    connectEnd,\n    requestStart,\n    responseStart,\n    responseEnd,\n  } = entry\n\n  const details: ResourceEntryDetails = {\n    download: formatTiming(startTime, responseStart, responseEnd),\n    first_byte: formatTiming(startTime, requestStart, responseStart),\n  }\n\n  // Make sure a worker processing time is recorded\n  if (0 < workerStart && workerStart < fetchStart) {\n    details.worker = formatTiming(startTime, workerStart, fetchStart)\n  }\n\n  // Make sure a connection occurred\n  if (fetchStart < connectEnd) {\n    details.connect = formatTiming(startTime, connectStart, connectEnd)\n\n    // Make sure a secure connection occurred\n    if (connectStart <= secureConnectionStart && secureConnectionStart <= connectEnd) {\n      details.ssl = formatTiming(startTime, secureConnectionStart, connectEnd)\n    }\n  }\n\n  // Make sure a domain lookup occurred\n  if (fetchStart < domainLookupEnd) {\n    details.dns = formatTiming(startTime, domainLookupStart, domainLookupEnd)\n  }\n\n  // Make sure a redirection occurred\n  if (startTime < redirectEnd) {\n    details.redirect = formatTiming(startTime, redirectStart, redirectEnd)\n  }\n\n  return details\n}\n\n/**\n * Entries with negative duration are unexpected and should be dismissed. The intake will ignore RUM\n * Resource events with negative durations anyway.\n * Since Chromium 128, more entries have unexpected negative durations, see\n * https://issues.chromium.org/issues/363031537\n */\nexport function hasValidResourceEntryDuration(entry: RumPerformanceResourceTiming) {\n  return entry.duration >= 0\n}\n\nexport function hasValidResourceEntryTimings(entry: RumPerformanceResourceTiming) {\n  // Ensure timings are in the right order. On top of filtering out potential invalid\n  // RumPerformanceResourceTiming, it will ignore entries from requests where timings cannot be\n  // collected, for example cross origin requests without a \"Timing-Allow-Origin\" header allowing\n  // it.\n  const areCommonTimingsInOrder = areInOrder(\n    entry.startTime,\n    entry.fetchStart,\n    entry.domainLookupStart,\n    entry.domainLookupEnd,\n    entry.connectStart,\n    entry.connectEnd,\n    entry.requestStart,\n    entry.responseStart,\n    entry.responseEnd\n  )\n\n  const areRedirectionTimingsInOrder = hasRedirection(entry)\n    ? areInOrder(entry.startTime, entry.redirectStart, entry.redirectEnd, entry.fetchStart)\n    : true\n\n  return areCommonTimingsInOrder && areRedirectionTimingsInOrder\n}\n\nfunction hasRedirection(entry: RumPerformanceResourceTiming) {\n  return entry.redirectEnd > entry.startTime\n}\nfunction formatTiming(origin: RelativeTime, start: RelativeTime, end: RelativeTime) {\n  if (origin <= start && start <= end) {\n    return {\n      duration: toServerDuration(elapsed(start, end)),\n      start: toServerDuration(elapsed(origin, start)),\n    }\n  }\n}\n\n/**\n * The 'nextHopProtocol' is an empty string for cross-origin resources without CORS headers,\n * meaning the protocol is unknown, and we shouldn't report it.\n * https://developer.mozilla.org/en-US/docs/Web/API/PerformanceResourceTiming/nextHopProtocol#cross-origin_resources\n */\nexport function computeResourceEntryProtocol(entry: RumPerformanceResourceTiming) {\n  return entry.nextHopProtocol === '' ? undefined : entry.nextHopProtocol\n}\n\n/**\n * Handles the 'deliveryType' property to distinguish between supported values ('cache', 'navigational-prefetch'),\n * undefined (unsupported in some browsers), and other cases ('other' for unknown or unrecognized values).\n * see: https://developer.mozilla.org/en-US/docs/Web/API/PerformanceResourceTiming/deliveryType\n */\nexport function computeResourceEntryDeliveryType(entry: RumPerformanceResourceTiming): DeliveryType | undefined {\n  return entry.deliveryType === '' ? 'other' : entry.deliveryType\n}\n\nexport function computeResourceEntrySize(entry: RumPerformanceResourceTiming) {\n  // Make sure a request actually occurred\n  if (entry.startTime < entry.responseStart) {\n    const { encodedBodySize, decodedBodySize, transferSize } = entry\n    return {\n      size: decodedBodySize,\n      encoded_body_size: encodedBodySize,\n      decoded_body_size: decodedBodySize,\n      transfer_size: transferSize,\n    }\n  }\n  return {\n    size: undefined,\n    encoded_body_size: undefined,\n    decoded_body_size: undefined,\n    transfer_size: undefined,\n  }\n}\n\nexport function isAllowedRequestUrl(url: string) {\n  return url && (!isIntakeUrl(url) || isExperimentalFeatureEnabled(ExperimentalFeature.TRACK_INTAKE_REQUESTS))\n}\n\nconst DATA_URL_REGEX = /data:(.+)?(;base64)?,/g\nexport const MAX_RESOURCE_VALUE_CHAR_LENGTH = 24_000\n\nexport function sanitizeIfLongDataUrl(url: string, lengthLimit: number = MAX_RESOURCE_VALUE_CHAR_LENGTH): string {\n  if (url.length <= lengthLimit || !url.startsWith('data:')) {\n    return url\n  }\n  // truncate url first to a random length to prevent match error when the url is too long\n  const dataUrlMatchArray = url.substring(0, 100).match(DATA_URL_REGEX)\n  if (!dataUrlMatchArray) {\n    return url\n  }\n  return `${dataUrlMatchArray[0]}[...]`\n}\n", "import type { Duration, RelativeTime } from '@datadog/browser-core'\nimport { addEventListeners, dateNow, DOM_EVENT, relativeNow } from '@datadog/browser-core'\nimport type { RumConfiguration } from '../domain/configuration'\n\n/**\n * first-input timing entry polyfill based on\n * https://github.com/GoogleChrome/web-vitals/blob/master/src/lib/polyfills/firstInputPolyfill.ts\n */\nexport function retrieveFirstInputTiming(\n  configuration: RumConfiguration,\n  callback: (timing: PerformanceEventTiming) => void\n) {\n  const startTimeStamp = dateNow()\n  let timingSent = false\n\n  const { stop: removeEventListeners } = addEventListeners(\n    configuration,\n    window,\n    [DOM_EVENT.CLICK, DOM_EVENT.MOUSE_DOWN, DOM_EVENT.KEY_DOWN, DOM_EVENT.TOUCH_START, DOM_EVENT.POINTER_DOWN],\n    (evt) => {\n      // Only count cancelable events, which should trigger behavior important to the user.\n      if (!evt.cancelable) {\n        return\n      }\n\n      // This timing will be used to compute the \"first Input delay\", which is the delta between\n      // when the system received the event (e.g. evt.timeStamp) and when it could run the callback\n      // (e.g. performance.now()).\n      const timing: PerformanceEventTiming = {\n        entryType: 'first-input',\n        processingStart: relativeNow(),\n        processingEnd: relativeNow(),\n        startTime: evt.timeStamp as RelativeTime,\n        duration: 0 as Duration, // arbitrary value to avoid nullable duration and simplify INP logic\n        name: '',\n        cancelable: false,\n        target: null,\n        toJSON: () => ({}),\n      }\n\n      if (evt.type === DOM_EVENT.POINTER_DOWN) {\n        sendTimingIfPointerIsNotCancelled(configuration, timing)\n      } else {\n        sendTiming(timing)\n      }\n    },\n    { passive: true, capture: true }\n  )\n\n  return { stop: removeEventListeners }\n\n  /**\n   * Pointer events are a special case, because they can trigger main or compositor thread behavior.\n   * We differentiate these cases based on whether or not we see a pointercancel event, which are\n   * fired when we scroll. If we're scrolling we don't need to report input delay since FID excludes\n   * scrolling and pinch/zooming.\n   */\n  function sendTimingIfPointerIsNotCancelled(configuration: RumConfiguration, timing: PerformanceEventTiming) {\n    addEventListeners(\n      configuration,\n      window,\n      [DOM_EVENT.POINTER_UP, DOM_EVENT.POINTER_CANCEL],\n      (event) => {\n        if (event.type === DOM_EVENT.POINTER_UP) {\n          sendTiming(timing)\n        }\n      },\n      { once: true }\n    )\n  }\n\n  function sendTiming(timing: PerformanceEventTiming) {\n    if (!timingSent) {\n      timingSent = true\n      removeEventListeners()\n      // In some cases the recorded delay is clearly wrong, e.g. it's negative or it's larger than\n      // the time between now and when the page was loaded.\n      // - https://github.com/GoogleChromeLabs/first-input-delay/issues/4\n      // - https://github.com/GoogleChromeLabs/first-input-delay/issues/6\n      // - https://github.com/GoogleChromeLabs/first-input-delay/issues/7\n      const delay = timing.processingStart - timing.startTime\n      if (delay >= 0 && delay < dateNow() - startTimeStamp) {\n        callback(timing)\n      }\n    }\n  }\n}\n", "import type { Duration, RelativeTime, TimeoutId } from '@datadog/browser-core'\nimport { addEventListener, Observable, setTimeout, clearTimeout, monitor } from '@datadog/browser-core'\nimport type { RumConfiguration } from '../domain/configuration'\nimport { hasValidResourceEntryDuration, isAllowedRequestUrl } from '../domain/resource/resourceUtils'\nimport { retrieveFirstInputTiming } from './firstInputPolyfill'\n\ntype RumPerformanceObserverConstructor = new (callback: PerformanceObserverCallback) => RumPerformanceObserver\n\nexport interface BrowserWindow extends Window {\n  PerformanceObserver: RumPerformanceObserverConstructor\n  performance: Performance & { interactionCount?: number }\n}\n\nexport interface RumPerformanceObserver extends PerformanceObserver {\n  observe(options?: PerformanceObserverInit & { durationThreshold?: number }): void\n}\n\n// We want to use a real enum (i.e. not a const enum) here, to be able to check whether an arbitrary\n// string is an expected performance entry\n// eslint-disable-next-line no-restricted-syntax\nexport enum RumPerformanceEntryType {\n  EVENT = 'event',\n  FIRST_INPUT = 'first-input',\n  LARGEST_CONTENTFUL_PAINT = 'largest-contentful-paint',\n  LAYOUT_SHIFT = 'layout-shift',\n  LONG_TASK = 'longtask',\n  LONG_ANIMATION_FRAME = 'long-animation-frame',\n  NAVIGATION = 'navigation',\n  PAINT = 'paint',\n  RESOURCE = 'resource',\n  VISIBILITY_STATE = 'visibility-state',\n}\n\nexport interface RumPerformanceLongTaskTiming {\n  name: string\n  entryType: RumPerformanceEntryType.LONG_TASK\n  startTime: RelativeTime\n  duration: Duration\n  toJSON(): Omit<PerformanceEntry, 'toJSON'>\n}\n\nexport interface RumPerformanceResourceTiming {\n  entryType: RumPerformanceEntryType.RESOURCE\n  initiatorType: string\n  responseStatus?: number\n  name: string\n  startTime: RelativeTime\n  duration: Duration\n  fetchStart: RelativeTime\n  workerStart: RelativeTime\n  domainLookupStart: RelativeTime\n  domainLookupEnd: RelativeTime\n  connectStart: RelativeTime\n  secureConnectionStart: RelativeTime\n  connectEnd: RelativeTime\n  requestStart: RelativeTime\n  responseStart: RelativeTime\n  responseEnd: RelativeTime\n  redirectStart: RelativeTime\n  redirectEnd: RelativeTime\n  decodedBodySize: number\n  encodedBodySize: number\n  transferSize: number\n  nextHopProtocol?: string\n  renderBlockingStatus?: string\n  traceId?: string\n  deliveryType?: 'cache' | 'navigational-prefetch' | ''\n  toJSON(): Omit<PerformanceEntry, 'toJSON'>\n}\n\nexport interface RumPerformancePaintTiming {\n  entryType: RumPerformanceEntryType.PAINT\n  name: 'first-paint' | 'first-contentful-paint'\n  startTime: RelativeTime\n  toJSON(): Omit<RumPerformancePaintTiming, 'toJSON'>\n}\n\nexport interface RumPerformanceNavigationTiming extends Omit<RumPerformanceResourceTiming, 'entryType'> {\n  entryType: RumPerformanceEntryType.NAVIGATION\n  initiatorType: 'navigation'\n  name: string\n\n  domComplete: RelativeTime\n  domContentLoadedEventEnd: RelativeTime\n  domInteractive: RelativeTime\n  loadEventEnd: RelativeTime\n\n  toJSON(): Omit<RumPerformanceNavigationTiming, 'toJSON'>\n}\n\nexport interface RumLargestContentfulPaintTiming {\n  entryType: RumPerformanceEntryType.LARGEST_CONTENTFUL_PAINT\n  startTime: RelativeTime\n  size: number\n  element?: Element\n  url?: string\n  toJSON(): Omit<RumLargestContentfulPaintTiming, 'toJSON'>\n}\n\nexport interface RumFirstInputTiming {\n  entryType: RumPerformanceEntryType.FIRST_INPUT\n  startTime: RelativeTime\n  processingStart: RelativeTime\n  processingEnd: RelativeTime\n  duration: Duration\n  target?: Node\n  interactionId?: number\n  toJSON(): Omit<RumFirstInputTiming, 'toJSON'>\n}\n\nexport interface RumPerformanceEventTiming {\n  entryType: RumPerformanceEntryType.EVENT\n  startTime: RelativeTime\n  processingStart: RelativeTime\n  processingEnd: RelativeTime\n  duration: Duration\n  interactionId?: number\n  target?: Node\n  name: string\n  toJSON(): Omit<RumPerformanceEventTiming, 'toJSON'>\n}\n\nexport interface RumLayoutShiftAttribution {\n  node: Node | null\n  previousRect: DOMRectReadOnly\n  currentRect: DOMRectReadOnly\n}\n\nexport interface RumLayoutShiftTiming {\n  entryType: RumPerformanceEntryType.LAYOUT_SHIFT\n  startTime: RelativeTime\n  value: number\n  hadRecentInput: boolean\n  sources: RumLayoutShiftAttribution[]\n  toJSON(): Omit<RumLayoutShiftTiming, 'toJSON'>\n}\n\n// Documentation https://developer.chrome.com/docs/web-platform/long-animation-frames#better-attribution\nexport type RumPerformanceScriptTiming = {\n  duration: Duration\n  entryType: 'script'\n  executionStart: RelativeTime\n  forcedStyleAndLayoutDuration: Duration\n  invoker: string // e.g. \"https://static.datadoghq.com/static/c/93085/chunk-bc4db53278fd4c77a637.min.js\"\n  invokerType:\n    | 'user-callback'\n    | 'event-listener'\n    | 'resolve-promise'\n    | 'reject-promise'\n    | 'classic-script'\n    | 'module-script'\n  name: 'script'\n  pauseDuration: Duration\n  sourceCharPosition: number\n  sourceFunctionName: string\n  sourceURL: string\n  startTime: RelativeTime\n  window: Window\n  windowAttribution: string\n}\n\nexport interface RumPerformanceLongAnimationFrameTiming {\n  blockingDuration: Duration\n  duration: Duration\n  entryType: RumPerformanceEntryType.LONG_ANIMATION_FRAME\n  firstUIEventTimestamp: RelativeTime\n  name: 'long-animation-frame'\n  renderStart: RelativeTime\n  scripts: RumPerformanceScriptTiming[]\n  startTime: RelativeTime\n  styleAndLayoutStart: RelativeTime\n  toJSON(): Omit<RumPerformanceLongAnimationFrameTiming, 'toJSON'>\n}\n\nexport interface RumFirstHiddenTiming {\n  entryType: RumPerformanceEntryType.VISIBILITY_STATE\n  name: 'hidden' | 'visible'\n  startTime: RelativeTime\n  toJSON(): Omit<RumFirstHiddenTiming, 'toJSON'>\n}\n\nexport type RumPerformanceEntry =\n  | RumPerformanceResourceTiming\n  | RumPerformanceLongTaskTiming\n  | RumPerformanceLongAnimationFrameTiming\n  | RumPerformancePaintTiming\n  | RumPerformanceNavigationTiming\n  | RumLargestContentfulPaintTiming\n  | RumFirstInputTiming\n  | RumPerformanceEventTiming\n  | RumLayoutShiftTiming\n  | RumFirstHiddenTiming\n\nexport type EntryTypeToReturnType = {\n  [RumPerformanceEntryType.EVENT]: RumPerformanceEventTiming\n  [RumPerformanceEntryType.FIRST_INPUT]: RumFirstInputTiming\n  [RumPerformanceEntryType.LARGEST_CONTENTFUL_PAINT]: RumLargestContentfulPaintTiming\n  [RumPerformanceEntryType.LAYOUT_SHIFT]: RumLayoutShiftTiming\n  [RumPerformanceEntryType.PAINT]: RumPerformancePaintTiming\n  [RumPerformanceEntryType.LONG_TASK]: RumPerformanceLongTaskTiming\n  [RumPerformanceEntryType.LONG_ANIMATION_FRAME]: RumPerformanceLongAnimationFrameTiming\n  [RumPerformanceEntryType.NAVIGATION]: RumPerformanceNavigationTiming\n  [RumPerformanceEntryType.RESOURCE]: RumPerformanceResourceTiming\n  [RumPerformanceEntryType.VISIBILITY_STATE]: RumFirstHiddenTiming\n}\n\nexport function createPerformanceObservable<T extends RumPerformanceEntryType>(\n  configuration: RumConfiguration,\n  options: { type: T; buffered?: boolean; durationThreshold?: number }\n) {\n  return new Observable<Array<EntryTypeToReturnType[T]>>((observable) => {\n    if (!window.PerformanceObserver) {\n      return\n    }\n\n    const handlePerformanceEntries = (entries: PerformanceEntryList) => {\n      const rumPerformanceEntries = filterRumPerformanceEntries(entries as Array<EntryTypeToReturnType[T]>)\n      if (rumPerformanceEntries.length > 0) {\n        observable.notify(rumPerformanceEntries)\n      }\n    }\n\n    let timeoutId: TimeoutId | undefined\n    let isObserverInitializing = true\n    const observer = new PerformanceObserver(\n      monitor((entries) => {\n        // In Safari the performance observer callback is synchronous.\n        // Because the buffered performance entry list can be quite large we delay the computation to prevent the SDK from blocking the main thread on init\n        if (isObserverInitializing) {\n          timeoutId = setTimeout(() => handlePerformanceEntries(entries.getEntries()))\n        } else {\n          handlePerformanceEntries(entries.getEntries())\n        }\n      })\n    )\n    try {\n      observer.observe(options)\n    } catch {\n      // Some old browser versions (<= chrome 74 ) don't support the PerformanceObserver type and buffered options\n      // In these cases, fallback to getEntriesByType and PerformanceObserver with entryTypes\n      // TODO: remove this fallback in the next major version\n      const fallbackSupportedEntryTypes = [\n        RumPerformanceEntryType.RESOURCE,\n        RumPerformanceEntryType.NAVIGATION,\n        RumPerformanceEntryType.LONG_TASK,\n        RumPerformanceEntryType.PAINT,\n      ]\n      if (fallbackSupportedEntryTypes.includes(options.type)) {\n        if (options.buffered) {\n          timeoutId = setTimeout(() => handlePerformanceEntries(performance.getEntriesByType(options.type)))\n        }\n        try {\n          observer.observe({ entryTypes: [options.type] })\n        } catch {\n          // Old versions of Safari are throwing \"entryTypes contained only unsupported types\"\n          // errors when observing only unsupported entry types.\n          //\n          // We could use `supportPerformanceTimingEvent` to make sure we don't invoke\n          // `observer.observe` with an unsupported entry type, but Safari 11 and 12 don't support\n          // `Performance.supportedEntryTypes`, so doing so would lose support for these versions\n          // even if they do support the entry type.\n          return\n        }\n      }\n    }\n    isObserverInitializing = false\n\n    manageResourceTimingBufferFull(configuration)\n\n    let stopFirstInputTiming: (() => void) | undefined\n    if (\n      !supportPerformanceTimingEvent(RumPerformanceEntryType.FIRST_INPUT) &&\n      options.type === RumPerformanceEntryType.FIRST_INPUT\n    ) {\n      ;({ stop: stopFirstInputTiming } = retrieveFirstInputTiming(configuration, (timing) => {\n        handlePerformanceEntries([timing])\n      }))\n    }\n\n    return () => {\n      observer.disconnect()\n      if (stopFirstInputTiming) {\n        stopFirstInputTiming()\n      }\n      clearTimeout(timeoutId)\n    }\n  })\n}\n\nlet resourceTimingBufferFullListener: { stop: () => void }\nfunction manageResourceTimingBufferFull(configuration: RumConfiguration) {\n  if (!resourceTimingBufferFullListener && supportPerformanceObject() && 'addEventListener' in performance) {\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1559377\n    resourceTimingBufferFullListener = addEventListener(configuration, performance, 'resourcetimingbufferfull', () => {\n      performance.clearResourceTimings()\n    })\n  }\n  return () => {\n    resourceTimingBufferFullListener?.stop()\n  }\n}\n\nfunction supportPerformanceObject() {\n  return window.performance !== undefined && 'getEntries' in performance\n}\n\nexport function supportPerformanceTimingEvent(entryType: RumPerformanceEntryType) {\n  return (\n    window.PerformanceObserver &&\n    PerformanceObserver.supportedEntryTypes !== undefined &&\n    PerformanceObserver.supportedEntryTypes.includes(entryType)\n  )\n}\n\nfunction filterRumPerformanceEntries<T extends RumPerformanceEntryType>(entries: Array<EntryTypeToReturnType[T]>) {\n  return entries.filter((entry) => !isForbiddenResource(entry))\n}\n\nfunction isForbiddenResource(entry: RumPerformanceEntry) {\n  return (\n    entry.entryType === RumPerformanceEntryType.RESOURCE &&\n    (!isAllowedRequestUrl(entry.name) || !hasValidResourceEntryDuration(entry))\n  )\n}\n", "import { monitor, noop, Observable, getZoneJsOriginalValue } from '@datadog/browser-core'\n\n// https://dom.spec.whatwg.org/#interface-mutationrecord\nexport interface RumCharacterDataMutationRecord {\n  type: 'characterData'\n  target: Node\n  oldValue: string | null\n}\n\nexport interface RumAttributesMutationRecord {\n  type: 'attributes'\n  target: Element\n  oldValue: string | null\n  attributeName: string | null\n}\n\nexport interface RumChildListMutationRecord {\n  type: 'childList'\n  target: Node\n  addedNodes: NodeList\n  removedNodes: NodeList\n}\n\nexport type RumMutationRecord =\n  | RumCharacterDataMutationRecord\n  | RumAttributesMutationRecord\n  | RumChildListMutationRecord\n\nexport function createDOMMutationObservable() {\n  const MutationObserver = getMutationObserverConstructor()\n\n  return new Observable<RumMutationRecord[]>((observable) => {\n    if (!MutationObserver) {\n      return\n    }\n\n    const observer = new MutationObserver(monitor((records) => observable.notify(records)))\n    observer.observe(document, {\n      attributes: true,\n      characterData: true,\n      childList: true,\n      subtree: true,\n    })\n    return () => observer.disconnect()\n  })\n}\n\ntype MutationObserverConstructor = new (callback: (records: RumMutationRecord[]) => void) => MutationObserver\n\nexport interface BrowserWindow extends Window {\n  MutationObserver?: MutationObserverConstructor\n  Zone?: unknown\n}\n\nexport function getMutationObserverConstructor(): MutationObserverConstructor | undefined {\n  let constructor: MutationObserverConstructor | undefined\n  const browserWindow = window as BrowserWindow\n\n  // Angular uses Zone.js to provide a context persisting across async tasks.  Zone.js replaces the\n  // global MutationObserver constructor with a patched version to support the context propagation.\n  // There is an ongoing issue[1][2] with this setup when using a MutationObserver within a Angular\n  // component: on some occasions, the callback is being called in an infinite loop, causing the\n  // page to freeze (even if the callback is completely empty).\n  //\n  // To work around this issue, we try to get the original MutationObserver constructor stored by\n  // Zone.js.\n  //\n  // [1] https://github.com/angular/angular/issues/26948\n  // [2] https://github.com/angular/angular/issues/31712\n  if (browserWindow.Zone) {\n    // Zone.js 0.8.6+ is storing original class constructors into the browser 'window' object[3].\n    //\n    // [3] https://github.com/angular/angular/blob/6375fa79875c0fe7b815efc45940a6e6f5c9c9eb/packages/zone.js/lib/common/utils.ts#L288\n    constructor = getZoneJsOriginalValue(browserWindow, 'MutationObserver')\n\n    if (browserWindow.MutationObserver && constructor === browserWindow.MutationObserver) {\n      // Anterior Zone.js versions (used in Angular 2) does not expose the original MutationObserver\n      // in the 'window' object. Luckily, the patched MutationObserver class is storing an original\n      // instance in its properties[4]. Let's get the original MutationObserver constructor from\n      // there.\n      //\n      // [4] https://github.com/angular/zone.js/blob/v0.8.5/lib/common/utils.ts#L412\n\n      const patchedInstance = new browserWindow.MutationObserver(noop) as {\n        originalInstance?: { constructor: MutationObserverConstructor }\n      }\n\n      const originalInstance = getZoneJsOriginalValue(patchedInstance, 'originalInstance')\n      constructor = originalInstance && originalInstance.constructor\n    }\n  }\n\n  if (!constructor) {\n    constructor = browserWindow.MutationObserver\n  }\n\n  return constructor\n}\n", "import { instrumentMethod, Observable } from '@datadog/browser-core'\n\nexport function createWindowOpenObservable() {\n  const observable = new Observable<void>()\n  const { stop } = instrumentMethod(window, 'open', () => observable.notify())\n  return { observable, stop }\n}\n", "import type { RelativeTime } from '@datadog/browser-core'\nimport type { ActionContexts } from '../action/actionCollection'\nimport type { RumSessionManager } from '../rumSessionManager'\nimport type { ViewHistory } from './viewHistory'\nimport type { UrlContexts } from './urlContexts'\n\nexport interface InternalContext {\n  application_id: string\n  session_id: string | undefined\n  view?: {\n    id: string\n    url: string\n    referrer: string\n    name?: string\n  }\n  user_action?: {\n    id: string | string[]\n  }\n}\n\n/**\n * Internal context keep returning v1 format\n * to not break compatibility with logs data format\n */\nexport function startInternalContext(\n  applicationId: string,\n  sessionManager: RumSessionManager,\n  viewHistory: ViewHistory,\n  actionContexts: ActionContexts,\n  urlContexts: UrlContexts\n) {\n  return {\n    get: (startTime?: number): InternalContext | undefined => {\n      const viewContext = viewHistory.findView(startTime as RelativeTime)\n      const urlContext = urlContexts.findUrl(startTime as RelativeTime)\n      const session = sessionManager.findTrackedSession(startTime as RelativeTime)\n      if (session && viewContext && urlContext) {\n        const actionId = actionContexts.findActionId(startTime as RelativeTime)\n        return {\n          application_id: applicationId,\n          session_id: session.id,\n          user_action: actionId ? { id: actionId } : undefined,\n          view: { id: viewContext.id, name: viewContext.name, referrer: urlContext.referrer, url: urlContext.url },\n        }\n      }\n    },\n  }\n}\n", "import type { Context, Duration, PageMayExitEvent, RawError, RelativeTime } from '@datadog/browser-core'\nimport { AbstractLifeCycle } from '@datadog/browser-core'\nimport type { RumEventDomainContext } from '../domainContext.types'\nimport type { RawRumEvent } from '../rawRumEvent.types'\nimport type { RumEvent } from '../rumEvent.types'\nimport type { RequestCompleteEvent, RequestStartEvent } from './requestCollection'\nimport type { AutoAction } from './action/actionCollection'\nimport type { ViewEvent, ViewCreatedEvent, ViewEndedEvent, BeforeViewUpdateEvent } from './view/trackViews'\n\nexport const enum LifeCycleEventType {\n  // Contexts (like viewHistory) should be opened using prefixed BEFORE_XXX events and closed using prefixed AFTER_XXX events\n  // It ensures the context is available during the non prefixed event callbacks\n  AUTO_ACTION_COMPLETED,\n  BEFORE_VIEW_CREATED,\n  VIEW_CREATED,\n  BEFORE_VIEW_UPDATED,\n  VIEW_UPDATED,\n  VIEW_ENDED,\n  AFTER_VIEW_ENDED,\n  REQUEST_STARTED,\n  REQUEST_COMPLETED,\n\n  // The SESSION_EXPIRED lifecycle event has been introduced to represent when a session has expired\n  // and trigger cleanup tasks related to this, prior to renewing the session. Its implementation is\n  // slightly naive: it is not triggered as soon as the session is expired, but rather just before\n  // notifying that the session is renewed. Thus, the session id is already set to the newly renewed\n  // session.\n  //\n  // This implementation is \"good enough\" for our use-cases. Improving this is not trivial,\n  // primarily because multiple instances of the SDK may be managing the same session cookie at\n  // the same time, for example when using Logs and RUM on the same page, or opening multiple tabs\n  // on the same domain.\n  SESSION_EXPIRED,\n  SESSION_RENEWED,\n  PAGE_MAY_EXIT,\n  RAW_RUM_EVENT_COLLECTED,\n  RUM_EVENT_COLLECTED,\n  RAW_ERROR_COLLECTED,\n}\n\n// This is a workaround for an issue occurring when the Browser SDK is included in a TypeScript\n// project configured with `isolatedModules: true`. Even if the const enum is declared in this\n// module, we cannot use it directly to define the EventMap interface keys (TS error: \"Cannot access\n// ambient const enums when the '--isolatedModules' flag is provided.\").\n//\n// Using a plain enum would fix the issue, but would also add 2KB to the minified bundle. By using\n// this workaround, we can keep using a const enum without impacting the bundle size (since it is a\n// \"declare\" statement, it will only be used during typecheck and completely ignored when building\n// JavaScript).\n//\n// See issues:\n// * https://github.com/DataDog/browser-sdk/issues/2208\n// * https://github.com/microsoft/TypeScript/issues/54152\ndeclare const LifeCycleEventTypeAsConst: {\n  AUTO_ACTION_COMPLETED: LifeCycleEventType.AUTO_ACTION_COMPLETED\n  BEFORE_VIEW_CREATED: LifeCycleEventType.BEFORE_VIEW_CREATED\n  VIEW_CREATED: LifeCycleEventType.VIEW_CREATED\n  BEFORE_VIEW_UPDATED: LifeCycleEventType.BEFORE_VIEW_UPDATED\n  VIEW_UPDATED: LifeCycleEventType.VIEW_UPDATED\n  VIEW_ENDED: LifeCycleEventType.VIEW_ENDED\n  AFTER_VIEW_ENDED: LifeCycleEventType.AFTER_VIEW_ENDED\n  REQUEST_STARTED: LifeCycleEventType.REQUEST_STARTED\n  REQUEST_COMPLETED: LifeCycleEventType.REQUEST_COMPLETED\n  SESSION_EXPIRED: LifeCycleEventType.SESSION_EXPIRED\n  SESSION_RENEWED: LifeCycleEventType.SESSION_RENEWED\n  PAGE_MAY_EXIT: LifeCycleEventType.PAGE_MAY_EXIT\n  RAW_RUM_EVENT_COLLECTED: LifeCycleEventType.RAW_RUM_EVENT_COLLECTED\n  RUM_EVENT_COLLECTED: LifeCycleEventType.RUM_EVENT_COLLECTED\n  RAW_ERROR_COLLECTED: LifeCycleEventType.RAW_ERROR_COLLECTED\n}\n\n// Note: this interface needs to be exported even if it is not used outside of this module, else TS\n// fails to build the rum-core package with error TS4058\nexport interface LifeCycleEventMap {\n  [LifeCycleEventTypeAsConst.AUTO_ACTION_COMPLETED]: AutoAction\n  [LifeCycleEventTypeAsConst.BEFORE_VIEW_CREATED]: ViewCreatedEvent\n  [LifeCycleEventTypeAsConst.VIEW_CREATED]: ViewCreatedEvent\n  [LifeCycleEventTypeAsConst.BEFORE_VIEW_UPDATED]: BeforeViewUpdateEvent\n  [LifeCycleEventTypeAsConst.VIEW_UPDATED]: ViewEvent\n  [LifeCycleEventTypeAsConst.VIEW_ENDED]: ViewEndedEvent\n  [LifeCycleEventTypeAsConst.AFTER_VIEW_ENDED]: ViewEndedEvent\n  [LifeCycleEventTypeAsConst.REQUEST_STARTED]: RequestStartEvent\n  [LifeCycleEventTypeAsConst.REQUEST_COMPLETED]: RequestCompleteEvent\n  [LifeCycleEventTypeAsConst.SESSION_EXPIRED]: void\n  [LifeCycleEventTypeAsConst.SESSION_RENEWED]: void\n  [LifeCycleEventTypeAsConst.PAGE_MAY_EXIT]: PageMayExitEvent\n  [LifeCycleEventTypeAsConst.RAW_RUM_EVENT_COLLECTED]: RawRumEventCollectedData\n  [LifeCycleEventTypeAsConst.RUM_EVENT_COLLECTED]: RumEvent & Context\n  [LifeCycleEventTypeAsConst.RAW_ERROR_COLLECTED]: {\n    error: RawError\n    customerContext?: Context\n  }\n}\n\nexport interface RawRumEventCollectedData<E extends RawRumEvent = RawRumEvent> {\n  startTime: RelativeTime\n  duration?: Duration\n  customerContext?: Context\n  rawRumEvent: E\n  domainContext: RumEventDomainContext<E['type']>\n}\n\nexport const LifeCycle = AbstractLifeCycle<LifeCycleEventMap>\nexport type LifeCycle = AbstractLifeCycle<LifeCycleEventMap>\n", "import type { RelativeTime, ClocksState, Context } from '@datadog/browser-core'\nimport { SESSION_TIME_OUT_DELAY, createValueHistory } from '@datadog/browser-core'\nimport type { LifeCycle } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\nimport type { BeforeViewUpdateEvent, ViewCreatedEvent } from '../view/trackViews'\n\nexport const VIEW_CONTEXT_TIME_OUT_DELAY = SESSION_TIME_OUT_DELAY\n\nexport interface ViewHistoryEntry {\n  service?: string\n  version?: string\n  context?: Context | undefined\n  id: string\n  name?: string\n  startClocks: ClocksState\n  sessionIsActive?: boolean\n}\n\nexport interface ViewHistory {\n  findView: (startTime?: RelativeTime) => ViewHistoryEntry | undefined\n  stop: () => void\n}\n\nexport function startViewHistory(lifeCycle: LifeCycle): ViewHistory {\n  const viewValueHistory = createValueHistory<ViewHistoryEntry>({ expireDelay: VIEW_CONTEXT_TIME_OUT_DELAY })\n\n  lifeCycle.subscribe(LifeCycleEventType.BEFORE_VIEW_CREATED, (view) => {\n    viewValueHistory.add(buildViewHistoryEntry(view), view.startClocks.relative)\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.AFTER_VIEW_ENDED, ({ endClocks }) => {\n    viewValueHistory.closeActive(endClocks.relative)\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.BEFORE_VIEW_UPDATED, (viewUpdate: BeforeViewUpdateEvent) => {\n    const currentView = viewValueHistory.find(viewUpdate.startClocks.relative)\n    if (!currentView) {\n      return\n    }\n    if (viewUpdate.name) {\n      currentView.name = viewUpdate.name\n    }\n    if (viewUpdate.context) {\n      currentView.context = viewUpdate.context\n    }\n    currentView.sessionIsActive = viewUpdate.sessionIsActive\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.SESSION_RENEWED, () => {\n    viewValueHistory.reset()\n  })\n\n  function buildViewHistoryEntry(view: ViewCreatedEvent) {\n    return {\n      service: view.service,\n      version: view.version,\n      context: view.context,\n      id: view.id,\n      name: view.name,\n      startClocks: view.startClocks,\n    }\n  }\n\n  return {\n    findView: (startTime) => viewValueHistory.find(startTime),\n    stop: () => {\n      viewValueHistory.stop()\n    },\n  }\n}\n", "import type {\n  Duration,\n  XhrCompleteContext,\n  XhrStartContext,\n  ClocksState,\n  FetchStartContext,\n  FetchResolveContext,\n  ContextManager,\n} from '@datadog/browser-core'\nimport {\n  RequestType,\n  initFetchObservable,\n  initXhrObservable,\n  readBytesFromStream,\n  elapsed,\n  timeStampNow,\n  tryToClone,\n} from '@datadog/browser-core'\nimport type { RumSessionManager } from '..'\nimport type { RumConfiguration } from './configuration'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\nimport { isAllowedRequestUrl } from './resource/resourceUtils'\nimport type { Tracer } from './tracing/tracer'\nimport { startTracer } from './tracing/tracer'\nimport type { SpanIdentifier, TraceIdentifier } from './tracing/identifier'\n\nexport interface CustomContext {\n  requestIndex: number\n  spanId?: SpanIdentifier\n  traceId?: TraceIdentifier\n  traceSampled?: boolean\n}\nexport interface RumFetchStartContext extends FetchStartContext, CustomContext {}\nexport interface RumFetchResolveContext extends FetchResolveContext, CustomContext {}\nexport interface RumXhrStartContext extends XhrStartContext, CustomContext {}\nexport interface RumXhrCompleteContext extends XhrCompleteContext, CustomContext {}\n\nexport interface RequestStartEvent {\n  requestIndex: number\n  url: string\n}\nexport interface RequestCompleteEvent {\n  requestIndex: number\n  type: RequestType\n  method: string\n  url: string\n  status: number\n  responseType?: string\n  startClocks: ClocksState\n  duration: Duration\n  spanId?: SpanIdentifier\n  traceId?: TraceIdentifier\n  traceSampled?: boolean\n  xhr?: XMLHttpRequest\n  response?: Response\n  input?: unknown\n  init?: RequestInit\n  error?: Error\n  isAborted: boolean\n  handlingStack?: string\n}\n\nlet nextRequestIndex = 1\n\nexport function startRequestCollection(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  sessionManager: RumSessionManager,\n  userContext: ContextManager,\n  accountContext: ContextManager\n) {\n  const tracer = startTracer(configuration, sessionManager, userContext, accountContext)\n  trackXhr(lifeCycle, configuration, tracer)\n  trackFetch(lifeCycle, tracer)\n}\n\nexport function trackXhr(lifeCycle: LifeCycle, configuration: RumConfiguration, tracer: Tracer) {\n  const subscription = initXhrObservable(configuration).subscribe((rawContext) => {\n    const context = rawContext as RumXhrStartContext | RumXhrCompleteContext\n    if (!isAllowedRequestUrl(context.url)) {\n      return\n    }\n\n    switch (context.state) {\n      case 'start':\n        tracer.traceXhr(context, context.xhr)\n        context.requestIndex = getNextRequestIndex()\n\n        lifeCycle.notify(LifeCycleEventType.REQUEST_STARTED, {\n          requestIndex: context.requestIndex,\n          url: context.url,\n        })\n        break\n      case 'complete':\n        tracer.clearTracingIfNeeded(context)\n        lifeCycle.notify(LifeCycleEventType.REQUEST_COMPLETED, {\n          duration: context.duration,\n          method: context.method,\n          requestIndex: context.requestIndex,\n          spanId: context.spanId,\n          startClocks: context.startClocks,\n          status: context.status,\n          traceId: context.traceId,\n          traceSampled: context.traceSampled,\n          type: RequestType.XHR,\n          url: context.url,\n          xhr: context.xhr,\n          isAborted: context.isAborted,\n          handlingStack: context.handlingStack,\n        })\n        break\n    }\n  })\n\n  return { stop: () => subscription.unsubscribe() }\n}\n\nexport function trackFetch(lifeCycle: LifeCycle, tracer: Tracer) {\n  const subscription = initFetchObservable().subscribe((rawContext) => {\n    const context = rawContext as RumFetchResolveContext | RumFetchStartContext\n    if (!isAllowedRequestUrl(context.url)) {\n      return\n    }\n\n    switch (context.state) {\n      case 'start':\n        tracer.traceFetch(context)\n        context.requestIndex = getNextRequestIndex()\n\n        lifeCycle.notify(LifeCycleEventType.REQUEST_STARTED, {\n          requestIndex: context.requestIndex,\n          url: context.url,\n        })\n        break\n      case 'resolve':\n        waitForResponseToComplete(context, (duration: Duration) => {\n          tracer.clearTracingIfNeeded(context)\n          lifeCycle.notify(LifeCycleEventType.REQUEST_COMPLETED, {\n            duration,\n            method: context.method,\n            requestIndex: context.requestIndex,\n            responseType: context.responseType,\n            spanId: context.spanId,\n            startClocks: context.startClocks,\n            status: context.status,\n            traceId: context.traceId,\n            traceSampled: context.traceSampled,\n            type: RequestType.FETCH,\n            url: context.url,\n            response: context.response,\n            init: context.init,\n            input: context.input,\n            isAborted: context.isAborted,\n            handlingStack: context.handlingStack,\n          })\n        })\n        break\n    }\n  })\n  return { stop: () => subscription.unsubscribe() }\n}\n\nfunction getNextRequestIndex() {\n  const result = nextRequestIndex\n  nextRequestIndex += 1\n  return result\n}\n\nfunction waitForResponseToComplete(context: RumFetchResolveContext, callback: (duration: Duration) => void) {\n  const clonedResponse = context.response && tryToClone(context.response)\n  if (!clonedResponse || !clonedResponse.body) {\n    // do not try to wait for the response if the clone failed, fetch error or null body\n    callback(elapsed(context.startClocks.timeStamp, timeStampNow()))\n  } else {\n    readBytesFromStream(\n      clonedResponse.body,\n      () => {\n        callback(elapsed(context.startClocks.timeStamp, timeStampNow()))\n      },\n      {\n        bytesLimit: Number.POSITIVE_INFINITY,\n        collectStreamBody: false,\n      }\n    )\n  }\n}\n", "import type { ServerDuration } from '@datadog/browser-core'\nimport { isNumber } from '@datadog/browser-core'\n\nexport function discardNegativeDuration(duration: ServerDuration | undefined): ServerDuration | undefined {\n  return isNumber(duration) && duration < 0 ? undefined : duration\n}\n", "import { noop } from '@datadog/browser-core'\nimport { RumEventType } from '../rawRumEvent.types'\nimport type { RumActionEvent, RumErrorEvent, RumLongTaskEvent, RumResourceEvent } from '../rumEvent.types'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\n\nexport interface EventCounts {\n  errorCount: number\n  actionCount: number\n  longTaskCount: number\n  resourceCount: number\n  frustrationCount: number\n}\n\nexport function trackEventCounts({\n  lifeCycle,\n  isChildEvent,\n  onChange: callback = noop,\n}: {\n  lifeCycle: LifeCycle\n  isChildEvent: (event: RumActionEvent | RumErrorEvent | RumLongTaskEvent | RumResourceEvent) => boolean\n  onChange?: () => void\n}) {\n  const eventCounts: EventCounts = {\n    errorCount: 0,\n    longTaskCount: 0,\n    resourceCount: 0,\n    actionCount: 0,\n    frustrationCount: 0,\n  }\n\n  const subscription = lifeCycle.subscribe(LifeCycleEventType.RUM_EVENT_COLLECTED, (event): void => {\n    if (event.type === 'view' || event.type === 'vital' || !isChildEvent(event)) {\n      return\n    }\n    switch (event.type) {\n      case RumEventType.ERROR:\n        eventCounts.errorCount += 1\n        callback()\n        break\n      case RumEventType.ACTION:\n        eventCounts.actionCount += 1\n        if (event.action.frustration) {\n          eventCounts.frustrationCount += event.action.frustration.type.length\n        }\n        callback()\n        break\n      case RumEventType.LONG_TASK:\n        eventCounts.longTaskCount += 1\n        callback()\n        break\n      case RumEventType.RESOURCE:\n        if (!event._dd?.discarded) {\n          eventCounts.resourceCount += 1\n          callback()\n        }\n        break\n    }\n  })\n\n  return {\n    stop: () => {\n      subscription.unsubscribe()\n    },\n    eventCounts,\n  }\n}\n", "export function isTextNode(node: Node): node is Text {\n  return node.nodeType === Node.TEXT_NODE\n}\n\nexport function isCommentNode(node: Node): node is Comment {\n  return node.nodeType === Node.COMMENT_NODE\n}\n\nexport function isElementNode(node: Node): node is Element {\n  return node.nodeType === Node.ELEMENT_NODE\n}\n\nexport function isNodeShadowHost(node: Node): node is Element & { shadowRoot: ShadowRoot } {\n  return isElementNode(node) && Boolean(node.shadowRoot)\n}\n\nexport function isNodeShadowRoot(node: Node): node is ShadowRoot {\n  const shadowRoot = node as ShadowRoot\n  return !!shadowRoot.host && shadowRoot.nodeType === Node.DOCUMENT_FRAGMENT_NODE && isElementNode(shadowRoot.host)\n}\n\nexport function hasChildNodes(node: Node) {\n  return node.childNodes.length > 0 || isNodeShadowHost(node)\n}\n\nexport function forEachChildNodes(node: Node, callback: (child: Node) => void) {\n  let child = node.firstChild\n\n  while (child) {\n    callback(child)\n\n    child = child.nextSibling\n  }\n\n  if (isNodeShadowHost(node)) {\n    callback(node.shadowRoot)\n  }\n}\n\n/**\n * Return `host` in case if the current node is a shadow root otherwise will return the `parentNode`\n */\nexport function getParentNode(node: Node): Node | null {\n  return isNodeShadowRoot(node) ? node.host : node.parentNode\n}\n", "import type { Subscription, TimeoutId, TimeStamp } from '@datadog/browser-core'\nimport { matchList, monitor, Observable, timeStampNow, setTimeout, clearTimeout } from '@datadog/browser-core'\nimport { createPerformanceObservable, RumPerformanceEntryType } from '../browser/performanceObservable'\nimport type { RumMutationRecord } from '../browser/domMutationObservable'\nimport { isElementNode } from '../browser/htmlDomUtils'\nimport type { RumConfiguration } from './configuration'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\n\n// Delay to wait for a page activity to validate the tracking process\nexport const PAGE_ACTIVITY_VALIDATION_DELAY = 100\n// Delay to wait after a page activity to end the tracking process\nexport const PAGE_ACTIVITY_END_DELAY = 100\n\nexport const EXCLUDED_MUTATIONS_ATTRIBUTE = 'data-dd-excluded-activity-mutations'\n\nexport interface PageActivityEvent {\n  isBusy: boolean\n}\n\nexport type PageActivityEndEvent = { hadActivity: true; end: TimeStamp } | { hadActivity: false }\n\n/**\n * Wait for the page activity end\n *\n * Detection lifecycle:\n * ```\n *                        Wait page activity end\n *              .-------------------'--------------------.\n *              v                                        v\n *     [Wait for a page activity ]          [Wait for a maximum duration]\n *     [timeout: VALIDATION_DELAY]          [  timeout: maxDuration     ]\n *          /                  \\                           |\n *         v                    v                          |\n *  [No page activity]   [Page activity]                   |\n *         |                   |,----------------------.   |\n *         v                   v                       |   |\n *     (Discard)     [Wait for a page activity]        |   |\n *                   [   timeout: END_DELAY   ]        |   |\n *                       /                \\            |   |\n *                      v                  v           |   |\n *             [No page activity]    [Page activity]   |   |\n *                      |                 |            |   |\n *                      |                 '------------'   |\n *                      '-----------. ,--------------------'\n *                                   v\n *                                 (End)\n * ```\n *\n * Note: by assuming that maxDuration is greater than VALIDATION_DELAY, we are sure that if the\n * process is still alive after maxDuration, it has been validated.\n */\nexport function waitPageActivityEnd(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<RumMutationRecord[]>,\n  windowOpenObservable: Observable<void>,\n  configuration: RumConfiguration,\n  pageActivityEndCallback: (event: PageActivityEndEvent) => void,\n  maxDuration?: number\n) {\n  const pageActivityObservable = createPageActivityObservable(\n    lifeCycle,\n    domMutationObservable,\n    windowOpenObservable,\n    configuration\n  )\n  return doWaitPageActivityEnd(pageActivityObservable, pageActivityEndCallback, maxDuration)\n}\n\nexport function doWaitPageActivityEnd(\n  pageActivityObservable: Observable<PageActivityEvent>,\n  pageActivityEndCallback: (event: PageActivityEndEvent) => void,\n  maxDuration?: number\n) {\n  let pageActivityEndTimeoutId: TimeoutId\n  let hasCompleted = false\n\n  const validationTimeoutId = setTimeout(\n    monitor(() => complete({ hadActivity: false })),\n    PAGE_ACTIVITY_VALIDATION_DELAY\n  )\n  const maxDurationTimeoutId =\n    maxDuration !== undefined\n      ? setTimeout(\n          monitor(() => complete({ hadActivity: true, end: timeStampNow() })),\n          maxDuration\n        )\n      : undefined\n\n  const pageActivitySubscription = pageActivityObservable.subscribe(({ isBusy }) => {\n    clearTimeout(validationTimeoutId)\n    clearTimeout(pageActivityEndTimeoutId)\n    const lastChangeTime = timeStampNow()\n    if (!isBusy) {\n      pageActivityEndTimeoutId = setTimeout(\n        monitor(() => complete({ hadActivity: true, end: lastChangeTime })),\n        PAGE_ACTIVITY_END_DELAY\n      )\n    }\n  })\n\n  const stop = () => {\n    hasCompleted = true\n    clearTimeout(validationTimeoutId)\n    clearTimeout(pageActivityEndTimeoutId)\n    clearTimeout(maxDurationTimeoutId)\n    pageActivitySubscription.unsubscribe()\n  }\n\n  function complete(event: PageActivityEndEvent) {\n    if (hasCompleted) {\n      return\n    }\n    stop()\n    pageActivityEndCallback(event)\n  }\n  return { stop }\n}\n\nexport function createPageActivityObservable(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<RumMutationRecord[]>,\n  windowOpenObservable: Observable<void>,\n  configuration: RumConfiguration\n): Observable<PageActivityEvent> {\n  return new Observable<PageActivityEvent>((observable) => {\n    const subscriptions: Subscription[] = []\n    let firstRequestIndex: undefined | number\n    let pendingRequestsCount = 0\n\n    subscriptions.push(\n      domMutationObservable.subscribe((mutations) => {\n        if (!mutations.every(isExcludedMutation)) {\n          notifyPageActivity()\n        }\n      }),\n      windowOpenObservable.subscribe(notifyPageActivity),\n      createPerformanceObservable(configuration, { type: RumPerformanceEntryType.RESOURCE }).subscribe((entries) => {\n        if (entries.some((entry) => !isExcludedUrl(configuration, entry.name))) {\n          notifyPageActivity()\n        }\n      }),\n      lifeCycle.subscribe(LifeCycleEventType.REQUEST_STARTED, (startEvent) => {\n        if (isExcludedUrl(configuration, startEvent.url)) {\n          return\n        }\n        if (firstRequestIndex === undefined) {\n          firstRequestIndex = startEvent.requestIndex\n        }\n        pendingRequestsCount += 1\n        notifyPageActivity()\n      }),\n      lifeCycle.subscribe(LifeCycleEventType.REQUEST_COMPLETED, (request) => {\n        if (\n          isExcludedUrl(configuration, request.url) ||\n          firstRequestIndex === undefined ||\n          // If the request started before the tracking start, ignore it\n          request.requestIndex < firstRequestIndex\n        ) {\n          return\n        }\n        pendingRequestsCount -= 1\n        notifyPageActivity()\n      })\n    )\n\n    return () => {\n      subscriptions.forEach((s) => s.unsubscribe())\n    }\n\n    function notifyPageActivity() {\n      observable.notify({ isBusy: pendingRequestsCount > 0 })\n    }\n  })\n}\n\nfunction isExcludedUrl(configuration: RumConfiguration, requestUrl: string): boolean {\n  return matchList(configuration.excludedActivityUrls, requestUrl)\n}\n\nfunction isExcludedMutation(mutation: RumMutationRecord): boolean {\n  const targetElement = mutation.type === 'characterData' ? mutation.target.parentElement : mutation.target\n\n  return Boolean(\n    targetElement &&\n      isElementNode(targetElement) &&\n      targetElement.matches(`[${EXCLUDED_MUTATIONS_ATTRIBUTE}], [${EXCLUDED_MUTATIONS_ATTRIBUTE}] *`)\n  )\n}\n", "import { DefaultPrivacyLevel } from '@datadog/browser-core'\nimport { isElementNode, getParentNode, isTextNode } from '../browser/htmlDomUtils'\n\nexport const NodePrivacyLevel = {\n  IGNORE: 'ignore',\n  HIDDEN: 'hidden',\n  ALLOW: DefaultPrivacyLevel.ALLOW,\n  MASK: DefaultPrivacyLevel.MASK,\n  MASK_USER_INPUT: DefaultPrivacyLevel.MASK_USER_INPUT,\n} as const\nexport type NodePrivacyLevel = (typeof NodePrivacyLevel)[keyof typeof NodePrivacyLevel]\n\nexport const PRIVACY_ATTR_NAME = 'data-dd-privacy'\n\n// Privacy Attrs\nexport const PRIVACY_ATTR_VALUE_ALLOW = 'allow'\nexport const PRIVACY_ATTR_VALUE_MASK = 'mask'\nexport const PRIVACY_ATTR_VALUE_MASK_USER_INPUT = 'mask-user-input'\nexport const PRIVACY_ATTR_VALUE_HIDDEN = 'hidden'\n\n// Privacy Classes - not all customers can set plain HTML attributes, so support classes too\nexport const PRIVACY_CLASS_PREFIX = 'dd-privacy-'\n\n// Private Replacement Templates\nexport const CENSORED_STRING_MARK = '***'\nexport const CENSORED_IMG_MARK = 'data:image/gif;base64,R0lGODlhAQABAIAAAMLCwgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw=='\n\nexport const FORM_PRIVATE_TAG_NAMES: { [tagName: string]: true } = {\n  INPUT: true,\n  OUTPUT: true,\n  TEXTAREA: true,\n  SELECT: true,\n  OPTION: true,\n  DATALIST: true,\n  OPTGROUP: true,\n}\n\nconst TEXT_MASKING_CHAR = 'x'\n\nexport type NodePrivacyLevelCache = Map<Node, NodePrivacyLevel>\n\n/**\n * Get node privacy level by iterating over its ancestors. When the direct parent privacy level is\n * know, it is best to use something like:\n *\n * derivePrivacyLevelGivenParent(getNodeSelfPrivacyLevel(node), parentNodePrivacyLevel)\n */\nexport function getNodePrivacyLevel(\n  node: Node,\n  defaultPrivacyLevel: NodePrivacyLevel,\n  cache?: NodePrivacyLevelCache\n): NodePrivacyLevel {\n  if (cache && cache.has(node)) {\n    return cache.get(node)!\n  }\n  const parentNode = getParentNode(node)\n  const parentNodePrivacyLevel = parentNode\n    ? getNodePrivacyLevel(parentNode, defaultPrivacyLevel, cache)\n    : defaultPrivacyLevel\n  const selfNodePrivacyLevel = getNodeSelfPrivacyLevel(node)\n  const nodePrivacyLevel = reducePrivacyLevel(selfNodePrivacyLevel, parentNodePrivacyLevel)\n  if (cache) {\n    cache.set(node, nodePrivacyLevel)\n  }\n  return nodePrivacyLevel\n}\n\n/**\n * Reduces the next privacy level based on self + parent privacy levels\n */\nexport function reducePrivacyLevel(\n  childPrivacyLevel: NodePrivacyLevel | undefined,\n  parentNodePrivacyLevel: NodePrivacyLevel\n): NodePrivacyLevel {\n  switch (parentNodePrivacyLevel) {\n    // These values cannot be overridden\n    case NodePrivacyLevel.HIDDEN:\n    case NodePrivacyLevel.IGNORE:\n      return parentNodePrivacyLevel\n  }\n  switch (childPrivacyLevel) {\n    case NodePrivacyLevel.ALLOW:\n    case NodePrivacyLevel.MASK:\n    case NodePrivacyLevel.MASK_USER_INPUT:\n    case NodePrivacyLevel.HIDDEN:\n    case NodePrivacyLevel.IGNORE:\n      return childPrivacyLevel\n    default:\n      return parentNodePrivacyLevel\n  }\n}\n\n/**\n * Determines the node's own privacy level without checking for ancestors.\n */\nexport function getNodeSelfPrivacyLevel(node: Node): NodePrivacyLevel | undefined {\n  // Only Element types can have a privacy level set\n  if (!isElementNode(node)) {\n    return\n  }\n\n  // Overrules for replay purpose\n  if (node.tagName === 'BASE') {\n    return NodePrivacyLevel.ALLOW\n  }\n\n  // Overrules to enforce end-user protection\n  if (node.tagName === 'INPUT') {\n    const inputElement = node as HTMLInputElement\n    if (inputElement.type === 'password' || inputElement.type === 'email' || inputElement.type === 'tel') {\n      return NodePrivacyLevel.MASK\n    }\n    if (inputElement.type === 'hidden') {\n      return NodePrivacyLevel.MASK\n    }\n    const autocomplete = inputElement.getAttribute('autocomplete')\n    // Handle input[autocomplete=cc-number/cc-csc/cc-exp/cc-exp-month/cc-exp-year/new-password/current-password]\n    if (autocomplete && (autocomplete.startsWith('cc-') || autocomplete.endsWith('-password'))) {\n      return NodePrivacyLevel.MASK\n    }\n  }\n\n  // Check HTML privacy attributes and classes\n  if (node.matches(getPrivacySelector(NodePrivacyLevel.HIDDEN))) {\n    return NodePrivacyLevel.HIDDEN\n  }\n\n  if (node.matches(getPrivacySelector(NodePrivacyLevel.MASK))) {\n    return NodePrivacyLevel.MASK\n  }\n\n  if (node.matches(getPrivacySelector(NodePrivacyLevel.MASK_USER_INPUT))) {\n    return NodePrivacyLevel.MASK_USER_INPUT\n  }\n\n  if (node.matches(getPrivacySelector(NodePrivacyLevel.ALLOW))) {\n    return NodePrivacyLevel.ALLOW\n  }\n\n  if (shouldIgnoreElement(node)) {\n    return NodePrivacyLevel.IGNORE\n  }\n}\n\n/**\n * Helper aiming to unify `mask` and `mask-user-input` privacy levels:\n *\n * In the `mask` case, it is trivial: we should mask the element.\n *\n * In the `mask-user-input` case, we should mask the element only if it is a \"form\" element or the\n * direct parent is a form element for text nodes).\n *\n * Other `shouldMaskNode` cases are edge cases that should not matter too much (ex: should we mask a\n * node if it is ignored or hidden? it doesn't matter since it won't be serialized).\n */\nexport function shouldMaskNode(node: Node, privacyLevel: NodePrivacyLevel) {\n  switch (privacyLevel) {\n    case NodePrivacyLevel.MASK:\n    case NodePrivacyLevel.HIDDEN:\n    case NodePrivacyLevel.IGNORE:\n      return true\n    case NodePrivacyLevel.MASK_USER_INPUT:\n      return isTextNode(node) ? isFormElement(node.parentNode) : isFormElement(node)\n    default:\n      return false\n  }\n}\n\nfunction isFormElement(node: Node | null): boolean {\n  if (!node || node.nodeType !== node.ELEMENT_NODE) {\n    return false\n  }\n  const element = node as HTMLInputElement\n  if (element.tagName === 'INPUT') {\n    switch (element.type) {\n      case 'button':\n      case 'color':\n      case 'reset':\n      case 'submit':\n        return false\n    }\n  }\n  return !!FORM_PRIVATE_TAG_NAMES[element.tagName]\n}\n\n/**\n * Text censoring non-destructively maintains whitespace characters in order to preserve text shape\n * during replay.\n */\nexport const censorText = (text: string) => text.replace(/\\S/g, TEXT_MASKING_CHAR)\n\nexport function getTextContent(\n  textNode: Node,\n  ignoreWhiteSpace: boolean,\n  parentNodePrivacyLevel: NodePrivacyLevel\n): string | undefined {\n  // The parent node may not be a html element which has a tagName attribute.\n  // So just let it be undefined which is ok in this use case.\n  const parentTagName = textNode.parentElement?.tagName\n  let textContent = textNode.textContent || ''\n\n  if (ignoreWhiteSpace && !textContent.trim()) {\n    return\n  }\n\n  const nodePrivacyLevel = parentNodePrivacyLevel\n\n  const isScript = parentTagName === 'SCRIPT'\n\n  if (isScript) {\n    // For perf reasons, we don't record script (heuristic)\n    textContent = CENSORED_STRING_MARK\n  } else if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    // Should never occur, but just in case, we set to CENSORED_MARK.\n    textContent = CENSORED_STRING_MARK\n  } else if (shouldMaskNode(textNode, nodePrivacyLevel)) {\n    if (\n      // Scrambling the child list breaks text nodes for DATALIST/SELECT/OPTGROUP\n      parentTagName === 'DATALIST' ||\n      parentTagName === 'SELECT' ||\n      parentTagName === 'OPTGROUP'\n    ) {\n      if (!textContent.trim()) {\n        return\n      }\n    } else if (parentTagName === 'OPTION') {\n      // <Option> has low entropy in charset + text length, so use `CENSORED_STRING_MARK` when masked\n      textContent = CENSORED_STRING_MARK\n    } else {\n      textContent = censorText(textContent)\n    }\n  }\n  return textContent\n}\n\n/**\n * TODO: Preserve CSS element order, and record the presence of the tag, just don't render\n * We don't need this logic on the recorder side.\n * For security related meta's, customer can mask themmanually given they\n * are easy to identify in the HEAD tag.\n */\nexport function shouldIgnoreElement(element: Element): boolean {\n  if (element.nodeName === 'SCRIPT') {\n    return true\n  }\n\n  if (element.nodeName === 'LINK') {\n    const relAttribute = getLowerCaseAttribute('rel')\n    return (\n      // Link as script - Ignore only when rel=preload, modulepreload or prefetch\n      (/preload|prefetch/i.test(relAttribute) && getLowerCaseAttribute('as') === 'script') ||\n      // Favicons\n      relAttribute === 'shortcut icon' ||\n      relAttribute === 'icon'\n    )\n  }\n\n  if (element.nodeName === 'META') {\n    const nameAttribute = getLowerCaseAttribute('name')\n    const relAttribute = getLowerCaseAttribute('rel')\n    const propertyAttribute = getLowerCaseAttribute('property')\n    return (\n      // Favicons\n      /^msapplication-tile(image|color)$/.test(nameAttribute) ||\n      nameAttribute === 'application-name' ||\n      relAttribute === 'icon' ||\n      relAttribute === 'apple-touch-icon' ||\n      relAttribute === 'shortcut icon' ||\n      // Description\n      nameAttribute === 'keywords' ||\n      nameAttribute === 'description' ||\n      // Social\n      /^(og|twitter|fb):/.test(propertyAttribute) ||\n      /^(og|twitter):/.test(nameAttribute) ||\n      nameAttribute === 'pinterest' ||\n      // Robots\n      nameAttribute === 'robots' ||\n      nameAttribute === 'googlebot' ||\n      nameAttribute === 'bingbot' ||\n      // Http headers. Ex: X-UA-Compatible, Content-Type, Content-Language, cache-control,\n      // X-Translated-By\n      element.hasAttribute('http-equiv') ||\n      // Authorship\n      nameAttribute === 'author' ||\n      nameAttribute === 'generator' ||\n      nameAttribute === 'framework' ||\n      nameAttribute === 'publisher' ||\n      nameAttribute === 'progid' ||\n      /^article:/.test(propertyAttribute) ||\n      /^product:/.test(propertyAttribute) ||\n      // Verification\n      nameAttribute === 'google-site-verification' ||\n      nameAttribute === 'yandex-verification' ||\n      nameAttribute === 'csrf-token' ||\n      nameAttribute === 'p:domain_verify' ||\n      nameAttribute === 'verify-v1' ||\n      nameAttribute === 'verification' ||\n      nameAttribute === 'shopify-checkout-api-token'\n    )\n  }\n\n  function getLowerCaseAttribute(name: string) {\n    return (element.getAttribute(name) || '').toLowerCase()\n  }\n\n  return false\n}\n\nexport function getPrivacySelector(privacyLevel: string) {\n  return `[${PRIVACY_ATTR_NAME}=\"${privacyLevel}\"], .${PRIVACY_CLASS_PREFIX}${privacyLevel}`\n}\n", "import { safeTruncate } from '@datadog/browser-core'\nimport { NodePrivacyLevel, getPrivacySelector } from '../privacy'\nimport type { RumConfiguration } from '../configuration'\n\n/**\n * Get the action name from the attribute 'data-dd-action-name' on the element or any of its parent.\n * It can also be retrieved from a user defined attribute.\n */\nexport const DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE = 'data-dd-action-name'\nexport const ACTION_NAME_PLACEHOLDER = 'Masked Element'\nexport const enum ActionNameSource {\n  CUSTOM_ATTRIBUTE = 'custom_attribute',\n  MASK_PLACEHOLDER = 'mask_placeholder',\n  TEXT_CONTENT = 'text_content',\n  STANDARD_ATTRIBUTE = 'standard_attribute',\n  BLANK = 'blank',\n}\ntype ActionName = {\n  name: string\n  nameSource: ActionNameSource\n}\n\nexport function getActionNameFromElement(\n  element: Element,\n  { enablePrivacyForActionName, actionNameAttribute: userProgrammaticAttribute }: RumConfiguration,\n  nodePrivacyLevel?: NodePrivacyLevel\n): ActionName {\n  // Proceed to get the action name in two steps:\n  // * first, get the name programmatically, explicitly defined by the user.\n  // * then, if privacy is set to mask, return a placeholder for the undefined.\n  // * if privacy is not set to mask, use strategies that are known to return good results.\n  //   Those strategies will be used on the element and a few parents, but it's likely that they won't succeed at all.\n  // * if no name is found this way, use strategies returning less accurate names as a fallback.\n  //   Those are much likely to succeed.\n  const defaultActionName =\n    getActionNameFromElementProgrammatically(element, DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE) ||\n    (userProgrammaticAttribute && getActionNameFromElementProgrammatically(element, userProgrammaticAttribute))\n\n  if (defaultActionName) {\n    return { name: defaultActionName, nameSource: ActionNameSource.CUSTOM_ATTRIBUTE }\n  } else if (nodePrivacyLevel === NodePrivacyLevel.MASK) {\n    return { name: ACTION_NAME_PLACEHOLDER, nameSource: ActionNameSource.MASK_PLACEHOLDER }\n  }\n\n  return (\n    getActionNameFromElementForStrategies(\n      element,\n      userProgrammaticAttribute,\n      priorityStrategies,\n      enablePrivacyForActionName\n    ) ||\n    getActionNameFromElementForStrategies(\n      element,\n      userProgrammaticAttribute,\n      fallbackStrategies,\n      enablePrivacyForActionName\n    ) || { name: '', nameSource: ActionNameSource.BLANK }\n  )\n}\n\nfunction getActionNameFromElementProgrammatically(targetElement: Element, programmaticAttribute: string) {\n  // We don't use getActionNameFromElementForStrategies here, because we want to consider all parents,\n  // without limit. It is up to the user to declare a relevant naming strategy.\n  const elementWithAttribute = targetElement.closest(`[${programmaticAttribute}]`)\n\n  if (!elementWithAttribute) {\n    return\n  }\n  const name = elementWithAttribute.getAttribute(programmaticAttribute)!\n  return truncate(normalizeWhitespace(name.trim()))\n}\n\ntype NameStrategy = (\n  element: Element | HTMLElement | HTMLInputElement | HTMLSelectElement,\n  userProgrammaticAttribute: string | undefined,\n  privacyEnabledActionName?: boolean\n) => ActionName | undefined | null\n\nconst priorityStrategies: NameStrategy[] = [\n  // associated LABEL text\n  (element, userProgrammaticAttribute) => {\n    if ('labels' in element && element.labels && element.labels.length > 0) {\n      return getActionNameFromTextualContent(element.labels[0], userProgrammaticAttribute)\n    }\n  },\n  // INPUT button (and associated) value\n  (element) => {\n    if (element.nodeName === 'INPUT') {\n      const input = element as HTMLInputElement\n      const type = input.getAttribute('type')\n      if (type === 'button' || type === 'submit' || type === 'reset') {\n        return { name: input.value, nameSource: ActionNameSource.TEXT_CONTENT }\n      }\n    }\n  },\n  // BUTTON, LABEL or button-like element text\n  (element, userProgrammaticAttribute, privacyEnabledActionName) => {\n    if (element.nodeName === 'BUTTON' || element.nodeName === 'LABEL' || element.getAttribute('role') === 'button') {\n      return getActionNameFromTextualContent(element, userProgrammaticAttribute, privacyEnabledActionName)\n    }\n  },\n  (element) => getActionNameFromStandardAttribute(element, 'aria-label'),\n  // associated element text designated by the aria-labelledby attribute\n  (element, userProgrammaticAttribute, privacyEnabledActionName) => {\n    const labelledByAttribute = element.getAttribute('aria-labelledby')\n    if (labelledByAttribute) {\n      return {\n        name: labelledByAttribute\n          .split(/\\s+/)\n          .map((id) => getElementById(element, id))\n          .filter((label): label is HTMLElement => Boolean(label))\n          .map((element) => getTextualContent(element, userProgrammaticAttribute, privacyEnabledActionName))\n          .join(' '),\n        nameSource: ActionNameSource.TEXT_CONTENT,\n      }\n    }\n  },\n  (element) => getActionNameFromStandardAttribute(element, 'alt'),\n  (element) => getActionNameFromStandardAttribute(element, 'name'),\n  (element) => getActionNameFromStandardAttribute(element, 'title'),\n  (element) => getActionNameFromStandardAttribute(element, 'placeholder'),\n  // SELECT first OPTION text\n  (element, userProgrammaticAttribute) => {\n    if ('options' in element && element.options.length > 0) {\n      return getActionNameFromTextualContent(element.options[0], userProgrammaticAttribute)\n    }\n  },\n]\n\nconst fallbackStrategies: NameStrategy[] = [\n  (element, userProgrammaticAttribute, privacyEnabledActionName) =>\n    getActionNameFromTextualContent(element, userProgrammaticAttribute, privacyEnabledActionName),\n]\n\n/**\n * Iterates over the target element and its parent, using the strategies list to get an action name.\n * Each strategies are applied on each element, stopping as soon as a non-empty value is returned.\n */\nconst MAX_PARENTS_TO_CONSIDER = 10\nfunction getActionNameFromElementForStrategies(\n  targetElement: Element,\n  userProgrammaticAttribute: string | undefined,\n  strategies: NameStrategy[],\n  privacyEnabledActionName?: boolean\n) {\n  let element: Element | null = targetElement\n  let recursionCounter = 0\n  while (\n    recursionCounter <= MAX_PARENTS_TO_CONSIDER &&\n    element &&\n    element.nodeName !== 'BODY' &&\n    element.nodeName !== 'HTML' &&\n    element.nodeName !== 'HEAD'\n  ) {\n    for (const strategy of strategies) {\n      const actionName = strategy(element, userProgrammaticAttribute, privacyEnabledActionName)\n      if (actionName) {\n        const { name, nameSource } = actionName\n        const trimmedName = name && name.trim()\n        if (trimmedName) {\n          return { name: truncate(normalizeWhitespace(trimmedName)), nameSource }\n        }\n      }\n    }\n    // Consider a FORM as a contextual limit to get the action name.  This is experimental and may\n    // be reconsidered in the future.\n    if (element.nodeName === 'FORM') {\n      break\n    }\n    element = element.parentElement\n    recursionCounter += 1\n  }\n}\n\nfunction normalizeWhitespace(s: string) {\n  return s.replace(/\\s+/g, ' ')\n}\n\nfunction truncate(s: string) {\n  return s.length > 100 ? `${safeTruncate(s, 100)} [...]` : s\n}\n\nfunction getElementById(refElement: Element, id: string) {\n  // Use the element ownerDocument here, because tests are executed in an iframe, so\n  // document.getElementById won't work.\n  return refElement.ownerDocument ? refElement.ownerDocument.getElementById(id) : null\n}\n\nfunction getActionNameFromStandardAttribute(element: Element | HTMLElement, attribute: string): ActionName {\n  return {\n    name: element.getAttribute(attribute) || '',\n    nameSource: ActionNameSource.STANDARD_ATTRIBUTE,\n  }\n}\n\nfunction getActionNameFromTextualContent(\n  element: Element | HTMLElement,\n  userProgrammaticAttribute: string | undefined,\n  privacyEnabledActionName?: boolean\n): ActionName {\n  return {\n    name: getTextualContent(element, userProgrammaticAttribute, privacyEnabledActionName) || '',\n    nameSource: ActionNameSource.TEXT_CONTENT,\n  }\n}\n\nfunction getTextualContent(\n  element: Element | HTMLElement,\n  userProgrammaticAttribute: string | undefined,\n  privacyEnabledActionName?: boolean\n) {\n  if ((element as HTMLElement).isContentEditable) {\n    return\n  }\n\n  if ('innerText' in element) {\n    let text = element.innerText\n\n    const removeTextFromElements = (query: string) => {\n      const list = element.querySelectorAll<Element | HTMLElement>(query)\n      for (let index = 0; index < list.length; index += 1) {\n        const element = list[index]\n        if ('innerText' in element) {\n          const textToReplace = element.innerText\n          if (textToReplace && textToReplace.trim().length > 0) {\n            text = text.replace(textToReplace, '')\n          }\n        }\n      }\n    }\n\n    // remove the text of elements with programmatic attribute value\n    removeTextFromElements(`[${DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE}]`)\n\n    if (userProgrammaticAttribute) {\n      removeTextFromElements(`[${userProgrammaticAttribute}]`)\n    }\n\n    if (privacyEnabledActionName) {\n      // remove the text of elements with privacy override\n      removeTextFromElements(\n        `${getPrivacySelector(NodePrivacyLevel.HIDDEN)}, ${getPrivacySelector(NodePrivacyLevel.MASK)}`\n      )\n    }\n\n    return text\n  }\n\n  return element.textContent\n}\n", "import { DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE } from './action/getActionNameFromElement'\n\n/**\n * Stable attributes are attributes that are commonly used to identify parts of a UI (ex:\n * component). Those attribute values should not be generated randomly (hardcoded most of the time)\n * and stay the same across deploys. They are not necessarily unique across the document.\n */\nexport const STABLE_ATTRIBUTES = [\n  DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE,\n  // Common test attributes (list provided by google recorder)\n  'data-testid',\n  'data-test',\n  'data-qa',\n  'data-cy',\n  'data-test-id',\n  'data-qa-id',\n  'data-testing',\n  // FullStory decorator attributes:\n  'data-component',\n  'data-element',\n  'data-source-file',\n]\n\ntype SelectorGetter = (element: Element, actionNameAttribute: string | undefined) => string | undefined\n\n// Selectors to use if they target a single element on the whole document. Those selectors are\n// considered as \"stable\" and uniquely identify an element regardless of the page state. If we find\n// one, we should consider the selector \"complete\" and stop iterating over ancestors.\nconst GLOBALLY_UNIQUE_SELECTOR_GETTERS: SelectorGetter[] = [getStableAttributeSelector, getIDSelector]\n\n// Selectors to use if they target a single element among an element descendants. Those selectors\n// are more brittle than \"globally unique\" selectors and should be combined with ancestor selectors\n// to improve specificity.\nconst UNIQUE_AMONG_CHILDREN_SELECTOR_GETTERS: SelectorGetter[] = [\n  getStableAttributeSelector,\n  getClassSelector,\n  getTagNameSelector,\n]\n\nexport function getSelectorFromElement(\n  targetElement: Element,\n  actionNameAttribute: string | undefined\n): string | undefined {\n  if (!targetElement.isConnected) {\n    // We cannot compute a selector for a detached element, as we don't have access to all of its\n    // parents, and we cannot determine if it's unique in the document.\n    return\n  }\n  let targetElementSelector: string | undefined\n  let currentElement: Element | null = targetElement\n\n  while (currentElement && currentElement.nodeName !== 'HTML') {\n    const globallyUniqueSelector = findSelector(\n      currentElement,\n      GLOBALLY_UNIQUE_SELECTOR_GETTERS,\n      isSelectorUniqueGlobally,\n      actionNameAttribute,\n      targetElementSelector\n    )\n    if (globallyUniqueSelector) {\n      return globallyUniqueSelector\n    }\n\n    const uniqueSelectorAmongChildren = findSelector(\n      currentElement,\n      UNIQUE_AMONG_CHILDREN_SELECTOR_GETTERS,\n      isSelectorUniqueAmongSiblings,\n      actionNameAttribute,\n      targetElementSelector\n    )\n    targetElementSelector =\n      uniqueSelectorAmongChildren || combineSelector(getPositionSelector(currentElement), targetElementSelector)\n\n    currentElement = currentElement.parentElement\n  }\n\n  return targetElementSelector\n}\n\nfunction isGeneratedValue(value: string) {\n  // To compute the \"URL path group\", the backend replaces every URL path parts as a question mark\n  // if it thinks the part is an identifier. The condition it uses is to checks whether a digit is\n  // present.\n  //\n  // Here, we use the same strategy: if the value contains a digit, we consider it generated. This\n  // strategy might be a bit naive and fail in some cases, but there are many fallbacks to generate\n  // CSS selectors so it should be fine most of the time.\n  return /[0-9]/.test(value)\n}\n\nfunction getIDSelector(element: Element): string | undefined {\n  if (element.id && !isGeneratedValue(element.id)) {\n    return `#${CSS.escape(element.id)}`\n  }\n}\n\nfunction getClassSelector(element: Element): string | undefined {\n  if (element.tagName === 'BODY') {\n    return\n  }\n  const classList = element.classList\n  for (let i = 0; i < classList.length; i += 1) {\n    const className = classList[i]\n    if (isGeneratedValue(className)) {\n      continue\n    }\n\n    return `${CSS.escape(element.tagName)}.${CSS.escape(className)}`\n  }\n}\n\nfunction getTagNameSelector(element: Element): string {\n  return CSS.escape(element.tagName)\n}\n\nfunction getStableAttributeSelector(element: Element, actionNameAttribute: string | undefined): string | undefined {\n  if (actionNameAttribute) {\n    const selector = getAttributeSelector(actionNameAttribute)\n    if (selector) {\n      return selector\n    }\n  }\n\n  for (const attributeName of STABLE_ATTRIBUTES) {\n    const selector = getAttributeSelector(attributeName)\n    if (selector) {\n      return selector\n    }\n  }\n\n  function getAttributeSelector(attributeName: string) {\n    if (element.hasAttribute(attributeName)) {\n      return `${CSS.escape(element.tagName)}[${attributeName}=\"${CSS.escape(element.getAttribute(attributeName)!)}\"]`\n    }\n  }\n}\n\nfunction getPositionSelector(element: Element): string {\n  let sibling = element.parentElement!.firstElementChild\n  let elementIndex = 1\n\n  while (sibling && sibling !== element) {\n    if (sibling.tagName === element.tagName) {\n      elementIndex += 1\n    }\n    sibling = sibling.nextElementSibling\n  }\n\n  return `${CSS.escape(element.tagName)}:nth-of-type(${elementIndex})`\n}\n\nfunction findSelector(\n  element: Element,\n  selectorGetters: SelectorGetter[],\n  predicate: (element: Element, elementSelector: string, childSelector: string | undefined) => boolean,\n  actionNameAttribute: string | undefined,\n  childSelector: string | undefined\n) {\n  for (const selectorGetter of selectorGetters) {\n    const elementSelector = selectorGetter(element, actionNameAttribute)\n    if (!elementSelector) {\n      continue\n    }\n    if (predicate(element, elementSelector, childSelector)) {\n      return combineSelector(elementSelector, childSelector)\n    }\n  }\n}\n\n/**\n * Check whether the selector is unique among the whole document.\n */\nfunction isSelectorUniqueGlobally(\n  element: Element,\n  elementSelector: string,\n  childSelector: string | undefined\n): boolean {\n  return element.ownerDocument.querySelectorAll(combineSelector(elementSelector, childSelector)).length === 1\n}\n\n/**\n * Check whether the selector is unique among the element siblings. In other words, it returns true\n * if \"ELEMENT_PARENT > CHILD_SELECTOR\" returns a single element.\n *\n * @param {Element} currentElement - the element being considered while iterating over the target\n * element ancestors.\n *\n * @param {string} currentElementSelector - a selector that matches the current element. That\n * selector is not a composed selector (i.e. it might be a single tag name, class name...).\n *\n * @param {string|undefined} childSelector - child selector is a selector that targets a descendant\n * of the current element. When undefined, the current element is the target element.\n *\n * # Scope selector usage\n *\n * When composed together, the final selector will be joined with `>` operators to make sure we\n * target direct descendants at each level. In this function, we'll use `querySelector` to check if\n * a selector matches descendants of the current element. But by default, the query selector match\n * elements at any level. Example:\n *\n * ```html\n * <main>\n *   <div>\n *     <span></span>\n *   </div>\n *   <marquee>\n *     <div>\n *       <span></span>\n *     </div>\n *   </marquee>\n * </main>\n * ```\n *\n * `sibling.querySelector('DIV > SPAN')` will match both span elements, so we would consider the\n * selector to be not unique, even if it is unique when we'll compose it with the parent with a `>`\n * operator (`MAIN > DIV > SPAN`).\n *\n * To avoid this, we can use the `:scope` selector to make sure the selector starts from the current\n * sibling (i.e. `sibling.querySelector('DIV:scope > SPAN')` will only match the first span).\n *\n * [1]: https://developer.mozilla.org/fr/docs/Web/CSS/:scope\n *\n * # Performance considerations\n *\n * We compute selectors in performance-critical operations (ex: during a click), so we need to make\n * sure the function is as fast as possible. We observed that naively using `querySelectorAll` to\n * check if the selector matches more than 1 element is quite expensive, so we want to avoid it.\n *\n * Because we are iterating the DOM upward and we use that function at every level, we know the\n * child selector is already unique among the current element children, so we don't need to check\n * for the current element subtree.\n *\n * Instead, we can focus on the current element siblings. If we find a single element matching the\n * selector within a sibling, we know that it's not unique. This allows us to use `querySelector`\n * (or `matches`, when the current element is the target element) instead of `querySelectorAll`.\n */\nexport function isSelectorUniqueAmongSiblings(\n  currentElement: Element,\n  currentElementSelector: string,\n  childSelector: string | undefined\n): boolean {\n  let isSiblingMatching: (sibling: Element) => boolean\n\n  if (childSelector === undefined) {\n    // If the child selector is undefined (meaning `currentElement` is the target element, not one\n    // of its ancestor), we need to use `matches` to check if the sibling is matching the selector,\n    // as `querySelector` only returns a descendant of the element.\n    isSiblingMatching = (sibling) => sibling.matches(currentElementSelector)\n  } else {\n    const scopedSelector = combineSelector(`${currentElementSelector}:scope`, childSelector)\n    isSiblingMatching = (sibling) => sibling.querySelector(scopedSelector) !== null\n  }\n\n  const parent = currentElement.parentElement!\n  let sibling = parent.firstElementChild\n  while (sibling) {\n    if (sibling !== currentElement && isSiblingMatching(sibling)) {\n      return false\n    }\n    sibling = sibling.nextElementSibling\n  }\n\n  return true\n}\n\nfunction combineSelector(parent: string, child: string | undefined): string {\n  return child ? `${parent}>${child}` : parent\n}\n", "import type { TimeoutId } from '@datadog/browser-core'\nimport { ONE_SECOND, clearTimeout, setTimeout } from '@datadog/browser-core'\nimport type { Click } from './trackClickActions'\n\nexport interface ClickChain {\n  tryAppend: (click: Click) => boolean\n  stop: () => void\n}\n\nexport const MAX_DURATION_BETWEEN_CLICKS = ONE_SECOND\nexport const MAX_DISTANCE_BETWEEN_CLICKS = 100\n\nconst enum ClickChainStatus {\n  WaitingForMoreClicks,\n  WaitingForClicksToStop,\n  Finalized,\n}\n\nexport function createClickChain(firstClick: Click, onFinalize: (clicks: Click[]) => void): ClickChain {\n  const bufferedClicks: Click[] = []\n  let status = ClickChainStatus.WaitingForMoreClicks\n  let maxDurationBetweenClicksTimeoutId: TimeoutId | undefined\n  appendClick(firstClick)\n\n  function appendClick(click: Click) {\n    click.stopObservable.subscribe(tryFinalize)\n    bufferedClicks.push(click)\n    clearTimeout(maxDurationBetweenClicksTimeoutId)\n    maxDurationBetweenClicksTimeoutId = setTimeout(dontAcceptMoreClick, MAX_DURATION_BETWEEN_CLICKS)\n  }\n\n  function tryFinalize() {\n    if (status === ClickChainStatus.WaitingForClicksToStop && bufferedClicks.every((click) => click.isStopped())) {\n      status = ClickChainStatus.Finalized\n      onFinalize(bufferedClicks)\n    }\n  }\n\n  function dontAcceptMoreClick() {\n    clearTimeout(maxDurationBetweenClicksTimeoutId)\n    if (status === ClickChainStatus.WaitingForMoreClicks) {\n      status = ClickChainStatus.WaitingForClicksToStop\n      tryFinalize()\n    }\n  }\n\n  return {\n    tryAppend: (click) => {\n      if (status !== ClickChainStatus.WaitingForMoreClicks) {\n        return false\n      }\n\n      if (\n        bufferedClicks.length > 0 &&\n        !areEventsSimilar(bufferedClicks[bufferedClicks.length - 1].event, click.event)\n      ) {\n        dontAcceptMoreClick()\n        return false\n      }\n\n      appendClick(click)\n      return true\n    },\n    stop: () => {\n      dontAcceptMoreClick()\n    },\n  }\n}\n\n/**\n * Checks whether two events are similar by comparing their target, position and timestamp\n */\nfunction areEventsSimilar(first: MouseEvent, second: MouseEvent) {\n  return (\n    first.target === second.target &&\n    mouseEventDistance(first, second) <= MAX_DISTANCE_BETWEEN_CLICKS &&\n    first.timeStamp - second.timeStamp <= MAX_DURATION_BETWEEN_CLICKS\n  )\n}\n\nfunction mouseEventDistance(origin: MouseEvent, other: MouseEvent) {\n  return Math.sqrt(Math.pow(origin.clientX - other.clientX, 2) + Math.pow(origin.clientY - other.clientY, 2))\n}\n", "import { addEventListener, DOM_EVENT } from '@datadog/browser-core'\nimport type { RelativeTime } from '@datadog/browser-core'\nimport type { RumConfiguration } from '../configuration'\n\nexport type ExtraPointerEventFields = {\n  target: Element\n  timeStamp: RelativeTime\n}\nexport type MouseEventOnElement = PointerEvent & ExtraPointerEventFields\n\nexport interface UserActivity {\n  selection: boolean\n  input: boolean\n  scroll: boolean\n}\nexport interface ActionEventsHooks<ClickContext> {\n  onPointerDown: (event: MouseEventOnElement) => ClickContext | undefined\n  onPointerUp: (context: ClickContext, event: MouseEventOnElement, getUserActivity: () => UserActivity) => void\n}\n\nexport function listenActionEvents<ClickContext>(\n  configuration: RumConfiguration,\n  { onPointerDown, onPointerUp }: ActionEventsHooks<ClickContext>\n) {\n  let selectionEmptyAtPointerDown: boolean\n  let userActivity: UserActivity = {\n    selection: false,\n    input: false,\n    scroll: false,\n  }\n  let clickContext: ClickContext | undefined\n\n  const listeners = [\n    addEventListener(\n      configuration,\n      window,\n      DOM_EVENT.POINTER_DOWN,\n      (event: PointerEvent) => {\n        if (isValidPointerEvent(event)) {\n          selectionEmptyAtPointerDown = isSelectionEmpty()\n          userActivity = {\n            selection: false,\n            input: false,\n            scroll: false,\n          }\n          clickContext = onPointerDown(event)\n        }\n      },\n      { capture: true }\n    ),\n\n    addEventListener(\n      configuration,\n      window,\n      DOM_EVENT.SELECTION_CHANGE,\n      () => {\n        if (!selectionEmptyAtPointerDown || !isSelectionEmpty()) {\n          userActivity.selection = true\n        }\n      },\n      { capture: true }\n    ),\n\n    addEventListener(\n      configuration,\n      window,\n      DOM_EVENT.SCROLL,\n      () => {\n        userActivity.scroll = true\n      },\n      { capture: true, passive: true }\n    ),\n\n    addEventListener(\n      configuration,\n      window,\n      DOM_EVENT.POINTER_UP,\n      (event: PointerEvent) => {\n        if (isValidPointerEvent(event) && clickContext) {\n          // Use a scoped variable to make sure the value is not changed by other clicks\n          const localUserActivity = userActivity\n          onPointerUp(clickContext, event, () => localUserActivity)\n          clickContext = undefined\n        }\n      },\n      { capture: true }\n    ),\n\n    addEventListener(\n      configuration,\n      window,\n      DOM_EVENT.INPUT,\n      () => {\n        userActivity.input = true\n      },\n      { capture: true }\n    ),\n  ]\n\n  return {\n    stop: () => {\n      listeners.forEach((listener) => listener.stop())\n    },\n  }\n}\n\nfunction isSelectionEmpty(): boolean {\n  const selection = window.getSelection()\n  return !selection || selection.isCollapsed\n}\n\nfunction isValidPointerEvent(event: PointerEvent): event is MouseEventOnElement {\n  return (\n    event.target instanceof Element &&\n    // Only consider 'primary' pointer events for now. Multi-touch support could be implemented in\n    // the future.\n    event.isPrimary !== false\n  )\n}\n", "import { ONE_SECOND } from '@datadog/browser-core'\nimport { FrustrationType } from '../../rawRumEvent.types'\nimport type { Click } from './trackClickActions'\n\nconst MIN_CLICKS_PER_SECOND_TO_CONSIDER_RAGE = 3\n\nexport function computeFrustration(clicks: Click[], rageClick: Click) {\n  if (isRage(clicks)) {\n    rageClick.addFrustration(FrustrationType.RAGE_CLICK)\n    if (clicks.some(isDead)) {\n      rageClick.addFrustration(FrustrationType.DEAD_CLICK)\n    }\n    if (rageClick.hasError) {\n      rageClick.addFrustration(FrustrationType.ERROR_CLICK)\n    }\n    return { isRage: true }\n  }\n\n  const hasSelectionChanged = clicks.some((click) => click.getUserActivity().selection)\n  clicks.forEach((click) => {\n    if (click.hasError) {\n      click.addFrustration(FrustrationType.ERROR_CLICK)\n    }\n    if (\n      isDead(click) &&\n      // Avoid considering clicks part of a double-click or triple-click selections as dead clicks\n      !hasSelectionChanged\n    ) {\n      click.addFrustration(FrustrationType.DEAD_CLICK)\n    }\n  })\n  return { isRage: false }\n}\n\nexport function isRage(clicks: Click[]) {\n  if (clicks.some((click) => click.getUserActivity().selection || click.getUserActivity().scroll)) {\n    return false\n  }\n  for (let i = 0; i < clicks.length - (MIN_CLICKS_PER_SECOND_TO_CONSIDER_RAGE - 1); i += 1) {\n    if (\n      clicks[i + MIN_CLICKS_PER_SECOND_TO_CONSIDER_RAGE - 1].event.timeStamp - clicks[i].event.timeStamp <=\n      ONE_SECOND\n    ) {\n      return true\n    }\n  }\n  return false\n}\n\nconst DEAD_CLICK_EXCLUDE_SELECTOR =\n  // inputs that don't trigger a meaningful event like \"input\" when clicked, including textual\n  // inputs (using a negative selector is shorter here)\n  'input:not([type=\"checkbox\"]):not([type=\"radio\"]):not([type=\"button\"]):not([type=\"submit\"]):not([type=\"reset\"]):not([type=\"range\"]),' +\n  'textarea,' +\n  'select,' +\n  // contenteditable and their descendants don't always trigger meaningful changes when manipulated\n  '[contenteditable],' +\n  '[contenteditable] *,' +\n  // canvas, as there is no good way to detect activity occurring on them\n  'canvas,' +\n  // links that are interactive (have an href attribute) or any of their descendants, as they can\n  // open a new tab or navigate to a hash without triggering a meaningful event\n  'a[href],' +\n  'a[href] *'\n\nexport function isDead(click: Click) {\n  if (click.hasPageActivity || click.getUserActivity().input || click.getUserActivity().scroll) {\n    return false\n  }\n\n  let target: Element | null = click.event.target\n\n  if (target.tagName === 'LABEL' && target.hasAttribute('for')) {\n    target = document.getElementById(target.getAttribute('for')!)\n  }\n\n  return !target || !target.matches(DEAD_CLICK_EXCLUDE_SELECTOR)\n}\n", "import { elapsed, ONE_SECOND, relativeNow } from '@datadog/browser-core'\nimport type { RelativeTime } from '@datadog/browser-core'\n\n// Maximum duration for click actions\nexport const CLICK_ACTION_MAX_DURATION = 10 * ONE_SECOND\nexport const interactionSelectorCache = new Map<RelativeTime, string>()\n\nexport function getInteractionSelector(relativeTimestamp: RelativeTime) {\n  const selector = interactionSelectorCache.get(relativeTimestamp)\n  interactionSelectorCache.delete(relativeTimestamp)\n  return selector\n}\n\nexport function updateInteractionSelector(relativeTimestamp: RelativeTime, selector: string) {\n  interactionSelectorCache.set(relativeTimestamp, selector)\n  interactionSelectorCache.forEach((_, relativeTimestamp) => {\n    if (elapsed(relativeTimestamp, relativeNow()) > CLICK_ACTION_MAX_DURATION) {\n      interactionSelectorCache.delete(relativeTimestamp)\n    }\n  })\n}\n", "import type { Duration, ClocksState, RelativeTime, TimeStamp, ValueHistory } from '@datadog/browser-core'\nimport {\n  timeStampNow,\n  Observable,\n  getRelativeTime,\n  ONE_MINUTE,\n  generateUUID,\n  clocksNow,\n  elapsed,\n  createValueHistory,\n  PageExitReason,\n} from '@datadog/browser-core'\nimport type { FrustrationType } from '../../rawRumEvent.types'\nimport { ActionType } from '../../rawRumEvent.types'\nimport type { LifeCycle } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\nimport { trackEventCounts } from '../trackEventCounts'\nimport { PAGE_ACTIVITY_VALIDATION_DELAY, waitPageActivityEnd } from '../waitPageActivityEnd'\nimport { getSelectorFromElement } from '../getSelectorFromElement'\nimport { getNodePrivacyLevel, NodePrivacyLevel } from '../privacy'\nimport type { RumConfiguration } from '../configuration'\nimport type { RumMutationRecord } from '../../browser/domMutationObservable'\nimport type { ClickChain } from './clickChain'\nimport { createClickChain } from './clickChain'\nimport { getActionNameFromElement } from './getActionNameFromElement'\nimport type { MouseEventOnElement, UserActivity } from './listenActionEvents'\nimport { listenActionEvents } from './listenActionEvents'\nimport { computeFrustration } from './computeFrustration'\nimport { CLICK_ACTION_MAX_DURATION, updateInteractionSelector } from './interactionSelectorCache'\n\ninterface ActionCounts {\n  errorCount: number\n  longTaskCount: number\n  resourceCount: number\n}\n\nexport interface ClickAction {\n  type: typeof ActionType.CLICK\n  id: string\n  name: string\n  nameSource: string\n  target?: {\n    selector: string | undefined\n    width: number\n    height: number\n  }\n  position?: { x: number; y: number }\n  startClocks: ClocksState\n  duration?: Duration\n  counts: ActionCounts\n  event: MouseEventOnElement\n  frustrationTypes: FrustrationType[]\n  events: Event[]\n}\n\nexport interface ActionContexts {\n  findActionId: (startTime?: RelativeTime) => string | string[] | undefined\n}\n\ntype ClickActionIdHistory = ValueHistory<ClickAction['id']>\n\nexport const ACTION_CONTEXT_TIME_OUT_DELAY = 5 * ONE_MINUTE // arbitrary\n\nexport function trackClickActions(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<RumMutationRecord[]>,\n  windowOpenObservable: Observable<void>,\n  configuration: RumConfiguration\n) {\n  const history: ClickActionIdHistory = createValueHistory({ expireDelay: ACTION_CONTEXT_TIME_OUT_DELAY })\n  const stopObservable = new Observable<void>()\n  let currentClickChain: ClickChain | undefined\n\n  lifeCycle.subscribe(LifeCycleEventType.SESSION_RENEWED, () => {\n    history.reset()\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.VIEW_ENDED, stopClickChain)\n  lifeCycle.subscribe(LifeCycleEventType.PAGE_MAY_EXIT, (event) => {\n    if (event.reason === PageExitReason.UNLOADING) {\n      stopClickChain()\n    }\n  })\n\n  const { stop: stopActionEventsListener } = listenActionEvents<{\n    clickActionBase: ClickActionBase\n    hadActivityOnPointerDown: () => boolean\n  }>(configuration, {\n    onPointerDown: (pointerDownEvent) =>\n      processPointerDown(configuration, lifeCycle, domMutationObservable, pointerDownEvent, windowOpenObservable),\n    onPointerUp: ({ clickActionBase, hadActivityOnPointerDown }, startEvent, getUserActivity) => {\n      startClickAction(\n        configuration,\n        lifeCycle,\n        domMutationObservable,\n        windowOpenObservable,\n        history,\n        stopObservable,\n        appendClickToClickChain,\n        clickActionBase,\n        startEvent,\n        getUserActivity,\n        hadActivityOnPointerDown\n      )\n    },\n  })\n\n  const actionContexts: ActionContexts = {\n    findActionId: (startTime?: RelativeTime) => history.findAll(startTime),\n  }\n\n  return {\n    stop: () => {\n      stopClickChain()\n      stopObservable.notify()\n      stopActionEventsListener()\n    },\n    actionContexts,\n  }\n\n  function appendClickToClickChain(click: Click) {\n    if (!currentClickChain || !currentClickChain.tryAppend(click)) {\n      const rageClick = click.clone()\n      currentClickChain = createClickChain(click, (clicks) => {\n        finalizeClicks(clicks, rageClick)\n      })\n    }\n  }\n\n  function stopClickChain() {\n    if (currentClickChain) {\n      currentClickChain.stop()\n    }\n  }\n}\n\nfunction processPointerDown(\n  configuration: RumConfiguration,\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<RumMutationRecord[]>,\n  pointerDownEvent: MouseEventOnElement,\n  windowOpenObservable: Observable<void>\n) {\n  const nodePrivacyLevel = configuration.enablePrivacyForActionName\n    ? getNodePrivacyLevel(pointerDownEvent.target, configuration.defaultPrivacyLevel)\n    : NodePrivacyLevel.ALLOW\n\n  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    return undefined\n  }\n\n  const clickActionBase = computeClickActionBase(pointerDownEvent, nodePrivacyLevel, configuration)\n\n  let hadActivityOnPointerDown = false\n\n  waitPageActivityEnd(\n    lifeCycle,\n    domMutationObservable,\n    windowOpenObservable,\n    configuration,\n    (pageActivityEndEvent) => {\n      hadActivityOnPointerDown = pageActivityEndEvent.hadActivity\n    },\n    // We don't care about the activity duration, we just want to know whether an activity did happen\n    // within the \"validation delay\" or not. Limit the duration so the callback is called sooner.\n    PAGE_ACTIVITY_VALIDATION_DELAY\n  )\n\n  return { clickActionBase, hadActivityOnPointerDown: () => hadActivityOnPointerDown }\n}\n\nfunction startClickAction(\n  configuration: RumConfiguration,\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<RumMutationRecord[]>,\n  windowOpenObservable: Observable<void>,\n  history: ClickActionIdHistory,\n  stopObservable: Observable<void>,\n  appendClickToClickChain: (click: Click) => void,\n  clickActionBase: ClickActionBase,\n  startEvent: MouseEventOnElement,\n  getUserActivity: () => UserActivity,\n  hadActivityOnPointerDown: () => boolean\n) {\n  const click = newClick(lifeCycle, history, getUserActivity, clickActionBase, startEvent)\n  appendClickToClickChain(click)\n\n  const selector = clickActionBase?.target?.selector\n  if (selector) {\n    updateInteractionSelector(startEvent.timeStamp, selector)\n  }\n\n  const { stop: stopWaitPageActivityEnd } = waitPageActivityEnd(\n    lifeCycle,\n    domMutationObservable,\n    windowOpenObservable,\n    configuration,\n    (pageActivityEndEvent) => {\n      if (pageActivityEndEvent.hadActivity && pageActivityEndEvent.end < click.startClocks.timeStamp) {\n        // If the clock is looking weird, just discard the click\n        click.discard()\n      } else {\n        if (pageActivityEndEvent.hadActivity) {\n          click.stop(pageActivityEndEvent.end)\n        } else if (hadActivityOnPointerDown()) {\n          click.stop(\n            // using the click start as activity end, so the click will have some activity but its\n            // duration will be 0 (as the activity started before the click start)\n            click.startClocks.timeStamp\n          )\n        } else {\n          click.stop()\n        }\n      }\n    },\n    CLICK_ACTION_MAX_DURATION\n  )\n\n  const viewEndedSubscription = lifeCycle.subscribe(LifeCycleEventType.VIEW_ENDED, ({ endClocks }) => {\n    click.stop(endClocks.timeStamp)\n  })\n\n  const stopSubscription = stopObservable.subscribe(() => {\n    click.stop()\n  })\n\n  click.stopObservable.subscribe(() => {\n    viewEndedSubscription.unsubscribe()\n    stopWaitPageActivityEnd()\n    stopSubscription.unsubscribe()\n  })\n}\n\ntype ClickActionBase = Pick<ClickAction, 'type' | 'name' | 'nameSource' | 'target' | 'position'>\n\nfunction computeClickActionBase(\n  event: MouseEventOnElement,\n  nodePrivacyLevel: NodePrivacyLevel,\n  configuration: RumConfiguration\n): ClickActionBase {\n  const rect = event.target.getBoundingClientRect()\n  const selector = getSelectorFromElement(event.target, configuration.actionNameAttribute)\n  if (selector) {\n    updateInteractionSelector(event.timeStamp, selector)\n  }\n  const actionName = getActionNameFromElement(event.target, configuration, nodePrivacyLevel)\n\n  return {\n    type: ActionType.CLICK,\n    target: {\n      width: Math.round(rect.width),\n      height: Math.round(rect.height),\n      selector,\n    },\n    position: {\n      // Use clientX and Y because for SVG element offsetX and Y are relatives to the <svg> element\n      x: Math.round(event.clientX - rect.left),\n      y: Math.round(event.clientY - rect.top),\n    },\n    name: actionName.name,\n    nameSource: actionName.nameSource,\n  }\n}\n\nconst enum ClickStatus {\n  // Initial state, the click is still ongoing.\n  ONGOING,\n  // The click is no more ongoing but still needs to be validated or discarded.\n  STOPPED,\n  // Final state, the click has been stopped and validated or discarded.\n  FINALIZED,\n}\n\nexport type Click = ReturnType<typeof newClick>\n\nfunction newClick(\n  lifeCycle: LifeCycle,\n  history: ClickActionIdHistory,\n  getUserActivity: () => UserActivity,\n  clickActionBase: ClickActionBase,\n  startEvent: MouseEventOnElement\n) {\n  const id = generateUUID()\n  const startClocks = clocksNow()\n  const historyEntry = history.add(id, startClocks.relative)\n  const eventCountsSubscription = trackEventCounts({\n    lifeCycle,\n    isChildEvent: (event) =>\n      event.action !== undefined &&\n      (Array.isArray(event.action.id) ? event.action.id.includes(id) : event.action.id === id),\n  })\n  let status = ClickStatus.ONGOING\n  let activityEndTime: undefined | TimeStamp\n  const frustrationTypes: FrustrationType[] = []\n  const stopObservable = new Observable<void>()\n\n  function stop(newActivityEndTime?: TimeStamp) {\n    if (status !== ClickStatus.ONGOING) {\n      return\n    }\n    activityEndTime = newActivityEndTime\n    status = ClickStatus.STOPPED\n    if (activityEndTime) {\n      historyEntry.close(getRelativeTime(activityEndTime))\n    } else {\n      historyEntry.remove()\n    }\n    eventCountsSubscription.stop()\n    stopObservable.notify()\n  }\n\n  return {\n    event: startEvent,\n    stop,\n    stopObservable,\n\n    get hasError() {\n      return eventCountsSubscription.eventCounts.errorCount > 0\n    },\n    get hasPageActivity() {\n      return activityEndTime !== undefined\n    },\n    getUserActivity,\n    addFrustration: (frustrationType: FrustrationType) => {\n      frustrationTypes.push(frustrationType)\n    },\n    startClocks,\n\n    isStopped: () => status === ClickStatus.STOPPED || status === ClickStatus.FINALIZED,\n\n    clone: () => newClick(lifeCycle, history, getUserActivity, clickActionBase, startEvent),\n\n    validate: (domEvents?: Event[]) => {\n      stop()\n      if (status !== ClickStatus.STOPPED) {\n        return\n      }\n\n      const { resourceCount, errorCount, longTaskCount } = eventCountsSubscription.eventCounts\n      const clickAction: ClickAction = {\n        duration: activityEndTime && elapsed(startClocks.timeStamp, activityEndTime),\n        startClocks,\n        id,\n        frustrationTypes,\n        counts: {\n          resourceCount,\n          errorCount,\n          longTaskCount,\n        },\n        events: domEvents ?? [startEvent],\n        event: startEvent,\n        ...clickActionBase,\n      }\n\n      lifeCycle.notify(LifeCycleEventType.AUTO_ACTION_COMPLETED, clickAction)\n      status = ClickStatus.FINALIZED\n    },\n\n    discard: () => {\n      stop()\n      status = ClickStatus.FINALIZED\n    },\n  }\n}\n\nexport function finalizeClicks(clicks: Click[], rageClick: Click) {\n  const { isRage } = computeFrustration(clicks, rageClick)\n  if (isRage) {\n    clicks.forEach((click) => click.discard())\n    rageClick.stop(timeStampNow())\n    rageClick.validate(clicks.map((click) => click.event))\n  } else {\n    rageClick.discard()\n    clicks.forEach((click) => click.validate())\n  }\n}\n", "import type { ClocksState, Context, Observable } from '@datadog/browser-core'\nimport { noop, combine, toServerDuration, generateUUID, SKIPPED, HookNames } from '@datadog/browser-core'\nimport { discardNegativeDuration } from '../discardNegativeDuration'\nimport type { RawRumActionEvent } from '../../rawRumEvent.types'\nimport { ActionType, RumEventType } from '../../rawRumEvent.types'\nimport type { LifeCycle, RawRumEventCollectedData } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\nimport type { RumConfiguration } from '../configuration'\nimport type { RumActionEventDomainContext } from '../../domainContext.types'\nimport type { DefaultRumEventAttributes, Hooks } from '../hooks'\nimport type { RumMutationRecord } from '../../browser/domMutationObservable'\nimport type { ActionContexts, ClickAction } from './trackClickActions'\nimport { trackClickActions } from './trackClickActions'\n\nexport type { ActionContexts }\n\nexport interface CustomAction {\n  type: typeof ActionType.CUSTOM\n  name: string\n  startClocks: ClocksState\n  context?: Context\n  handlingStack?: string\n}\n\nexport type AutoAction = ClickAction\n\nexport function startActionCollection(\n  lifeCycle: LifeCycle,\n  hooks: Hooks,\n  domMutationObservable: Observable<RumMutationRecord[]>,\n  windowOpenObservable: Observable<void>,\n  configuration: RumConfiguration\n) {\n  lifeCycle.subscribe(LifeCycleEventType.AUTO_ACTION_COMPLETED, (action) =>\n    lifeCycle.notify(LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, processAction(action))\n  )\n\n  hooks.register(HookNames.Assemble, ({ startTime, eventType }): DefaultRumEventAttributes | SKIPPED => {\n    if (\n      eventType !== RumEventType.ERROR &&\n      eventType !== RumEventType.RESOURCE &&\n      eventType !== RumEventType.LONG_TASK\n    ) {\n      return SKIPPED\n    }\n\n    const actionId = actionContexts.findActionId(startTime)\n    if (!actionId) {\n      return SKIPPED\n    }\n\n    return {\n      type: eventType,\n      action: { id: actionId },\n    }\n  })\n\n  let actionContexts: ActionContexts = { findActionId: noop as () => undefined }\n  let stop: () => void = noop\n\n  if (configuration.trackUserInteractions) {\n    ;({ actionContexts, stop } = trackClickActions(\n      lifeCycle,\n      domMutationObservable,\n      windowOpenObservable,\n      configuration\n    ))\n  }\n\n  return {\n    addAction: (action: CustomAction) => {\n      lifeCycle.notify(LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, processAction(action))\n    },\n    actionContexts,\n    stop,\n  }\n}\n\nfunction processAction(action: AutoAction | CustomAction): RawRumEventCollectedData<RawRumActionEvent> {\n  const autoActionProperties = isAutoAction(action)\n    ? {\n        action: {\n          id: action.id,\n          loading_time: discardNegativeDuration(toServerDuration(action.duration)),\n          frustration: {\n            type: action.frustrationTypes,\n          },\n          error: {\n            count: action.counts.errorCount,\n          },\n          long_task: {\n            count: action.counts.longTaskCount,\n          },\n          resource: {\n            count: action.counts.resourceCount,\n          },\n        },\n        _dd: {\n          action: {\n            target: action.target,\n            position: action.position,\n            name_source: action.nameSource,\n          },\n        },\n      }\n    : undefined\n  const actionEvent: RawRumActionEvent = combine(\n    {\n      action: { id: generateUUID(), target: { name: action.name }, type: action.type },\n      date: action.startClocks.timeStamp,\n      type: RumEventType.ACTION,\n    },\n    autoActionProperties\n  )\n\n  const duration = isAutoAction(action) ? action.duration : undefined\n  const customerContext = !isAutoAction(action) ? action.context : undefined\n  const domainContext: RumActionEventDomainContext = isAutoAction(action)\n    ? { events: action.events }\n    : { handlingStack: action.handlingStack }\n\n  return {\n    customerContext,\n    rawRumEvent: actionEvent,\n    duration,\n    startTime: action.startClocks.relative,\n    domainContext,\n  }\n}\n\nfunction isAutoAction(action: AutoAction | CustomAction): action is AutoAction {\n  return action.type !== ActionType.CUSTOM\n}\n", "import type { Observable, RawError } from '@datadog/browser-core'\nimport { initConsoleObservable, ConsoleApiName } from '@datadog/browser-core'\n\nexport function trackConsoleError(errorObservable: Observable<RawError>) {\n  const subscription = initConsoleObservable([ConsoleApiName.error]).subscribe((consoleLog) =>\n    errorObservable.notify(consoleLog.error)\n  )\n\n  return {\n    stop: () => {\n      subscription.unsubscribe()\n    },\n  }\n}\n", "import type { Observable, RawError } from '@datadog/browser-core'\nimport { initReportObservable, RawReportType } from '@datadog/browser-core'\nimport type { RumConfiguration } from '../configuration'\n\nexport function trackReportError(configuration: RumConfiguration, errorObservable: Observable<RawError>) {\n  const subscription = initReportObservable(configuration, [\n    RawReportType.cspViolation,\n    RawReportType.intervention,\n  ]).subscribe((rawError) => errorObservable.notify(rawError))\n\n  return {\n    stop: () => {\n      subscription.unsubscribe()\n    },\n  }\n}\n", "import type { Context, RawError, ClocksState } from '@datadog/browser-core'\nimport {\n  ErrorSource,\n  generateUUID,\n  computeRawError,\n  ErrorHandling,\n  Observable,\n  trackRuntimeError,\n  NonErrorPrefix,\n  combine,\n} from '@datadog/browser-core'\nimport type { RumConfiguration } from '../configuration'\nimport type { RawRumErrorEvent } from '../../rawRumEvent.types'\nimport { RumEventType } from '../../rawRumEvent.types'\nimport type { LifeCycle, RawRumEventCollectedData } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\nimport type { RumErrorEventDomainContext } from '../../domainContext.types'\nimport { trackConsoleError } from './trackConsoleError'\nimport { trackReportError } from './trackReportError'\n\nexport interface ProvidedError {\n  startClocks: ClocksState\n  error: unknown\n  context?: Context\n  handlingStack: string\n  componentStack?: string\n}\n\nexport function startErrorCollection(lifeCycle: LifeCycle, configuration: RumConfiguration) {\n  const errorObservable = new Observable<RawError>()\n\n  trackConsoleError(errorObservable)\n  trackRuntimeError(errorObservable)\n  trackReportError(configuration, errorObservable)\n\n  errorObservable.subscribe((error) => lifeCycle.notify(LifeCycleEventType.RAW_ERROR_COLLECTED, { error }))\n\n  return doStartErrorCollection(lifeCycle)\n}\n\nexport function doStartErrorCollection(lifeCycle: LifeCycle) {\n  lifeCycle.subscribe(LifeCycleEventType.RAW_ERROR_COLLECTED, ({ error, customerContext }) => {\n    customerContext = combine(error.context, customerContext)\n    lifeCycle.notify(LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, {\n      customerContext,\n      ...processError(error),\n    })\n  })\n\n  return {\n    addError: ({ error, handlingStack, componentStack, startClocks, context: customerContext }: ProvidedError) => {\n      const rawError = computeRawError({\n        originalError: error,\n        handlingStack,\n        componentStack,\n        startClocks,\n        nonErrorPrefix: NonErrorPrefix.PROVIDED,\n        source: ErrorSource.CUSTOM,\n        handling: ErrorHandling.HANDLED,\n      })\n\n      lifeCycle.notify(LifeCycleEventType.RAW_ERROR_COLLECTED, {\n        customerContext,\n        error: rawError,\n      })\n    },\n  }\n}\n\nfunction processError(error: RawError): RawRumEventCollectedData<RawRumErrorEvent> {\n  const rawRumEvent: RawRumErrorEvent = {\n    date: error.startClocks.timeStamp,\n    error: {\n      id: generateUUID(),\n      message: error.message,\n      source: error.source,\n      stack: error.stack,\n      handling_stack: error.handlingStack,\n      component_stack: error.componentStack,\n      type: error.type,\n      handling: error.handling,\n      causes: error.causes,\n      source_type: 'browser',\n      fingerprint: error.fingerprint,\n      csp: error.csp,\n    },\n    type: RumEventType.ERROR,\n  }\n\n  const domainContext: RumErrorEventDomainContext = {\n    error: error.originalError,\n    handlingStack: error.handlingStack,\n  }\n\n  return {\n    rawRumEvent,\n    startTime: error.startClocks.relative,\n    domainContext,\n  }\n}\n", "import type { Duration, RelativeTime } from '@datadog/browser-core'\nimport { addDuration } from '@datadog/browser-core'\nimport type { RumPerformanceResourceTiming } from '../../browser/performanceObservable'\nimport type { RequestCompleteEvent } from '../requestCollection'\nimport { hasValidResourceEntryDuration, hasValidResourceEntryTimings } from './resourceUtils'\n\ninterface Timing {\n  startTime: RelativeTime\n  duration: Duration\n}\n\nconst alreadyMatchedEntries = new WeakSet<PerformanceEntry>()\n\n/**\n * Look for corresponding timing in resource timing buffer\n *\n * Observations:\n * - Timing (start, end) are nested inside the request (start, end)\n * - Some timing can be not exactly nested, being off by < 1 ms\n *\n * Strategy:\n * - from valid nested entries (with 1 ms error margin)\n * - filter out timing that were already matched to a request\n * - then, if a single timing match, return the timing\n * - otherwise we can't decide, return undefined\n */\nexport function matchRequestResourceEntry(request: RequestCompleteEvent) {\n  if (!performance || !('getEntriesByName' in performance)) {\n    return\n  }\n  const sameNameEntries = performance.getEntriesByName(request.url, 'resource') as RumPerformanceResourceTiming[]\n\n  if (!sameNameEntries.length || !('toJSON' in sameNameEntries[0])) {\n    return\n  }\n\n  const candidates = sameNameEntries\n    .filter((entry) => !alreadyMatchedEntries.has(entry))\n    .filter((entry) => hasValidResourceEntryDuration(entry) && hasValidResourceEntryTimings(entry))\n    .filter((entry) =>\n      isBetween(\n        entry,\n        request.startClocks.relative,\n        endTime({ startTime: request.startClocks.relative, duration: request.duration })\n      )\n    )\n\n  if (candidates.length === 1) {\n    alreadyMatchedEntries.add(candidates[0])\n\n    return candidates[0].toJSON() as RumPerformanceResourceTiming\n  }\n\n  return\n}\n\nfunction endTime(timing: Timing) {\n  return addDuration(timing.startTime, timing.duration)\n}\n\nfunction isBetween(timing: Timing, start: RelativeTime, end: RelativeTime) {\n  const errorMargin = 1 as Duration\n  return timing.startTime >= start - errorMargin && endTime(timing) <= addDuration(end, errorMargin)\n}\n", "import type { TimeStamp } from '@datadog/browser-core'\nimport { dateNow, findCommaSeparatedValue, ONE_MINUTE } from '@datadog/browser-core'\nimport { isCommentNode, isTextNode } from '../../browser/htmlDomUtils'\n\ninterface DocumentTraceData {\n  traceId: string\n  traceTime: TimeStamp\n}\n\nexport const INITIAL_DOCUMENT_OUTDATED_TRACE_ID_THRESHOLD = 2 * ONE_MINUTE\n\nexport function getDocumentTraceId(document: Document): string | undefined {\n  const data = getDocumentTraceDataFromMeta(document) || getDocumentTraceDataFromComment(document)\n\n  if (!data || data.traceTime <= dateNow() - INITIAL_DOCUMENT_OUTDATED_TRACE_ID_THRESHOLD) {\n    return undefined\n  }\n\n  return data.traceId\n}\n\nexport function getDocumentTraceDataFromMeta(document: Document): DocumentTraceData | undefined {\n  const traceIdMeta = document.querySelector<HTMLMetaElement>('meta[name=dd-trace-id]')\n  const traceTimeMeta = document.querySelector<HTMLMetaElement>('meta[name=dd-trace-time]')\n  return createDocumentTraceData(traceIdMeta && traceIdMeta.content, traceTimeMeta && traceTimeMeta.content)\n}\n\nexport function getDocumentTraceDataFromComment(document: Document): DocumentTraceData | undefined {\n  const comment = findTraceComment(document)\n  if (!comment) {\n    return undefined\n  }\n  return createDocumentTraceData(\n    findCommaSeparatedValue(comment, 'trace-id'),\n    findCommaSeparatedValue(comment, 'trace-time')\n  )\n}\n\nexport function createDocumentTraceData(\n  traceId: string | undefined | null,\n  rawTraceTime: string | undefined | null\n): DocumentTraceData | undefined {\n  const traceTime = rawTraceTime && (Number(rawTraceTime) as TimeStamp)\n  if (!traceId || !traceTime) {\n    return undefined\n  }\n\n  return {\n    traceId,\n    traceTime,\n  }\n}\n\nexport function findTraceComment(document: Document): string | undefined {\n  // 1. Try to find the comment as a direct child of the document\n  // Note: TSLint advises to use a 'for of', but TS doesn't allow to use 'for of' if the iterated\n  // value is not an array or string (here, a NodeList).\n  for (let i = 0; i < document.childNodes.length; i += 1) {\n    const comment = getTraceCommentFromNode(document.childNodes[i])\n    if (comment) {\n      return comment\n    }\n  }\n\n  // 2. If the comment is placed after the </html> tag, but have some space or new lines before or\n  // after, the DOM parser will lift it (and the surrounding text) at the end of the <body> tag.\n  // Try to look for the comment at the end of the <body> by by iterating over its child nodes in\n  // reverse order, stopping if we come across a non-text node.\n  if (document.body) {\n    for (let i = document.body.childNodes.length - 1; i >= 0; i -= 1) {\n      const node = document.body.childNodes[i]\n      const comment = getTraceCommentFromNode(node)\n      if (comment) {\n        return comment\n      }\n      if (!isTextNode(node)) {\n        break\n      }\n    }\n  }\n}\n\nfunction getTraceCommentFromNode(node: Node | null) {\n  if (node && isCommentNode(node)) {\n    const match = /^\\s*DATADOG;(.*?)\\s*$/.exec(node.data)\n    if (match) {\n      return match[1]\n    }\n  }\n}\n", "import type { RelativeTime, TimeStamp } from '@datadog/browser-core'\nimport { getRelativeTime, isNumber } from '@datadog/browser-core'\nimport {\n  RumPerformanceEntryType,\n  supportPerformanceTimingEvent,\n  type RumPerformanceNavigationTiming,\n} from './performanceObservable'\n\nexport function getNavigationEntry(): RumPerformanceNavigationTiming {\n  if (supportPerformanceTimingEvent(RumPerformanceEntryType.NAVIGATION)) {\n    const navigationEntry = performance.getEntriesByType(\n      RumPerformanceEntryType.NAVIGATION\n    )[0] as unknown as RumPerformanceNavigationTiming\n    if (navigationEntry) {\n      return navigationEntry\n    }\n  }\n\n  const timings = computeTimingsFromDeprecatedPerformanceTiming()\n  const entry: RumPerformanceNavigationTiming = {\n    entryType: RumPerformanceEntryType.NAVIGATION as const,\n    initiatorType: 'navigation' as const,\n    name: window.location.href,\n    startTime: 0 as RelativeTime,\n    duration: timings.loadEventEnd,\n    decodedBodySize: 0,\n    encodedBodySize: 0,\n    transferSize: 0,\n    workerStart: 0 as RelativeTime,\n    toJSON: () => ({ ...entry, toJSON: undefined }),\n    ...timings,\n  }\n\n  return entry\n}\n\nexport type TimingsFromDeprecatedPerformanceTiming = {\n  -readonly [key in keyof Omit<PerformanceTiming, 'toJSON'>]: RelativeTime\n}\n\nexport function computeTimingsFromDeprecatedPerformanceTiming() {\n  const result: Partial<TimingsFromDeprecatedPerformanceTiming> = {}\n  const timing = performance.timing\n\n  for (const key in timing) {\n    if (isNumber(timing[key as keyof PerformanceTiming])) {\n      const numberKey = key as keyof TimingsFromDeprecatedPerformanceTiming\n      const timingElement = timing[numberKey] as TimeStamp\n      result[numberKey] = timingElement === 0 ? (0 as RelativeTime) : getRelativeTime(timingElement)\n    }\n  }\n  return result as TimingsFromDeprecatedPerformanceTiming\n}\n", "import { runOnReadyState } from '@datadog/browser-core'\nimport { RumPerformanceEntryType } from '../../browser/performanceObservable'\nimport type { RumPerformanceResourceTiming } from '../../browser/performanceObservable'\nimport type { RumConfiguration } from '../configuration'\nimport { getDocumentTraceId } from '../tracing/getDocumentTraceId'\nimport { getNavigationEntry } from '../../browser/performanceUtils'\nimport { FAKE_INITIAL_DOCUMENT } from './resourceUtils'\n\nexport function retrieveInitialDocumentResourceTiming(\n  configuration: RumConfiguration,\n  callback: (timing: RumPerformanceResourceTiming) => void,\n  getNavigationEntryImpl = getNavigationEntry\n) {\n  runOnReadyState(configuration, 'interactive', () => {\n    const navigationEntry = getNavigationEntryImpl()\n    const entry: RumPerformanceResourceTiming = Object.assign(navigationEntry.toJSON(), {\n      entryType: RumPerformanceEntryType.RESOURCE as const,\n      initiatorType: FAKE_INITIAL_DOCUMENT,\n      // The ResourceTiming duration entry should be `responseEnd - startTime`. With\n      // NavigationTiming entries, `startTime` is always 0, so set it to `responseEnd`.\n      duration: navigationEntry.responseEnd,\n      traceId: getDocumentTraceId(document),\n      toJSON: () => ({ ...entry, toJSON: undefined }),\n    })\n    callback(entry)\n  })\n}\n", "import type { ClocksState, Duration } from '@datadog/browser-core'\nimport {\n  combine,\n  generateUUID,\n  RequestType,\n  ResourceType,\n  toServerDuration,\n  relativeToClocks,\n  createTaskQueue,\n} from '@datadog/browser-core'\nimport type { RumConfiguration } from '../configuration'\nimport {\n  RumPerformanceEntryType,\n  createPerformanceObservable,\n  type RumPerformanceResourceTiming,\n} from '../../browser/performanceObservable'\nimport type { RumXhrResourceEventDomainContext, RumFetchResourceEventDomainContext } from '../../domainContext.types'\nimport type { RawRumResourceEvent } from '../../rawRumEvent.types'\nimport { RumEventType } from '../../rawRumEvent.types'\nimport { LifeCycleEventType } from '../lifeCycle'\nimport type { RawRumEventCollectedData, LifeCycle } from '../lifeCycle'\nimport type { RequestCompleteEvent } from '../requestCollection'\nimport type { PageStateHistory } from '../contexts/pageStateHistory'\nimport { PageState } from '../contexts/pageStateHistory'\nimport { createSpanIdentifier } from '../tracing/identifier'\nimport { matchRequestResourceEntry } from './matchRequestResourceEntry'\nimport {\n  computeResourceEntryDetails,\n  computeResourceEntryDuration,\n  computeResourceEntryType,\n  computeResourceEntrySize,\n  computeResourceEntryProtocol,\n  computeResourceEntryDeliveryType,\n  isResourceEntryRequestType,\n  sanitizeIfLongDataUrl,\n} from './resourceUtils'\nimport { retrieveInitialDocumentResourceTiming } from './retrieveInitialDocumentResourceTiming'\n\nexport function startResourceCollection(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  pageStateHistory: PageStateHistory,\n  taskQueue = createTaskQueue(),\n  retrieveInitialDocumentResourceTimingImpl = retrieveInitialDocumentResourceTiming\n) {\n  lifeCycle.subscribe(LifeCycleEventType.REQUEST_COMPLETED, (request: RequestCompleteEvent) => {\n    handleResource(() => processRequest(request, configuration, pageStateHistory))\n  })\n\n  const performanceResourceSubscription = createPerformanceObservable(configuration, {\n    type: RumPerformanceEntryType.RESOURCE,\n    buffered: true,\n  }).subscribe((entries) => {\n    for (const entry of entries) {\n      if (!isResourceEntryRequestType(entry)) {\n        handleResource(() => processResourceEntry(entry, configuration))\n      }\n    }\n  })\n\n  retrieveInitialDocumentResourceTimingImpl(configuration, (timing) => {\n    handleResource(() => processResourceEntry(timing, configuration))\n  })\n\n  function handleResource(computeRawEvent: () => RawRumEventCollectedData<RawRumResourceEvent> | undefined) {\n    taskQueue.push(() => {\n      const rawEvent = computeRawEvent()\n      if (rawEvent) {\n        lifeCycle.notify(LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, rawEvent)\n      }\n    })\n  }\n\n  return {\n    stop: () => {\n      performanceResourceSubscription.unsubscribe()\n    },\n  }\n}\n\nfunction processRequest(\n  request: RequestCompleteEvent,\n  configuration: RumConfiguration,\n  pageStateHistory: PageStateHistory\n): RawRumEventCollectedData<RawRumResourceEvent> | undefined {\n  const matchingTiming = matchRequestResourceEntry(request)\n  const startClocks = matchingTiming ? relativeToClocks(matchingTiming.startTime) : request.startClocks\n  const tracingInfo = computeRequestTracingInfo(request, configuration)\n  if (!configuration.trackResources && !tracingInfo) {\n    return\n  }\n\n  const type = request.type === RequestType.XHR ? ResourceType.XHR : ResourceType.FETCH\n\n  const correspondingTimingOverrides = matchingTiming ? computeResourceEntryMetrics(matchingTiming) : undefined\n\n  const duration = matchingTiming\n    ? computeResourceEntryDuration(matchingTiming)\n    : computeRequestDuration(pageStateHistory, startClocks, request.duration)\n\n  const resourceEvent = combine(\n    {\n      date: startClocks.timeStamp,\n      resource: {\n        id: generateUUID(),\n        type,\n        duration: toServerDuration(duration),\n        method: request.method,\n        status_code: request.status,\n        protocol: matchingTiming && computeResourceEntryProtocol(matchingTiming),\n        url: sanitizeIfLongDataUrl(request.url),\n        delivery_type: matchingTiming && computeResourceEntryDeliveryType(matchingTiming),\n      },\n      type: RumEventType.RESOURCE,\n      _dd: {\n        discarded: !configuration.trackResources,\n      },\n    },\n    tracingInfo,\n    correspondingTimingOverrides\n  )\n\n  return {\n    startTime: startClocks.relative,\n    duration,\n    rawRumEvent: resourceEvent,\n    domainContext: {\n      performanceEntry: matchingTiming,\n      xhr: request.xhr,\n      response: request.response,\n      requestInput: request.input,\n      requestInit: request.init,\n      error: request.error,\n      isAborted: request.isAborted,\n      handlingStack: request.handlingStack,\n    } as RumFetchResourceEventDomainContext | RumXhrResourceEventDomainContext,\n  }\n}\n\nfunction processResourceEntry(\n  entry: RumPerformanceResourceTiming,\n  configuration: RumConfiguration\n): RawRumEventCollectedData<RawRumResourceEvent> | undefined {\n  const startClocks = relativeToClocks(entry.startTime)\n  const tracingInfo = computeResourceEntryTracingInfo(entry, configuration)\n  if (!configuration.trackResources && !tracingInfo) {\n    return\n  }\n\n  const type = computeResourceEntryType(entry)\n  const entryMetrics = computeResourceEntryMetrics(entry)\n  const duration = computeResourceEntryDuration(entry)\n\n  const resourceEvent = combine(\n    {\n      date: startClocks.timeStamp,\n      resource: {\n        id: generateUUID(),\n        type,\n        duration: toServerDuration(duration),\n        url: entry.name,\n        status_code: discardZeroStatus(entry.responseStatus),\n        protocol: computeResourceEntryProtocol(entry),\n        delivery_type: computeResourceEntryDeliveryType(entry),\n      },\n      type: RumEventType.RESOURCE,\n      _dd: {\n        discarded: !configuration.trackResources,\n      },\n    },\n    tracingInfo,\n    entryMetrics\n  )\n  return {\n    startTime: startClocks.relative,\n    duration,\n    rawRumEvent: resourceEvent,\n    domainContext: {\n      performanceEntry: entry,\n    },\n  }\n}\n\nfunction computeResourceEntryMetrics(entry: RumPerformanceResourceTiming) {\n  const { renderBlockingStatus } = entry\n  return {\n    resource: {\n      render_blocking_status: renderBlockingStatus,\n      ...computeResourceEntrySize(entry),\n      ...computeResourceEntryDetails(entry),\n    },\n  }\n}\n\nfunction computeRequestTracingInfo(request: RequestCompleteEvent, configuration: RumConfiguration) {\n  const hasBeenTraced = request.traceSampled && request.traceId && request.spanId\n  if (!hasBeenTraced) {\n    return undefined\n  }\n  return {\n    _dd: {\n      span_id: request.spanId!.toString(),\n      trace_id: request.traceId!.toString(),\n      rule_psr: configuration.rulePsr,\n    },\n  }\n}\n\nfunction computeResourceEntryTracingInfo(entry: RumPerformanceResourceTiming, configuration: RumConfiguration) {\n  const hasBeenTraced = entry.traceId\n  if (!hasBeenTraced) {\n    return undefined\n  }\n  return {\n    _dd: {\n      trace_id: entry.traceId,\n      span_id: createSpanIdentifier().toString(),\n      rule_psr: configuration.rulePsr,\n    },\n  }\n}\n\nfunction computeRequestDuration(pageStateHistory: PageStateHistory, startClocks: ClocksState, duration: Duration) {\n  return !pageStateHistory.wasInPageStateDuringPeriod(PageState.FROZEN, startClocks.relative, duration)\n    ? duration\n    : undefined\n}\n\n/**\n * The status is 0 for cross-origin resources without CORS headers, so the status is meaningless, and we shouldn't report it\n * https://developer.mozilla.org/en-US/docs/Web/API/PerformanceResourceTiming/responseStatus#cross-origin_response_status_codes\n */\nfunction discardZeroStatus(statusCode: number | undefined): number | undefined {\n  return statusCode === 0 ? undefined : statusCode\n}\n", "import type { LifeCycle } from '../lifeCycle'\nimport { trackEventCounts } from '../trackEventCounts'\n\nexport function trackViewEventCounts(lifeCycle: LifeCycle, viewId: string, onChange: () => void) {\n  const { stop, eventCounts } = trackEventCounts({\n    lifeCycle,\n    isChildEvent: (event) => event.view.id === viewId,\n    onChange,\n  })\n\n  return {\n    stop,\n    eventCounts,\n  }\n}\n", "import type { Duration, RelativeTime } from '@datadog/browser-core'\nimport { ONE_MINUTE, elapsed, relativeNow } from '@datadog/browser-core'\nimport type { RumPerformancePaintTiming } from '../../../browser/performanceObservable'\nimport { createPerformanceObservable, RumPerformanceEntryType } from '../../../browser/performanceObservable'\nimport type { RumConfiguration } from '../../configuration'\nimport type { FirstHidden } from './trackFirstHidden'\n\n// Discard FCP timings above a certain delay to avoid incorrect data\n// It happens in some cases like sleep mode or some browser implementations\nexport const FCP_MAXIMUM_DELAY = 10 * ONE_MINUTE\n\nexport function trackFirstContentfulPaint(\n  configuration: RumConfiguration,\n  firstHidden: FirstHidden,\n  callback: (fcpTiming: RelativeTime) => void\n) {\n  const performanceSubscription = createPerformanceObservable(configuration, {\n    type: RumPerformanceEntryType.PAINT,\n    buffered: true,\n  }).subscribe((entries) => {\n    const fcpEntry = entries.find(\n      (entry): entry is RumPerformancePaintTiming =>\n        entry.name === 'first-contentful-paint' &&\n        entry.startTime < firstHidden.timeStamp &&\n        entry.startTime < FCP_MAXIMUM_DELAY\n    )\n    if (fcpEntry) {\n      callback(fcpEntry.startTime)\n    }\n  })\n  return {\n    stop: performanceSubscription.unsubscribe,\n  }\n}\n\n/**\n * Measure the First Contentful Paint after a BFCache restoration.\n * The DOM is restored synchronously, so we approximate the FCP with the first frame\n * rendered just after the pageshow event, using two nested requestAnimationFrame calls.\n */\nexport function trackRestoredFirstContentfulPaint(viewStartRelative: RelativeTime, callback: (fcp: Duration) => void) {\n  requestAnimationFrame(() => {\n    requestAnimationFrame(() => {\n      callback(elapsed(viewStartRelative, relativeNow()))\n    })\n  })\n}\n", "import type { Duration, RelativeTime } from '@datadog/browser-core'\nimport { elapsed } from '@datadog/browser-core'\nimport { isElementNode } from '../../../browser/htmlDomUtils'\nimport type { RumConfiguration } from '../../configuration'\nimport { createPerformanceObservable, RumPerformanceEntryType } from '../../../browser/performanceObservable'\nimport type { RumFirstInputTiming } from '../../../browser/performanceObservable'\nimport { getSelectorFromElement } from '../../getSelectorFromElement'\nimport type { FirstHidden } from './trackFirstHidden'\n\nexport interface FirstInput {\n  delay: Duration\n  time: RelativeTime\n  targetSelector?: string\n}\n\n/**\n * Track the first input occurring during the initial View to return:\n * - First Input Delay\n * - First Input Time\n * Callback is called at most one time.\n * Documentation: https://web.dev/fid/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getFID.ts\n */\nexport function trackFirstInput(\n  configuration: RumConfiguration,\n  firstHidden: FirstHidden,\n  callback: (firstInput: FirstInput) => void\n) {\n  const performanceFirstInputSubscription = createPerformanceObservable(configuration, {\n    type: RumPerformanceEntryType.FIRST_INPUT,\n    buffered: true,\n  }).subscribe((entries) => {\n    const firstInputEntry = entries.find(\n      (entry): entry is RumFirstInputTiming => entry.startTime < firstHidden.timeStamp\n    )\n    if (firstInputEntry) {\n      const firstInputDelay = elapsed(firstInputEntry.startTime, firstInputEntry.processingStart)\n      let firstInputTargetSelector\n\n      if (firstInputEntry.target && isElementNode(firstInputEntry.target)) {\n        firstInputTargetSelector = getSelectorFromElement(firstInputEntry.target, configuration.actionNameAttribute)\n      }\n\n      callback({\n        // Ensure firstInputDelay to be positive, see\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1185815\n        delay: firstInputDelay >= 0 ? firstInputDelay : (0 as Duration),\n        time: firstInputEntry.startTime,\n        targetSelector: firstInputTargetSelector,\n      })\n    }\n  })\n\n  return {\n    stop: () => {\n      performanceFirstInputSubscription.unsubscribe()\n    },\n  }\n}\n", "import type { Duration, TimeoutId } from '@datadog/browser-core'\nimport { setTimeout, relativeNow, runOnReadyState, clearTimeout } from '@datadog/browser-core'\nimport type { RumPerformanceNavigationTiming } from '../../../browser/performanceObservable'\nimport type { RumConfiguration } from '../../configuration'\nimport { getNavigationEntry } from '../../../browser/performanceUtils'\n\nexport interface NavigationTimings {\n  domComplete: Duration\n  domContentLoaded: Duration\n  domInteractive: Duration\n  loadEvent: Duration\n  firstByte: Duration | undefined\n}\n\n// This is a subset of \"RumPerformanceNavigationTiming\" that only contains the relevant fields for\n// computing navigation timings. This is useful to mock the navigation entry in tests.\nexport type RelevantNavigationTiming = Pick<\n  RumPerformanceNavigationTiming,\n  'domComplete' | 'domContentLoadedEventEnd' | 'domInteractive' | 'loadEventEnd' | 'responseStart'\n>\n\nexport function trackNavigationTimings(\n  configuration: RumConfiguration,\n  callback: (timings: NavigationTimings) => void,\n  getNavigationEntryImpl: () => RelevantNavigationTiming = getNavigationEntry\n) {\n  return waitAfterLoadEvent(configuration, () => {\n    const entry = getNavigationEntryImpl()\n\n    if (!isIncompleteNavigation(entry)) {\n      callback(processNavigationEntry(entry))\n    }\n  })\n}\n\nfunction processNavigationEntry(entry: RelevantNavigationTiming): NavigationTimings {\n  return {\n    domComplete: entry.domComplete,\n    domContentLoaded: entry.domContentLoadedEventEnd,\n    domInteractive: entry.domInteractive,\n    loadEvent: entry.loadEventEnd,\n    // In some cases the value reported is negative or is larger\n    // than the current page time. Ignore these cases:\n    // https://github.com/GoogleChrome/web-vitals/issues/137\n    // https://github.com/GoogleChrome/web-vitals/issues/162\n    firstByte: entry.responseStart >= 0 && entry.responseStart <= relativeNow() ? entry.responseStart : undefined,\n  }\n}\n\nfunction isIncompleteNavigation(entry: RelevantNavigationTiming) {\n  return entry.loadEventEnd <= 0\n}\n\nfunction waitAfterLoadEvent(configuration: RumConfiguration, callback: () => void) {\n  let timeoutId: TimeoutId | undefined\n  const { stop: stopOnReadyState } = runOnReadyState(configuration, 'complete', () => {\n    // Invoke the callback a bit after the actual load event, so the \"loadEventEnd\" timing is accurate\n    timeoutId = setTimeout(() => callback())\n  })\n  return {\n    stop: () => {\n      stopOnReadyState()\n      clearTimeout(timeoutId)\n    },\n  }\n}\n", "import type { RelativeTime } from '@datadog/browser-core'\nimport { DOM_EVENT, ONE_MINUTE, addEventListeners, findLast } from '@datadog/browser-core'\nimport type { RumConfiguration } from '../../configuration'\nimport { createPerformanceObservable, RumPerformanceEntryType } from '../../../browser/performanceObservable'\nimport type { RumLargestContentfulPaintTiming } from '../../../browser/performanceObservable'\nimport { getSelectorFromElement } from '../../getSelectorFromElement'\nimport type { FirstHidden } from './trackFirstHidden'\n\n// Discard LCP timings above a certain delay to avoid incorrect data\n// It happens in some cases like sleep mode or some browser implementations\nexport const LCP_MAXIMUM_DELAY = 10 * ONE_MINUTE\n\nexport interface LargestContentfulPaint {\n  value: RelativeTime\n  targetSelector?: string\n  resourceUrl?: string\n}\n\n/**\n * Track the largest contentful paint (LCP) occurring during the initial View.  This can yield\n * multiple values, only the most recent one should be used.\n * Documentation: https://web.dev/lcp/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/onLCP.ts\n */\nexport function trackLargestContentfulPaint(\n  configuration: RumConfiguration,\n  firstHidden: FirstHidden,\n  eventTarget: Window,\n  callback: (largestContentfulPaint: LargestContentfulPaint) => void\n) {\n  // Ignore entries that come after the first user interaction. According to the documentation, the\n  // browser should not send largest-contentful-paint entries after a user interact with the page,\n  // but the web-vitals reference implementation uses this as a safeguard.\n  let firstInteractionTimestamp = Infinity\n  const { stop: stopEventListener } = addEventListeners(\n    configuration,\n    eventTarget,\n    [DOM_EVENT.POINTER_DOWN, DOM_EVENT.KEY_DOWN],\n    (event) => {\n      firstInteractionTimestamp = event.timeStamp\n    },\n    { capture: true, once: true }\n  )\n\n  let biggestLcpSize = 0\n  const performanceLcpSubscription = createPerformanceObservable(configuration, {\n    type: RumPerformanceEntryType.LARGEST_CONTENTFUL_PAINT,\n    buffered: true,\n  }).subscribe((entries) => {\n    const lcpEntry = findLast(\n      entries,\n      (entry): entry is RumLargestContentfulPaintTiming =>\n        entry.entryType === RumPerformanceEntryType.LARGEST_CONTENTFUL_PAINT &&\n        entry.startTime < firstInteractionTimestamp &&\n        entry.startTime < firstHidden.timeStamp &&\n        entry.startTime < LCP_MAXIMUM_DELAY &&\n        // Ensure to get the LCP entry with the biggest size, see\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1516655\n        entry.size > biggestLcpSize\n    )\n    if (lcpEntry) {\n      let lcpTargetSelector\n      if (lcpEntry.element) {\n        lcpTargetSelector = getSelectorFromElement(lcpEntry.element, configuration.actionNameAttribute)\n      }\n\n      callback({\n        value: lcpEntry.startTime,\n        targetSelector: lcpTargetSelector,\n        resourceUrl: computeLcpEntryUrl(lcpEntry),\n      })\n      biggestLcpSize = lcpEntry.size\n    }\n  })\n\n  return {\n    stop: () => {\n      stopEventListener()\n      performanceLcpSubscription.unsubscribe()\n    },\n  }\n}\n\n// The property url report an empty string if the value is not available, we shouldn't report it in this case.\nfunction computeLcpEntryUrl(entry: RumLargestContentfulPaintTiming) {\n  return entry.url === '' ? undefined : entry.url\n}\n", "import type { ClocksState, RelativeTime } from '@datadog/browser-core'\nimport { addEventListeners, DOM_EVENT, noop } from '@datadog/browser-core'\nimport type { RumConfiguration } from '../../configuration'\nimport { supportPerformanceTimingEvent, RumPerformanceEntryType } from '../../../browser/performanceObservable'\n\nexport type FirstHidden = ReturnType<typeof trackFirstHidden>\n\nexport type Options = {\n  viewStart: ClocksState\n}\n\nexport function trackFirstHidden(\n  configuration: RumConfiguration,\n  viewStart: ClocksState,\n  eventTarget: Window = window\n) {\n  if (document.visibilityState === 'hidden') {\n    return { timeStamp: 0 as RelativeTime, stop: noop }\n  }\n\n  if (supportPerformanceTimingEvent(RumPerformanceEntryType.VISIBILITY_STATE)) {\n    const firstHiddenEntry = performance\n      .getEntriesByType(RumPerformanceEntryType.VISIBILITY_STATE)\n      .filter((entry) => entry.name === 'hidden')\n      .find((entry) => entry.startTime >= viewStart.relative)\n\n    if (firstHiddenEntry) {\n      return { timeStamp: firstHiddenEntry.startTime as RelativeTime, stop: noop }\n    }\n  }\n\n  let timeStamp: RelativeTime = Infinity as RelativeTime\n\n  const { stop } = addEventListeners(\n    configuration,\n    eventTarget,\n    [DOM_EVENT.PAGE_HIDE, DOM_EVENT.VISIBILITY_CHANGE],\n    (event) => {\n      if (event.type === DOM_EVENT.PAGE_HIDE || document.visibilityState === 'hidden') {\n        timeStamp = event.timeStamp as RelativeTime\n        stop()\n      }\n    },\n    { capture: true }\n  )\n\n  return {\n    get timeStamp() {\n      return timeStamp\n    },\n    stop,\n  }\n}\n", "import type { ClocksState, Duration } from '@datadog/browser-core'\nimport type { RumConfiguration } from '../../configuration'\nimport { trackFirstContentfulPaint } from './trackFirstContentfulPaint'\nimport type { FirstInput } from './trackFirstInput'\nimport { trackFirstInput } from './trackFirstInput'\nimport type { NavigationTimings } from './trackNavigationTimings'\nimport { trackNavigationTimings } from './trackNavigationTimings'\nimport type { LargestContentfulPaint } from './trackLargestContentfulPaint'\nimport { trackLargestContentfulPaint } from './trackLargestContentfulPaint'\nimport { trackFirstHidden } from './trackFirstHidden'\n\nexport interface InitialViewMetrics {\n  firstContentfulPaint?: Duration\n  navigationTimings?: NavigationTimings\n  largestContentfulPaint?: LargestContentfulPaint\n  firstInput?: FirstInput\n}\n\nexport function trackInitialViewMetrics(\n  configuration: RumConfiguration,\n  viewStart: ClocksState,\n  setLoadEvent: (loadEnd: Duration) => void,\n  scheduleViewUpdate: () => void\n) {\n  const initialViewMetrics: InitialViewMetrics = {}\n\n  const { stop: stopNavigationTracking } = trackNavigationTimings(configuration, (navigationTimings) => {\n    setLoadEvent(navigationTimings.loadEvent)\n    initialViewMetrics.navigationTimings = navigationTimings\n    scheduleViewUpdate()\n  })\n\n  const firstHidden = trackFirstHidden(configuration, viewStart)\n  const { stop: stopFCPTracking } = trackFirstContentfulPaint(configuration, firstHidden, (firstContentfulPaint) => {\n    initialViewMetrics.firstContentfulPaint = firstContentfulPaint\n    scheduleViewUpdate()\n  })\n\n  const { stop: stopLCPTracking } = trackLargestContentfulPaint(\n    configuration,\n    firstHidden,\n    window,\n    (largestContentfulPaint) => {\n      initialViewMetrics.largestContentfulPaint = largestContentfulPaint\n      scheduleViewUpdate()\n    }\n  )\n\n  const { stop: stopFIDTracking } = trackFirstInput(configuration, firstHidden, (firstInput) => {\n    initialViewMetrics.firstInput = firstInput\n    scheduleViewUpdate()\n  })\n\n  function stop() {\n    stopNavigationTracking()\n    stopFCPTracking()\n    stopLCPTracking()\n    stopFIDTracking()\n    firstHidden.stop()\n  }\n\n  return {\n    stop,\n    initialViewMetrics,\n  }\n}\n", "import type { RumLayoutShiftAttribution } from '../../../browser/performanceObservable'\n\n/**\n * Calculates the area of a rectangle given its width and height\n */\nconst calculateArea = (width: number, height: number): number => width * height\n\n/**\n * Calculates the intersection area between two rectangles\n */\nconst calculateIntersectionArea = (rect1: DOMRectReadOnly, rect2: DOMRectReadOnly): number => {\n  const left = Math.max(rect1.left, rect2.left)\n  const top = Math.max(rect1.top, rect2.top)\n  const right = Math.min(rect1.right, rect2.right)\n  const bottom = Math.min(rect1.bottom, rect2.bottom)\n\n  if (left >= right || top >= bottom) {\n    return 0\n  }\n\n  return calculateArea(right - left, bottom - top)\n}\n\n/**\n * Calculates the total impacted area of a layout shift source\n * This is the sum of the previous and current areas minus their intersection\n */\nexport const getClsAttributionImpactedArea = (source: RumLayoutShiftAttribution): number => {\n  const previousArea = calculateArea(source.previousRect.width, source.previousRect.height)\n  const currentArea = calculateArea(source.currentRect.width, source.currentRect.height)\n  const intersectionArea = calculateIntersectionArea(source.previousRect, source.currentRect)\n\n  return previousArea + currentArea - intersectionArea\n}\n", "import { round, ONE_SECOND, noop, elapsed } from '@datadog/browser-core'\nimport type { Duration, RelativeTime, WeakRef, WeakRefConstructor } from '@datadog/browser-core'\nimport { isElementNode } from '../../../browser/htmlDomUtils'\nimport type { RumLayoutShiftAttribution, RumLayoutShiftTiming } from '../../../browser/performanceObservable'\nimport {\n  supportPerformanceTimingEvent,\n  RumPerformanceEntryType,\n  createPerformanceObservable,\n} from '../../../browser/performanceObservable'\nimport { getSelectorFromElement } from '../../getSelectorFromElement'\nimport type { RumConfiguration } from '../../configuration'\nimport type { RumRect } from '../../../rumEvent.types'\nimport { getClsAttributionImpactedArea } from './getClsAttributionImpactedArea'\n\ndeclare const WeakRef: WeakRefConstructor\n\nexport interface CumulativeLayoutShift {\n  value: number\n  targetSelector?: string\n  time?: Duration\n  previousRect?: RumRect\n  currentRect?: RumRect\n  devicePixelRatio?: number\n}\n\ninterface LayoutShiftInstance {\n  target: WeakRef<Element> | undefined\n  time: Duration\n  previousRect: DOMRectReadOnly | undefined\n  currentRect: DOMRectReadOnly | undefined\n  devicePixelRatio: number\n}\n\n/**\n * Track the cumulative layout shifts (CLS).\n * Layout shifts are grouped into session windows.\n * The minimum gap between session windows is 1 second.\n * The maximum duration of a session window is 5 second.\n * The session window layout shift value is the sum of layout shifts inside it.\n * The CLS value is the max of session windows values.\n *\n * This yields a new value whenever the CLS value is updated (a higher session window value is computed).\n *\n * See isLayoutShiftSupported to check for browser support.\n *\n * Documentation:\n * https://web.dev/cls/\n * https://web.dev/evolving-cls/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getCLS.ts\n */\nexport function trackCumulativeLayoutShift(\n  configuration: RumConfiguration,\n  viewStart: RelativeTime,\n  callback: (cumulativeLayoutShift: CumulativeLayoutShift) => void\n) {\n  if (!isLayoutShiftSupported()) {\n    return {\n      stop: noop,\n    }\n  }\n\n  let maxClsValue = 0\n  let biggestShift: LayoutShiftInstance | undefined\n\n  // if no layout shift happen the value should be reported as 0\n  callback({\n    value: 0,\n  })\n\n  const slidingWindow = slidingSessionWindow()\n  const performanceSubscription = createPerformanceObservable(configuration, {\n    type: RumPerformanceEntryType.LAYOUT_SHIFT,\n    buffered: true,\n  }).subscribe((entries) => {\n    for (const entry of entries) {\n      if (entry.hadRecentInput || entry.startTime < viewStart) {\n        continue\n      }\n\n      const { cumulatedValue, isMaxValue } = slidingWindow.update(entry)\n\n      if (isMaxValue) {\n        const attribution = getTopImpactedElement(entry.sources)\n        biggestShift = {\n          target: attribution?.node ? new WeakRef(attribution.node) : undefined,\n          time: elapsed(viewStart, entry.startTime),\n          previousRect: attribution?.previousRect,\n          currentRect: attribution?.currentRect,\n          devicePixelRatio: window.devicePixelRatio,\n        }\n      }\n\n      if (cumulatedValue > maxClsValue) {\n        maxClsValue = cumulatedValue\n        const target = biggestShift?.target?.deref()\n\n        callback({\n          value: round(maxClsValue, 4),\n          targetSelector: target && getSelectorFromElement(target, configuration.actionNameAttribute),\n          time: biggestShift?.time,\n          previousRect: biggestShift?.previousRect ? asRumRect(biggestShift.previousRect) : undefined,\n          currentRect: biggestShift?.currentRect ? asRumRect(biggestShift.currentRect) : undefined,\n          devicePixelRatio: biggestShift?.devicePixelRatio,\n        })\n      }\n    }\n  })\n\n  return {\n    stop: () => {\n      performanceSubscription.unsubscribe()\n    },\n  }\n}\n\nfunction getTopImpactedElement(\n  sources: RumLayoutShiftAttribution[]\n): (RumLayoutShiftAttribution & { node: Element }) | undefined {\n  let topImpactedSource: (RumLayoutShiftAttribution & { node: Element }) | undefined\n  for (const source of sources) {\n    if (source.node && isElementNode(source.node)) {\n      const currentImpactedArea = getClsAttributionImpactedArea(source)\n      if (!topImpactedSource || getClsAttributionImpactedArea(topImpactedSource) < currentImpactedArea) {\n        topImpactedSource = source as RumLayoutShiftAttribution & { node: Element }\n      }\n    }\n  }\n  return topImpactedSource\n}\n\nfunction asRumRect({ x, y, width, height }: DOMRectReadOnly): RumRect {\n  return { x, y, width, height }\n}\n\nexport const MAX_WINDOW_DURATION = 5 * ONE_SECOND\nconst MAX_UPDATE_GAP = ONE_SECOND\n\nfunction slidingSessionWindow() {\n  let cumulatedValue = 0\n  let startTime: RelativeTime\n  let endTime: RelativeTime\n  let maxValue = 0\n\n  return {\n    update: (entry: RumLayoutShiftTiming) => {\n      const shouldCreateNewWindow =\n        startTime === undefined ||\n        entry.startTime - endTime >= MAX_UPDATE_GAP ||\n        entry.startTime - startTime >= MAX_WINDOW_DURATION\n\n      let isMaxValue: boolean\n\n      if (shouldCreateNewWindow) {\n        startTime = endTime = entry.startTime\n        maxValue = cumulatedValue = entry.value\n        isMaxValue = true\n      } else {\n        cumulatedValue += entry.value\n        endTime = entry.startTime\n        isMaxValue = entry.value > maxValue\n\n        if (isMaxValue) {\n          maxValue = entry.value\n        }\n      }\n\n      return {\n        cumulatedValue,\n        isMaxValue,\n      }\n    },\n  }\n}\n\n/**\n * Check whether `layout-shift` is supported by the browser.\n */\nexport function isLayoutShiftSupported() {\n  return supportPerformanceTimingEvent(RumPerformanceEntryType.LAYOUT_SHIFT) && 'WeakRef' in window\n}\n", "/**\n * performance.interactionCount polyfill\n *\n * The interactionCount is an integer which counts the total number of distinct user interactions,\n * for which there was a unique interactionId.\n *\n * The interactionCount polyfill is an estimate based on a convention specific to Chrome. Cf: https://github.com/GoogleChrome/web-vitals/pull/213\n * This is currently not an issue as the polyfill is only used for INP which is currently only supported on Chrome.\n * Hopefully when/if other browsers will support INP, they will also implement performance.interactionCount at the same time, so we won't need that polyfill.\n *\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/main/src/lib/polyfills/interactionCountPolyfill.ts\n */\n\nimport { monitor } from '@datadog/browser-core'\nimport type {\n  BrowserWindow,\n  RumPerformanceEventTiming,\n  RumPerformanceObserver,\n} from '../../../browser/performanceObservable'\n\nlet observer: RumPerformanceObserver | undefined\n\nlet interactionCountEstimate = 0\nlet minKnownInteractionId = Infinity\nlet maxKnownInteractionId = 0\n\nexport function initInteractionCountPolyfill() {\n  if ('interactionCount' in performance || observer) {\n    return\n  }\n\n  observer = new (window as BrowserWindow).PerformanceObserver(\n    monitor((entries: PerformanceObserverEntryList) => {\n      entries.getEntries().forEach((e) => {\n        const entry = e as unknown as RumPerformanceEventTiming\n\n        if (entry.interactionId) {\n          minKnownInteractionId = Math.min(minKnownInteractionId, entry.interactionId)\n          maxKnownInteractionId = Math.max(maxKnownInteractionId, entry.interactionId)\n\n          interactionCountEstimate = (maxKnownInteractionId - minKnownInteractionId) / 7 + 1\n        }\n      })\n    })\n  )\n\n  observer.observe({ type: 'event', buffered: true, durationThreshold: 0 })\n}\n\n/**\n * Returns the `interactionCount` value using the native API (if available)\n * or the polyfill estimate in this module.\n */\nexport const getInteractionCount = () =>\n  observer ? interactionCountEstimate : (window as BrowserWindow).performance.interactionCount! || 0\n", "import { elapsed, noop, ONE_MINUTE } from '@datadog/browser-core'\nimport type { Duration, RelativeTime } from '@datadog/browser-core'\nimport {\n  createPerformanceObservable,\n  RumPerformanceEntryType,\n  supportPerformanceTimingEvent,\n} from '../../../browser/performanceObservable'\nimport type { RumFirstInputTiming, RumPerformanceEventTiming } from '../../../browser/performanceObservable'\nimport { ViewLoadingType } from '../../../rawRumEvent.types'\nimport { getSelectorFromElement } from '../../getSelectorFromElement'\nimport { isElementNode } from '../../../browser/htmlDomUtils'\nimport { getInteractionSelector } from '../../action/interactionSelectorCache'\nimport type { RumConfiguration } from '../../configuration'\nimport { getInteractionCount, initInteractionCountPolyfill } from './interactionCountPolyfill'\n\n// Arbitrary value to prevent unnecessary memory usage on views with lots of interactions.\nconst MAX_INTERACTION_ENTRIES = 10\n// Arbitrary value to cap INP outliers\nexport const MAX_INP_VALUE = (1 * ONE_MINUTE) as Duration\n\nexport interface InteractionToNextPaint {\n  value: Duration\n  targetSelector?: string\n  time?: Duration\n}\n/**\n * Track the interaction to next paint (INP).\n * To avoid outliers, return the p98 worst interaction of the view.\n * Documentation: https://web.dev/inp/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/main/src/onINP.ts\n */\nexport function trackInteractionToNextPaint(\n  configuration: RumConfiguration,\n  viewStart: RelativeTime,\n  viewLoadingType: ViewLoadingType\n) {\n  if (!isInteractionToNextPaintSupported()) {\n    return {\n      getInteractionToNextPaint: () => undefined,\n      setViewEnd: noop,\n      stop: noop,\n    }\n  }\n\n  const { getViewInteractionCount, stopViewInteractionCount } = trackViewInteractionCount(viewLoadingType)\n\n  let viewEnd = Infinity as RelativeTime\n\n  const longestInteractions = trackLongestInteractions(getViewInteractionCount)\n  let interactionToNextPaint = -1 as Duration\n  let interactionToNextPaintTargetSelector: string | undefined\n  let interactionToNextPaintStartTime: Duration | undefined\n\n  function handleEntries(entries: Array<RumPerformanceEventTiming | RumFirstInputTiming>) {\n    for (const entry of entries) {\n      if (\n        entry.interactionId &&\n        // Check the entry start time is inside the view bounds because some view interactions can be reported after the view end (if long duration).\n        entry.startTime >= viewStart &&\n        entry.startTime <= viewEnd\n      ) {\n        longestInteractions.process(entry)\n      }\n    }\n\n    const newInteraction = longestInteractions.estimateP98Interaction()\n    if (newInteraction && newInteraction.duration !== interactionToNextPaint) {\n      interactionToNextPaint = newInteraction.duration\n      interactionToNextPaintStartTime = elapsed(viewStart, newInteraction.startTime)\n      interactionToNextPaintTargetSelector = getInteractionSelector(newInteraction.startTime)\n      if (!interactionToNextPaintTargetSelector && newInteraction.target && isElementNode(newInteraction.target)) {\n        interactionToNextPaintTargetSelector = getSelectorFromElement(\n          newInteraction.target,\n          configuration.actionNameAttribute\n        )\n      }\n    }\n  }\n\n  const firstInputSubscription = createPerformanceObservable(configuration, {\n    type: RumPerformanceEntryType.FIRST_INPUT,\n    buffered: true,\n  }).subscribe(handleEntries)\n\n  const eventSubscription = createPerformanceObservable(configuration, {\n    type: RumPerformanceEntryType.EVENT,\n    // durationThreshold only impact PerformanceEventTiming entries used for INP computation which requires a threshold at 40 (default is 104ms)\n    // cf: https://github.com/GoogleChrome/web-vitals/blob/3806160ffbc93c3c4abf210a167b81228172b31c/src/onINP.ts#L202-L210\n    durationThreshold: 40,\n    buffered: true,\n  }).subscribe(handleEntries)\n\n  return {\n    getInteractionToNextPaint: (): InteractionToNextPaint | undefined => {\n      // If no INP duration where captured because of the performanceObserver 40ms threshold\n      // but the view interaction count > 0 then report 0\n      if (interactionToNextPaint >= 0) {\n        return {\n          value: Math.min(interactionToNextPaint, MAX_INP_VALUE) as Duration,\n          targetSelector: interactionToNextPaintTargetSelector,\n          time: interactionToNextPaintStartTime,\n        }\n      } else if (getViewInteractionCount()) {\n        return {\n          value: 0 as Duration,\n        }\n      }\n    },\n    setViewEnd: (viewEndTime: RelativeTime) => {\n      viewEnd = viewEndTime\n      stopViewInteractionCount()\n    },\n    stop: () => {\n      eventSubscription.unsubscribe()\n      firstInputSubscription.unsubscribe()\n    },\n  }\n}\n\nfunction trackLongestInteractions(getViewInteractionCount: () => number) {\n  const longestInteractions: Array<RumPerformanceEventTiming | RumFirstInputTiming> = []\n\n  function sortAndTrimLongestInteractions() {\n    longestInteractions.sort((a, b) => b.duration - a.duration).splice(MAX_INTERACTION_ENTRIES)\n  }\n\n  return {\n    /**\n     * Process the performance entry:\n     * - if its duration is long enough, add the performance entry to the list of worst interactions\n     * - if an entry with the same interaction id exists and its duration is lower than the new one, then replace it in the list of worst interactions\n     */\n    process(entry: RumPerformanceEventTiming | RumFirstInputTiming) {\n      const interactionIndex = longestInteractions.findIndex(\n        (interaction) => entry.interactionId === interaction.interactionId\n      )\n\n      const minLongestInteraction = longestInteractions[longestInteractions.length - 1]\n\n      if (interactionIndex !== -1) {\n        if (entry.duration > longestInteractions[interactionIndex].duration) {\n          longestInteractions[interactionIndex] = entry\n          sortAndTrimLongestInteractions()\n        }\n      } else if (\n        longestInteractions.length < MAX_INTERACTION_ENTRIES ||\n        entry.duration > minLongestInteraction.duration\n      ) {\n        longestInteractions.push(entry)\n        sortAndTrimLongestInteractions()\n      }\n    },\n    /**\n     * Compute the p98 longest interaction.\n     * For better performance the computation is based on 10 longest interactions and the interaction count of the current view.\n     */\n    estimateP98Interaction(): RumPerformanceEventTiming | RumFirstInputTiming | undefined {\n      const interactionIndex = Math.min(longestInteractions.length - 1, Math.floor(getViewInteractionCount() / 50))\n      return longestInteractions[interactionIndex]\n    },\n  }\n}\n\nexport function trackViewInteractionCount(viewLoadingType: ViewLoadingType) {\n  initInteractionCountPolyfill()\n  const previousInteractionCount = viewLoadingType === ViewLoadingType.INITIAL_LOAD ? 0 : getInteractionCount()\n  let state: { stopped: false } | { stopped: true; interactionCount: number } = { stopped: false }\n\n  function computeViewInteractionCount() {\n    return getInteractionCount() - previousInteractionCount\n  }\n\n  return {\n    getViewInteractionCount: () => {\n      if (state.stopped) {\n        return state.interactionCount\n      }\n\n      return computeViewInteractionCount()\n    },\n    stopViewInteractionCount: () => {\n      state = { stopped: true, interactionCount: computeViewInteractionCount() }\n    },\n  }\n}\n\nexport function isInteractionToNextPaintSupported() {\n  return (\n    supportPerformanceTimingEvent(RumPerformanceEntryType.EVENT) &&\n    window.PerformanceEventTiming &&\n    'interactionId' in PerformanceEventTiming.prototype\n  )\n}\n", "import type { ClocksState, Duration, Observable } from '@datadog/browser-core'\nimport { elapsed } from '@datadog/browser-core'\nimport { waitPageActivityEnd } from '../../waitPageActivityEnd'\nimport type { RumConfiguration } from '../../configuration'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { ViewLoadingType } from '../../../rawRumEvent.types'\nimport type { RumMutationRecord } from '../../../browser/domMutationObservable'\nimport { trackFirstHidden } from './trackFirstHidden'\n\n/**\n * For non-initial views (such as route changes or BFCache restores), the regular load event does not fire\n * In these cases, trackLoadingTime can only emit a loadingTime  if waitPageActivityEnd detects some post-restore activity.\n * If nothing happens after the view starts,no candidate is recorded and loadingTime stays undefined.\n */\n\nexport function trackLoadingTime(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<RumMutationRecord[]>,\n  windowOpenObservable: Observable<void>,\n  configuration: RumConfiguration,\n  loadType: ViewLoadingType,\n  viewStart: ClocksState,\n  callback: (loadingTime: Duration) => void\n) {\n  let isWaitingForLoadEvent = loadType === ViewLoadingType.INITIAL_LOAD\n  let isWaitingForActivityLoadingTime = true\n  const loadingTimeCandidates: Duration[] = []\n  const firstHidden = trackFirstHidden(configuration, viewStart)\n\n  function invokeCallbackIfAllCandidatesAreReceived() {\n    if (!isWaitingForActivityLoadingTime && !isWaitingForLoadEvent && loadingTimeCandidates.length > 0) {\n      const loadingTime = Math.max(...loadingTimeCandidates)\n      // firstHidden is a relative time from time origin, so we use the relative start time of the view to compare with the loading time\n      if (loadingTime < firstHidden.timeStamp - viewStart.relative) {\n        callback(loadingTime as Duration)\n      }\n    }\n  }\n\n  const { stop } = waitPageActivityEnd(\n    lifeCycle,\n    domMutationObservable,\n    windowOpenObservable,\n    configuration,\n    (event) => {\n      if (isWaitingForActivityLoadingTime) {\n        isWaitingForActivityLoadingTime = false\n        if (event.hadActivity) {\n          loadingTimeCandidates.push(elapsed(viewStart.timeStamp, event.end))\n        }\n        invokeCallbackIfAllCandidatesAreReceived()\n      }\n    }\n  )\n\n  return {\n    stop: () => {\n      stop()\n      firstHidden.stop()\n    },\n    setLoadEvent: (loadEvent: Duration) => {\n      if (isWaitingForLoadEvent) {\n        isWaitingForLoadEvent = false\n        loadingTimeCandidates.push(loadEvent)\n        invokeCallbackIfAllCandidatesAreReceived()\n      }\n    },\n  }\n}\n", "export function getScrollX() {\n  let scrollX\n  const visual = window.visualViewport\n  if (visual) {\n    scrollX = visual.pageLeft - visual.offsetLeft\n  } else if (window.scrollX !== undefined) {\n    scrollX = window.scrollX\n  } else {\n    scrollX = window.pageXOffset || 0\n  }\n  return Math.round(scrollX)\n}\n\nexport function getScrollY() {\n  let scrollY\n  const visual = window.visualViewport\n  if (visual) {\n    scrollY = visual.pageTop - visual.offsetTop\n  } else if (window.scrollY !== undefined) {\n    scrollY = window.scrollY\n  } else {\n    scrollY = window.pageYOffset || 0\n  }\n  return Math.round(scrollY)\n}\n", "import { Observable, throttle, addEventListener, DOM_EVENT } from '@datadog/browser-core'\nimport type { RumConfiguration } from '../domain/configuration'\n\nexport interface ViewportDimension {\n  height: number\n  width: number\n  [k: string]: unknown\n}\n\nlet viewportObservable: Observable<ViewportDimension> | undefined\n\nexport function initViewportObservable(configuration: RumConfiguration) {\n  if (!viewportObservable) {\n    viewportObservable = createViewportObservable(configuration)\n  }\n  return viewportObservable\n}\n\nexport function createViewportObservable(configuration: RumConfiguration) {\n  return new Observable<ViewportDimension>((observable) => {\n    const { throttled: updateDimension } = throttle(() => {\n      observable.notify(getViewportDimension())\n    }, 200)\n\n    return addEventListener(configuration, window, DOM_EVENT.RESIZE, updateDimension, { capture: true, passive: true })\n      .stop\n  })\n}\n\n// excludes the width and height of any rendered classic scrollbar that is fixed to the visual viewport\nexport function getViewportDimension(): ViewportDimension {\n  const visual = window.visualViewport\n  if (visual) {\n    return {\n      width: Number(visual.width * visual.scale),\n      height: Number(visual.height * visual.scale),\n    }\n  }\n\n  return {\n    width: Number(window.innerWidth || 0),\n    height: Number(window.innerHeight || 0),\n  }\n}\n", "import type { ClocksState, Duration } from '@datadog/browser-core'\nimport {\n  Observable,\n  ONE_SECOND,\n  elapsed,\n  relativeNow,\n  throttle,\n  addEventListener,\n  DOM_EVENT,\n  monitor,\n} from '@datadog/browser-core'\nimport type { RumConfiguration } from '../../configuration'\nimport { getScrollY } from '../../../browser/scroll'\nimport { getViewportDimension } from '../../../browser/viewportObservable'\n\n/** Arbitrary scroll throttle duration */\nexport const THROTTLE_SCROLL_DURATION = ONE_SECOND\n\nexport interface ScrollMetrics {\n  maxDepth: number\n  maxScrollHeight: number\n  maxDepthScrollTop: number\n  maxScrollHeightTime: Duration\n}\n\nexport function trackScrollMetrics(\n  configuration: RumConfiguration,\n  viewStart: ClocksState,\n  callback: (scrollMetrics: ScrollMetrics) => void,\n  scrollValues = createScrollValuesObservable(configuration)\n) {\n  let maxScrollDepth = 0\n  let maxScrollHeight = 0\n  let maxScrollHeightTime = 0 as Duration\n\n  const subscription = scrollValues.subscribe(({ scrollDepth, scrollTop, scrollHeight }) => {\n    let shouldUpdate = false\n\n    if (scrollDepth > maxScrollDepth) {\n      maxScrollDepth = scrollDepth\n      shouldUpdate = true\n    }\n\n    if (scrollHeight > maxScrollHeight) {\n      maxScrollHeight = scrollHeight\n      const now = relativeNow()\n      maxScrollHeightTime = elapsed(viewStart.relative, now)\n      shouldUpdate = true\n    }\n\n    if (shouldUpdate) {\n      callback({\n        maxDepth: Math.min(maxScrollDepth, maxScrollHeight),\n        maxDepthScrollTop: scrollTop,\n        maxScrollHeight,\n        maxScrollHeightTime,\n      })\n    }\n  })\n\n  return {\n    stop: () => subscription.unsubscribe(),\n  }\n}\n\nexport interface ScrollValues {\n  scrollDepth: number\n  scrollTop: number\n  scrollHeight: number\n}\n\nexport function computeScrollValues() {\n  const scrollTop = getScrollY()\n\n  const { height } = getViewportDimension()\n\n  const scrollHeight = Math.round((document.scrollingElement || document.documentElement).scrollHeight)\n\n  const scrollDepth = Math.round(height + scrollTop)\n\n  return {\n    scrollHeight,\n    scrollDepth,\n    scrollTop,\n  }\n}\n\nexport function createScrollValuesObservable(\n  configuration: RumConfiguration,\n  throttleDuration = THROTTLE_SCROLL_DURATION\n): Observable<ScrollValues> {\n  return new Observable<ScrollValues>((observable) => {\n    function notify() {\n      observable.notify(computeScrollValues())\n    }\n\n    if (window.ResizeObserver) {\n      const throttledNotify = throttle(notify, throttleDuration, {\n        leading: false,\n        trailing: true,\n      })\n\n      const observerTarget = document.scrollingElement || document.documentElement\n      const resizeObserver = new ResizeObserver(monitor(throttledNotify.throttled))\n      if (observerTarget) {\n        resizeObserver.observe(observerTarget)\n      }\n      const eventListener = addEventListener(configuration, window, DOM_EVENT.SCROLL, throttledNotify.throttled, {\n        passive: true,\n      })\n\n      return () => {\n        throttledNotify.cancel()\n        resizeObserver.disconnect()\n        eventListener.stop()\n      }\n    }\n  })\n}\n", "import type { ClocksState, Duration, Observable } from '@datadog/browser-core'\nimport type { ViewLoadingType } from '../../../rawRumEvent.types'\nimport type { RumConfiguration } from '../../configuration'\nimport type { LifeCycle } from '../../lifeCycle'\nimport type { RumMutationRecord } from '../../../browser/domMutationObservable'\nimport type { CumulativeLayoutShift } from './trackCumulativeLayoutShift'\nimport { trackCumulativeLayoutShift } from './trackCumulativeLayoutShift'\nimport type { InteractionToNextPaint } from './trackInteractionToNextPaint'\nimport { trackInteractionToNextPaint } from './trackInteractionToNextPaint'\nimport { trackLoadingTime } from './trackLoadingTime'\nimport type { ScrollMetrics } from './trackScrollMetrics'\nimport { trackScrollMetrics } from './trackScrollMetrics'\n\nexport interface CommonViewMetrics {\n  loadingTime?: Duration\n  cumulativeLayoutShift?: CumulativeLayoutShift\n  interactionToNextPaint?: InteractionToNextPaint\n  scroll?: ScrollMetrics\n}\n\nexport function trackCommonViewMetrics(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<RumMutationRecord[]>,\n  windowOpenObservable: Observable<void>,\n  configuration: RumConfiguration,\n  scheduleViewUpdate: () => void,\n  loadingType: ViewLoadingType,\n  viewStart: ClocksState\n) {\n  const commonViewMetrics: CommonViewMetrics = {}\n\n  const { stop: stopLoadingTimeTracking, setLoadEvent } = trackLoadingTime(\n    lifeCycle,\n    domMutationObservable,\n    windowOpenObservable,\n    configuration,\n    loadingType,\n    viewStart,\n    (newLoadingTime) => {\n      commonViewMetrics.loadingTime = newLoadingTime\n      scheduleViewUpdate()\n    }\n  )\n\n  const { stop: stopScrollMetricsTracking } = trackScrollMetrics(configuration, viewStart, (newScrollMetrics) => {\n    commonViewMetrics.scroll = newScrollMetrics\n  })\n\n  const { stop: stopCLSTracking } = trackCumulativeLayoutShift(\n    configuration,\n    viewStart.relative,\n    (cumulativeLayoutShift) => {\n      commonViewMetrics.cumulativeLayoutShift = cumulativeLayoutShift\n      scheduleViewUpdate()\n    }\n  )\n\n  const {\n    stop: stopINPTracking,\n    getInteractionToNextPaint,\n    setViewEnd,\n  } = trackInteractionToNextPaint(configuration, viewStart.relative, loadingType)\n\n  return {\n    stop: () => {\n      stopLoadingTimeTracking()\n      stopCLSTracking()\n      stopScrollMetricsTracking()\n    },\n    stopINPTracking,\n    setLoadEvent,\n    setViewEnd,\n    getCommonViewMetrics: () => {\n      commonViewMetrics.interactionToNextPaint = getInteractionToNextPaint()\n      return commonViewMetrics\n    },\n  }\n}\n", "import type { Configuration } from '@datadog/browser-core'\nimport { addEventListener, DOM_EVENT } from '@datadog/browser-core'\n\nexport function onBFCacheRestore(\n  configuration: Configuration,\n  callback: (event: PageTransitionEvent) => void\n): () => void {\n  const { stop } = addEventListener(\n    configuration,\n    window,\n    DOM_EVENT.PAGE_SHOW,\n    (event: PageTransitionEvent) => {\n      if (event.persisted) {\n        callback(event)\n      }\n    },\n    { capture: true }\n  )\n  return stop\n}\n", "import type { RelativeTime, ClocksState } from '@datadog/browser-core'\nimport type { InitialViewMetrics } from './trackInitialViewMetrics'\nimport { trackRestoredFirstContentfulPaint } from './trackFirstContentfulPaint'\n\n/**\n * BFCache keeps a full in-memory snapshot of the DOM. When the page is restored, nothing needs to be fetched, so the whole\n * viewport repaints in a single frame. Consequently, LCP almost always equals FCP.\n * (See: https://github.com/GoogleChrome/web-vitals/pull/87)\n */\nexport function trackBfcacheMetrics(\n  viewStart: ClocksState,\n  metrics: InitialViewMetrics,\n  scheduleViewUpdate: () => void\n) {\n  trackRestoredFirstContentfulPaint(viewStart.relative, (paintTime) => {\n    metrics.firstContentfulPaint = paintTime\n    metrics.largestContentfulPaint = { value: paintTime as RelativeTime }\n    scheduleViewUpdate()\n  })\n}\n", "import type {\n  Duration,\n  ClocksState,\n  TimeStamp,\n  Subscription,\n  RelativeTime,\n  Context,\n  ContextValue,\n} from '@datadog/browser-core'\nimport {\n  noop,\n  PageExitReason,\n  shallowClone,\n  elapsed,\n  generateUUID,\n  ONE_MINUTE,\n  throttle,\n  clocksNow,\n  clocksOrigin,\n  relativeToClocks,\n  timeStampNow,\n  display,\n  looksLikeRelativeTime,\n  setInterval,\n  clearInterval,\n  setTimeout,\n  Observable,\n  createContextManager,\n} from '@datadog/browser-core'\nimport type { ViewCustomTimings } from '../../rawRumEvent.types'\nimport { ViewLoadingType } from '../../rawRumEvent.types'\nimport type { LifeCycle } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\nimport type { EventCounts } from '../trackEventCounts'\nimport type { LocationChange } from '../../browser/locationChangeObservable'\nimport type { RumConfiguration, RumInitConfiguration } from '../configuration'\nimport type { RumMutationRecord } from '../../browser/domMutationObservable'\nimport { trackViewEventCounts } from './trackViewEventCounts'\nimport { trackInitialViewMetrics } from './viewMetrics/trackInitialViewMetrics'\nimport type { InitialViewMetrics } from './viewMetrics/trackInitialViewMetrics'\nimport type { CommonViewMetrics } from './viewMetrics/trackCommonViewMetrics'\nimport { trackCommonViewMetrics } from './viewMetrics/trackCommonViewMetrics'\nimport { onBFCacheRestore } from './bfCacheSupport'\nimport { trackBfcacheMetrics } from './viewMetrics/trackBfcacheMetrics'\n\nexport interface ViewEvent {\n  id: string\n  name?: string\n  service?: string\n  version?: string\n  context?: Context\n  location: Readonly<Location>\n  commonViewMetrics: CommonViewMetrics\n  initialViewMetrics: InitialViewMetrics\n  customTimings: ViewCustomTimings\n  eventCounts: EventCounts\n  documentVersion: number\n  startClocks: ClocksState\n  duration: Duration\n  isActive: boolean\n  sessionIsActive: boolean\n  loadingType: ViewLoadingType\n}\n\nexport interface ViewCreatedEvent {\n  id: string\n  name?: string\n  service?: string\n  version?: string\n  context?: Context\n  startClocks: ClocksState\n}\n\nexport interface BeforeViewUpdateEvent {\n  id: string\n  name?: string\n  context?: Context\n  startClocks: ClocksState\n  sessionIsActive: boolean\n}\n\nexport interface ViewEndedEvent {\n  endClocks: ClocksState\n}\n\nexport const THROTTLE_VIEW_UPDATE_PERIOD = 3000\nexport const SESSION_KEEP_ALIVE_INTERVAL = 5 * ONE_MINUTE\n\n// Some events or metrics can be captured after the end of the view. To avoid missing those;\n// an arbitrary delay is added for stopping their tracking after the view ends.\n//\n// Ideally, we would not stop and keep tracking events or metrics until the end of the session.\n// But this might have a small performance impact if there are many many views.\n// So let's have a fairly short delay improving the situation in most cases and avoid impacting performances too much.\nexport const KEEP_TRACKING_AFTER_VIEW_DELAY = 5 * ONE_MINUTE\n\nexport interface ViewOptions {\n  name?: string\n  service?: RumInitConfiguration['service']\n  version?: RumInitConfiguration['version']\n  context?: Context\n}\n\nexport function trackViews(\n  location: Location,\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<RumMutationRecord[]>,\n  windowOpenObservable: Observable<void>,\n  configuration: RumConfiguration,\n  locationChangeObservable: Observable<LocationChange>,\n  areViewsTrackedAutomatically: boolean,\n  initialViewOptions?: ViewOptions\n) {\n  const activeViews: Set<ReturnType<typeof newView>> = new Set()\n  let currentView = startNewView(ViewLoadingType.INITIAL_LOAD, clocksOrigin(), initialViewOptions)\n  let stopOnBFCacheRestore: (() => void) | undefined\n\n  startViewLifeCycle()\n\n  let locationChangeSubscription: Subscription\n  if (areViewsTrackedAutomatically) {\n    locationChangeSubscription = renewViewOnLocationChange(locationChangeObservable)\n    if (configuration.trackBfcacheViews) {\n      stopOnBFCacheRestore = onBFCacheRestore(configuration, (pageshowEvent) => {\n        currentView.end()\n        const startClocks = relativeToClocks(pageshowEvent.timeStamp as RelativeTime)\n        currentView = startNewView(ViewLoadingType.BF_CACHE, startClocks, undefined)\n      })\n    }\n  }\n\n  function startNewView(loadingType: ViewLoadingType, startClocks?: ClocksState, viewOptions?: ViewOptions) {\n    const newlyCreatedView = newView(\n      lifeCycle,\n      domMutationObservable,\n      windowOpenObservable,\n      configuration,\n      location,\n      loadingType,\n      startClocks,\n      viewOptions\n    )\n    activeViews.add(newlyCreatedView)\n    newlyCreatedView.stopObservable.subscribe(() => {\n      activeViews.delete(newlyCreatedView)\n    })\n    return newlyCreatedView\n  }\n\n  function startViewLifeCycle() {\n    lifeCycle.subscribe(LifeCycleEventType.SESSION_RENEWED, () => {\n      // Renew view on session renewal\n      currentView = startNewView(ViewLoadingType.ROUTE_CHANGE, undefined, {\n        name: currentView.name,\n        service: currentView.service,\n        version: currentView.version,\n        context: currentView.contextManager.getContext(),\n      })\n    })\n\n    lifeCycle.subscribe(LifeCycleEventType.SESSION_EXPIRED, () => {\n      currentView.end({ sessionIsActive: false })\n    })\n  }\n\n  function renewViewOnLocationChange(locationChangeObservable: Observable<LocationChange>) {\n    return locationChangeObservable.subscribe(({ oldLocation, newLocation }) => {\n      if (areDifferentLocation(oldLocation, newLocation)) {\n        currentView.end()\n        currentView = startNewView(ViewLoadingType.ROUTE_CHANGE)\n      }\n    })\n  }\n\n  return {\n    addTiming: (name: string, time: RelativeTime | TimeStamp = timeStampNow()) => {\n      currentView.addTiming(name, time)\n    },\n    startView: (options?: ViewOptions, startClocks?: ClocksState) => {\n      currentView.end({ endClocks: startClocks })\n      currentView = startNewView(ViewLoadingType.ROUTE_CHANGE, startClocks, options)\n    },\n    setViewContext: (context: Context) => {\n      currentView.contextManager.setContext(context)\n    },\n    setViewContextProperty: (key: string, value: ContextValue) => {\n      currentView.contextManager.setContextProperty(key, value)\n    },\n    setViewName: (name: string) => {\n      currentView.setViewName(name)\n    },\n    getViewContext: () => currentView.contextManager.getContext(),\n\n    stop: () => {\n      if (locationChangeSubscription) {\n        locationChangeSubscription.unsubscribe()\n      }\n      if (stopOnBFCacheRestore) {\n        stopOnBFCacheRestore()\n      }\n      currentView.end()\n      activeViews.forEach((view) => view.stop())\n    },\n  }\n}\n\nfunction newView(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<RumMutationRecord[]>,\n  windowOpenObservable: Observable<void>,\n  configuration: RumConfiguration,\n  initialLocation: Location,\n  loadingType: ViewLoadingType,\n  startClocks: ClocksState = clocksNow(),\n  viewOptions?: ViewOptions\n) {\n  // Setup initial values\n  const id = generateUUID()\n  const stopObservable = new Observable<void>()\n  const customTimings: ViewCustomTimings = {}\n  let documentVersion = 0\n  let endClocks: ClocksState | undefined\n  const location = shallowClone(initialLocation)\n  const contextManager = createContextManager()\n\n  let sessionIsActive = true\n  let name = viewOptions?.name\n  const service = viewOptions?.service || configuration.service\n  const version = viewOptions?.version || configuration.version\n  const context = viewOptions?.context\n\n  if (context) {\n    contextManager.setContext(context)\n  }\n\n  const viewCreatedEvent = {\n    id,\n    name,\n    startClocks,\n    service,\n    version,\n    context,\n  }\n  lifeCycle.notify(LifeCycleEventType.BEFORE_VIEW_CREATED, viewCreatedEvent)\n  lifeCycle.notify(LifeCycleEventType.VIEW_CREATED, viewCreatedEvent)\n\n  // Update the view every time the measures are changing\n  const { throttled, cancel: cancelScheduleViewUpdate } = throttle(triggerViewUpdate, THROTTLE_VIEW_UPDATE_PERIOD, {\n    leading: false,\n  })\n\n  const {\n    setLoadEvent,\n    setViewEnd,\n    stop: stopCommonViewMetricsTracking,\n    stopINPTracking,\n    getCommonViewMetrics,\n  } = trackCommonViewMetrics(\n    lifeCycle,\n    domMutationObservable,\n    windowOpenObservable,\n    configuration,\n    scheduleViewUpdate,\n    loadingType,\n    startClocks\n  )\n\n  const { stop: stopInitialViewMetricsTracking, initialViewMetrics } =\n    loadingType === ViewLoadingType.INITIAL_LOAD\n      ? trackInitialViewMetrics(configuration, startClocks, setLoadEvent, scheduleViewUpdate)\n      : { stop: noop, initialViewMetrics: {} as InitialViewMetrics }\n\n  // Start BFCache-specific metrics when restoring from BFCache\n  if (loadingType === ViewLoadingType.BF_CACHE) {\n    trackBfcacheMetrics(startClocks, initialViewMetrics, scheduleViewUpdate)\n  }\n\n  const { stop: stopEventCountsTracking, eventCounts } = trackViewEventCounts(lifeCycle, id, scheduleViewUpdate)\n\n  // Session keep alive\n  const keepAliveIntervalId = setInterval(triggerViewUpdate, SESSION_KEEP_ALIVE_INTERVAL)\n\n  const pageMayExitSubscription = lifeCycle.subscribe(LifeCycleEventType.PAGE_MAY_EXIT, (pageMayExitEvent) => {\n    if (pageMayExitEvent.reason === PageExitReason.UNLOADING) {\n      triggerViewUpdate()\n    }\n  })\n\n  // Initial view update\n  triggerViewUpdate()\n\n  // View context update should always be throttled\n  contextManager.changeObservable.subscribe(scheduleViewUpdate)\n\n  function triggerBeforeViewUpdate() {\n    lifeCycle.notify(LifeCycleEventType.BEFORE_VIEW_UPDATED, {\n      id,\n      name,\n      context: contextManager.getContext(),\n      startClocks,\n      sessionIsActive,\n    })\n  }\n\n  function scheduleViewUpdate() {\n    triggerBeforeViewUpdate()\n    throttled()\n  }\n\n  function triggerViewUpdate() {\n    cancelScheduleViewUpdate()\n    triggerBeforeViewUpdate()\n\n    documentVersion += 1\n    const currentEnd = endClocks === undefined ? timeStampNow() : endClocks.timeStamp\n    lifeCycle.notify(LifeCycleEventType.VIEW_UPDATED, {\n      customTimings,\n      documentVersion,\n      id,\n      name,\n      service,\n      version,\n      context: contextManager.getContext(),\n      loadingType,\n      location,\n      startClocks,\n      commonViewMetrics: getCommonViewMetrics(),\n      initialViewMetrics,\n      duration: elapsed(startClocks.timeStamp, currentEnd),\n      isActive: endClocks === undefined,\n      sessionIsActive,\n      eventCounts,\n    })\n  }\n\n  return {\n    get name() {\n      return name\n    },\n    service,\n    version,\n    contextManager,\n    stopObservable,\n    end(options: { endClocks?: ClocksState; sessionIsActive?: boolean } = {}) {\n      if (endClocks) {\n        // view already ended\n        return\n      }\n      endClocks = options.endClocks ?? clocksNow()\n      sessionIsActive = options.sessionIsActive ?? true\n\n      lifeCycle.notify(LifeCycleEventType.VIEW_ENDED, { endClocks })\n      lifeCycle.notify(LifeCycleEventType.AFTER_VIEW_ENDED, { endClocks })\n      clearInterval(keepAliveIntervalId)\n      setViewEnd(endClocks.relative)\n      stopCommonViewMetricsTracking()\n      pageMayExitSubscription.unsubscribe()\n      triggerViewUpdate()\n      setTimeout(() => {\n        this.stop()\n      }, KEEP_TRACKING_AFTER_VIEW_DELAY)\n    },\n    stop() {\n      stopInitialViewMetricsTracking()\n      stopEventCountsTracking()\n      stopINPTracking()\n      stopObservable.notify()\n    },\n    addTiming(name: string, time: RelativeTime | TimeStamp) {\n      if (endClocks) {\n        return\n      }\n      const relativeTime = looksLikeRelativeTime(time) ? time : elapsed(startClocks.timeStamp, time)\n      customTimings[sanitizeTiming(name)] = relativeTime\n      scheduleViewUpdate()\n    },\n    setViewName(updatedName: string) {\n      name = updatedName\n      triggerViewUpdate()\n    },\n  }\n}\n\n/**\n * Timing name is used as facet path that must contain only letters, digits, or the characters - _ . @ $\n */\nfunction sanitizeTiming(name: string) {\n  const sanitized = name.replace(/[^a-zA-Z0-9-_.@$]/g, '_')\n  if (sanitized !== name) {\n    display.warn(`Invalid timing name: ${name}, sanitized to: ${sanitized}`)\n  }\n  return sanitized\n}\n\nfunction areDifferentLocation(currentLocation: Location, otherLocation: Location) {\n  return (\n    currentLocation.pathname !== otherLocation.pathname ||\n    (!isHashAnAnchor(otherLocation.hash) &&\n      getPathFromHash(otherLocation.hash) !== getPathFromHash(currentLocation.hash))\n  )\n}\n\nfunction isHashAnAnchor(hash: string) {\n  const correspondingId = hash.substring(1)\n  // check if the correspondingId is empty because on Firefox an empty string passed to getElementById() prints a consol warning\n  return correspondingId !== '' && !!document.getElementById(correspondingId)\n}\n\nfunction getPathFromHash(hash: string) {\n  const index = hash.indexOf('?')\n  return index < 0 ? hash : hash.slice(0, index)\n}\n", "import type { Duration, ServerDuration, Observable } from '@datadog/browser-core'\nimport { DISCARDED, HookNames, isEmptyObject, mapValues, toServerDuration } from '@datadog/browser-core'\nimport { discardNegativeDuration } from '../discardNegativeDuration'\nimport type { RecorderApi } from '../../boot/rumPublicApi'\nimport type { RawRumViewEvent, ViewPerformanceData } from '../../rawRumEvent.types'\nimport { RumEventType } from '../../rawRumEvent.types'\nimport type { LifeCycle, RawRumEventCollectedData } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\nimport type { LocationChange } from '../../browser/locationChangeObservable'\nimport type { RumConfiguration } from '../configuration'\nimport type { ViewHistory } from '../contexts/viewHistory'\nimport type { DefaultRumEventAttributes, Hooks } from '../hooks'\nimport type { RumMutationRecord } from '../../browser/domMutationObservable'\nimport { trackViews } from './trackViews'\nimport type { ViewEvent, ViewOptions } from './trackViews'\nimport type { CommonViewMetrics } from './viewMetrics/trackCommonViewMetrics'\nimport type { InitialViewMetrics } from './viewMetrics/trackInitialViewMetrics'\n\nexport function startViewCollection(\n  lifeCycle: LifeCycle,\n  hooks: Hooks,\n  configuration: RumConfiguration,\n  location: Location,\n  domMutationObservable: Observable<RumMutationRecord[]>,\n  pageOpenObservable: Observable<void>,\n  locationChangeObservable: Observable<LocationChange>,\n  recorderApi: RecorderApi,\n  viewHistory: ViewHistory,\n  initialViewOptions?: ViewOptions\n) {\n  lifeCycle.subscribe(LifeCycleEventType.VIEW_UPDATED, (view) =>\n    lifeCycle.notify(LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, processViewUpdate(view, configuration, recorderApi))\n  )\n\n  hooks.register(HookNames.Assemble, ({ startTime, eventType }): DefaultRumEventAttributes | DISCARDED => {\n    const view = viewHistory.findView(startTime)\n\n    if (!view) {\n      return DISCARDED\n    }\n\n    return {\n      type: eventType,\n      service: view.service,\n      version: view.version,\n      context: view.context,\n      view: {\n        id: view.id,\n        name: view.name,\n      },\n    }\n  })\n\n  return trackViews(\n    location,\n    lifeCycle,\n    domMutationObservable,\n    pageOpenObservable,\n    configuration,\n    locationChangeObservable,\n    !configuration.trackViewsManually,\n    initialViewOptions\n  )\n}\n\nfunction processViewUpdate(\n  view: ViewEvent,\n  configuration: RumConfiguration,\n  recorderApi: RecorderApi\n): RawRumEventCollectedData<RawRumViewEvent> {\n  const replayStats = recorderApi.getReplayStats(view.id)\n  const clsDevicePixelRatio = view.commonViewMetrics?.cumulativeLayoutShift?.devicePixelRatio\n  const viewEvent: RawRumViewEvent = {\n    _dd: {\n      document_version: view.documentVersion,\n      replay_stats: replayStats,\n      cls: clsDevicePixelRatio\n        ? {\n            device_pixel_ratio: clsDevicePixelRatio,\n          }\n        : undefined,\n      configuration: {\n        start_session_replay_recording_manually: configuration.startSessionReplayRecordingManually,\n      },\n    },\n    date: view.startClocks.timeStamp,\n    type: RumEventType.VIEW,\n    view: {\n      action: {\n        count: view.eventCounts.actionCount,\n      },\n      frustration: {\n        count: view.eventCounts.frustrationCount,\n      },\n      cumulative_layout_shift: view.commonViewMetrics.cumulativeLayoutShift?.value,\n      cumulative_layout_shift_time: toServerDuration(view.commonViewMetrics.cumulativeLayoutShift?.time),\n      cumulative_layout_shift_target_selector: view.commonViewMetrics.cumulativeLayoutShift?.targetSelector,\n      first_byte: toServerDuration(view.initialViewMetrics.navigationTimings?.firstByte),\n      dom_complete: toServerDuration(view.initialViewMetrics.navigationTimings?.domComplete),\n      dom_content_loaded: toServerDuration(view.initialViewMetrics.navigationTimings?.domContentLoaded),\n      dom_interactive: toServerDuration(view.initialViewMetrics.navigationTimings?.domInteractive),\n      error: {\n        count: view.eventCounts.errorCount,\n      },\n      first_contentful_paint: toServerDuration(view.initialViewMetrics.firstContentfulPaint),\n      first_input_delay: toServerDuration(view.initialViewMetrics.firstInput?.delay),\n      first_input_time: toServerDuration(view.initialViewMetrics.firstInput?.time),\n      first_input_target_selector: view.initialViewMetrics.firstInput?.targetSelector,\n      interaction_to_next_paint: toServerDuration(view.commonViewMetrics.interactionToNextPaint?.value),\n      interaction_to_next_paint_time: toServerDuration(view.commonViewMetrics.interactionToNextPaint?.time),\n      interaction_to_next_paint_target_selector: view.commonViewMetrics.interactionToNextPaint?.targetSelector,\n      is_active: view.isActive,\n      name: view.name,\n      largest_contentful_paint: toServerDuration(view.initialViewMetrics.largestContentfulPaint?.value),\n      largest_contentful_paint_target_selector: view.initialViewMetrics.largestContentfulPaint?.targetSelector,\n      load_event: toServerDuration(view.initialViewMetrics.navigationTimings?.loadEvent),\n      loading_time: discardNegativeDuration(toServerDuration(view.commonViewMetrics.loadingTime)),\n      loading_type: view.loadingType,\n      long_task: {\n        count: view.eventCounts.longTaskCount,\n      },\n      performance: computeViewPerformanceData(view.commonViewMetrics, view.initialViewMetrics),\n      resource: {\n        count: view.eventCounts.resourceCount,\n      },\n      time_spent: toServerDuration(view.duration),\n    },\n    display: view.commonViewMetrics.scroll\n      ? {\n          scroll: {\n            max_depth: view.commonViewMetrics.scroll.maxDepth,\n            max_depth_scroll_top: view.commonViewMetrics.scroll.maxDepthScrollTop,\n            max_scroll_height: view.commonViewMetrics.scroll.maxScrollHeight,\n            max_scroll_height_time: toServerDuration(view.commonViewMetrics.scroll.maxScrollHeightTime),\n          },\n        }\n      : undefined,\n    privacy: {\n      replay_level: configuration.defaultPrivacyLevel,\n    },\n  }\n\n  if (!isEmptyObject(view.customTimings)) {\n    viewEvent.view.custom_timings = mapValues(\n      view.customTimings,\n      toServerDuration as (duration: Duration) => ServerDuration\n    )\n  }\n\n  return {\n    rawRumEvent: viewEvent,\n    startTime: view.startClocks.relative,\n    duration: view.duration,\n    domainContext: {\n      location: view.location,\n    },\n  }\n}\n\nfunction computeViewPerformanceData(\n  { cumulativeLayoutShift, interactionToNextPaint }: CommonViewMetrics,\n  { firstContentfulPaint, firstInput, largestContentfulPaint }: InitialViewMetrics\n): ViewPerformanceData {\n  return {\n    cls: cumulativeLayoutShift && {\n      score: cumulativeLayoutShift.value,\n      timestamp: toServerDuration(cumulativeLayoutShift.time),\n      target_selector: cumulativeLayoutShift.targetSelector,\n      previous_rect: cumulativeLayoutShift.previousRect,\n      current_rect: cumulativeLayoutShift.currentRect,\n    },\n    fcp: firstContentfulPaint && { timestamp: toServerDuration(firstContentfulPaint) },\n    fid: firstInput && {\n      duration: toServerDuration(firstInput.delay),\n      timestamp: toServerDuration(firstInput.time),\n      target_selector: firstInput.targetSelector,\n    },\n    inp: interactionToNextPaint && {\n      duration: toServerDuration(interactionToNextPaint.value),\n      timestamp: toServerDuration(interactionToNextPaint.time),\n      target_selector: interactionToNextPaint.targetSelector,\n    },\n    lcp: largestContentfulPaint && {\n      timestamp: toServerDuration(largestContentfulPaint.value),\n      target_selector: largestContentfulPaint.targetSelector,\n      resource_url: largestContentfulPaint.resourceUrl,\n    },\n  }\n}\n", "import type { RelativeTime, TrackingConsentState } from '@datadog/browser-core'\nimport {\n  BridgeCapability,\n  Observable,\n  SESSION_NOT_TRACKED,\n  bridgeSupports,\n  noop,\n  performDraw,\n  startSessionManager,\n} from '@datadog/browser-core'\nimport type { RumConfiguration } from './configuration'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\n\nexport const enum SessionType {\n  SYNTHETICS = 'synthetics',\n  USER = 'user',\n  CI_TEST = 'ci_test',\n}\n\nexport const RUM_SESSION_KEY = 'rum'\n\nexport interface RumSessionManager {\n  findTrackedSession: (startTime?: RelativeTime) => RumSession | undefined\n  expire: () => void\n  expireObservable: Observable<void>\n  setForcedReplay: () => void\n}\n\nexport type RumSession = {\n  id: string\n  sessionReplay: SessionReplayState\n  anonymousId?: string\n}\n\nexport const enum RumTrackingType {\n  NOT_TRACKED = SESSION_NOT_TRACKED,\n  TRACKED_WITH_SESSION_REPLAY = '1',\n  TRACKED_WITHOUT_SESSION_REPLAY = '2',\n}\n\nexport const enum SessionReplayState {\n  OFF,\n  SAMPLED,\n  FORCED,\n}\n\nexport function startRumSessionManager(\n  configuration: RumConfiguration,\n  lifeCycle: LifeCycle,\n  trackingConsentState: TrackingConsentState\n): RumSessionManager {\n  const sessionManager = startSessionManager(\n    configuration,\n    RUM_SESSION_KEY,\n    (rawTrackingType) => computeTrackingType(configuration, rawTrackingType),\n    trackingConsentState\n  )\n\n  sessionManager.expireObservable.subscribe(() => {\n    lifeCycle.notify(LifeCycleEventType.SESSION_EXPIRED)\n  })\n\n  sessionManager.renewObservable.subscribe(() => {\n    lifeCycle.notify(LifeCycleEventType.SESSION_RENEWED)\n  })\n\n  sessionManager.sessionStateUpdateObservable.subscribe(({ previousState, newState }) => {\n    if (!previousState.forcedReplay && newState.forcedReplay) {\n      const sessionEntity = sessionManager.findSession()\n      if (sessionEntity) {\n        sessionEntity.isReplayForced = true\n      }\n    }\n  })\n  return {\n    findTrackedSession: (startTime) => {\n      const session = sessionManager.findSession(startTime)\n      if (!session || session.trackingType === RumTrackingType.NOT_TRACKED) {\n        return\n      }\n      return {\n        id: session.id,\n        sessionReplay:\n          session.trackingType === RumTrackingType.TRACKED_WITH_SESSION_REPLAY\n            ? SessionReplayState.SAMPLED\n            : session.isReplayForced\n              ? SessionReplayState.FORCED\n              : SessionReplayState.OFF,\n        anonymousId: session.anonymousId,\n      }\n    },\n    expire: sessionManager.expire,\n    expireObservable: sessionManager.expireObservable,\n    setForcedReplay: () => sessionManager.updateSessionState({ forcedReplay: '1' }),\n  }\n}\n\n/**\n * Start a tracked replay session stub\n */\nexport function startRumSessionManagerStub(): RumSessionManager {\n  const session: RumSession = {\n    id: '00000000-aaaa-0000-aaaa-000000000000',\n    sessionReplay: bridgeSupports(BridgeCapability.RECORDS) ? SessionReplayState.SAMPLED : SessionReplayState.OFF,\n  }\n  return {\n    findTrackedSession: () => session,\n    expire: noop,\n    expireObservable: new Observable(),\n    setForcedReplay: noop,\n  }\n}\n\nfunction computeTrackingType(configuration: RumConfiguration, rawTrackingType?: string) {\n  if (hasValidRumSession(rawTrackingType)) {\n    return rawTrackingType\n  }\n  if (!performDraw(configuration.sessionSampleRate)) {\n    return RumTrackingType.NOT_TRACKED\n  }\n  if (!performDraw(configuration.sessionReplaySampleRate)) {\n    return RumTrackingType.TRACKED_WITHOUT_SESSION_REPLAY\n  }\n  return RumTrackingType.TRACKED_WITH_SESSION_REPLAY\n}\n\nfunction hasValidRumSession(trackingType?: string): trackingType is RumTrackingType {\n  return (\n    trackingType === RumTrackingType.NOT_TRACKED ||\n    trackingType === RumTrackingType.TRACKED_WITH_SESSION_REPLAY ||\n    trackingType === RumTrackingType.TRACKED_WITHOUT_SESSION_REPLAY\n  )\n}\n", "import type { Context, Observable, RawError, PageMayExitEvent, Encoder } from '@datadog/browser-core'\nimport { DeflateEncoderStreamId, combine, startBatchWithReplica } from '@datadog/browser-core'\nimport type { RumConfiguration } from '../domain/configuration'\nimport type { LifeCycle } from '../domain/lifeCycle'\nimport { LifeCycleEventType } from '../domain/lifeCycle'\nimport { RumEventType } from '../rawRumEvent.types'\nimport type { RumEvent } from '../rumEvent.types'\n\nexport function startRumBatch(\n  configuration: RumConfiguration,\n  lifeCycle: LifeCycle,\n  reportError: (error: RawError) => void,\n  pageMayExitObservable: Observable<PageMayExitEvent>,\n  sessionExpireObservable: Observable<void>,\n  createEncoder: (streamId: DeflateEncoderStreamId) => Encoder\n) {\n  const replica = configuration.replica\n\n  const batch = startBatchWithReplica(\n    configuration,\n    {\n      endpoint: configuration.rumEndpointBuilder,\n      encoder: createEncoder(DeflateEncoderStreamId.RUM),\n    },\n    replica && {\n      endpoint: replica.rumEndpointBuilder,\n      transformMessage: (message) => combine(message, { application: { id: replica.applicationId } }),\n      encoder: createEncoder(DeflateEncoderStreamId.RUM_REPLICA),\n    },\n    reportError,\n    pageMayExitObservable,\n    sessionExpireObservable\n  )\n\n  lifeCycle.subscribe(LifeCycleEventType.RUM_EVENT_COLLECTED, (serverRumEvent: RumEvent & Context) => {\n    if (serverRumEvent.type === RumEventType.VIEW) {\n      batch.upsert(serverRumEvent, serverRumEvent.view.id)\n    } else {\n      batch.add(serverRumEvent)\n    }\n  })\n\n  return batch\n}\n", "import type { Context } from '@datadog/browser-core'\nimport { getEventBridge } from '@datadog/browser-core'\nimport type { LifeCycle } from '../domain/lifeCycle'\nimport { LifeCycleEventType } from '../domain/lifeCycle'\nimport type { RumEvent } from '../rumEvent.types'\n\nexport function startRumEventBridge(lifeCycle: LifeCycle) {\n  const bridge = getEventBridge<'rum', RumEvent>()!\n\n  lifeCycle.subscribe(LifeCycleEventType.RUM_EVENT_COLLECTED, (serverRumEvent: RumEvent & Context) => {\n    bridge.send('rum', serverRumEvent)\n  })\n}\n", "import type { RelativeTime, Observable } from '@datadog/browser-core'\nimport { SESSION_TIME_OUT_DELAY, relativeNow, createValueHistory, HookNames, DISCARDED } from '@datadog/browser-core'\nimport type { LocationChange } from '../../browser/locationChangeObservable'\nimport type { LifeCycle } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\nimport type { DefaultRumEventAttributes, Hooks } from '../hooks'\n\n/**\n * We want to attach to an event:\n * - the url corresponding to its start\n * - the referrer corresponding to the previous view url (or document referrer for initial view)\n */\n\nexport const URL_CONTEXT_TIME_OUT_DELAY = SESSION_TIME_OUT_DELAY\n\nexport interface UrlContext {\n  url: string\n  referrer: string\n}\n\nexport interface UrlContexts {\n  findUrl: (startTime?: RelativeTime) => UrlContext | undefined\n  stop: () => void\n}\n\nexport function startUrlContexts(\n  lifeCycle: LifeCycle,\n  hooks: Hooks,\n  locationChangeObservable: Observable<LocationChange>,\n  location: Location\n) {\n  const urlContextHistory = createValueHistory<UrlContext>({ expireDelay: URL_CONTEXT_TIME_OUT_DELAY })\n\n  let previousViewUrl: string | undefined\n\n  lifeCycle.subscribe(LifeCycleEventType.BEFORE_VIEW_CREATED, ({ startClocks }) => {\n    const viewUrl = location.href\n    urlContextHistory.add(\n      buildUrlContext({\n        url: viewUrl,\n        referrer: !previousViewUrl ? document.referrer : previousViewUrl,\n      }),\n      startClocks.relative\n    )\n    previousViewUrl = viewUrl\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.AFTER_VIEW_ENDED, ({ endClocks }) => {\n    urlContextHistory.closeActive(endClocks.relative)\n  })\n\n  const locationChangeSubscription = locationChangeObservable.subscribe(({ newLocation }) => {\n    const current = urlContextHistory.find()\n    if (current) {\n      const changeTime = relativeNow()\n      urlContextHistory.closeActive(changeTime)\n      urlContextHistory.add(\n        buildUrlContext({\n          url: newLocation.href,\n          referrer: current.referrer,\n        }),\n        changeTime\n      )\n    }\n  })\n\n  function buildUrlContext({ url, referrer }: { url: string; referrer: string }) {\n    return {\n      url,\n      referrer,\n    }\n  }\n\n  hooks.register(HookNames.Assemble, ({ startTime, eventType }): DefaultRumEventAttributes | DISCARDED => {\n    const urlContext = urlContextHistory.find(startTime)\n\n    if (!urlContext) {\n      return DISCARDED\n    }\n\n    return {\n      type: eventType,\n      view: {\n        url: urlContext.url,\n        referrer: urlContext.referrer,\n      },\n    }\n  })\n\n  return {\n    findUrl: (startTime?: RelativeTime) => urlContextHistory.find(startTime),\n    stop: () => {\n      locationChangeSubscription.unsubscribe()\n      urlContextHistory.stop()\n    },\n  }\n}\n", "import { addEventListener, DOM_EVENT, instrumentMethod, Observable, shallowClone } from '@datadog/browser-core'\nimport type { RumConfiguration } from '../domain/configuration'\n\nexport interface LocationChange {\n  oldLocation: Readonly<Location>\n  newLocation: Readonly<Location>\n}\n\nexport function createLocationChangeObservable(configuration: RumConfiguration, location: Location) {\n  let currentLocation = shallowClone(location)\n\n  return new Observable<LocationChange>((observable) => {\n    const { stop: stopHistoryTracking } = trackHistory(configuration, onLocationChange)\n    const { stop: stopHashTracking } = trackHash(configuration, onLocationChange)\n\n    function onLocationChange() {\n      if (currentLocation.href === location.href) {\n        return\n      }\n      const newLocation = shallowClone(location)\n      observable.notify({\n        newLocation,\n        oldLocation: currentLocation,\n      })\n      currentLocation = newLocation\n    }\n\n    return () => {\n      stopHistoryTracking()\n      stopHashTracking()\n    }\n  })\n}\n\nfunction trackHistory(configuration: RumConfiguration, onHistoryChange: () => void) {\n  const { stop: stopInstrumentingPushState } = instrumentMethod(\n    getHistoryInstrumentationTarget('pushState'),\n    'pushState',\n    ({ onPostCall }) => {\n      onPostCall(onHistoryChange)\n    }\n  )\n  const { stop: stopInstrumentingReplaceState } = instrumentMethod(\n    getHistoryInstrumentationTarget('replaceState'),\n    'replaceState',\n    ({ onPostCall }) => {\n      onPostCall(onHistoryChange)\n    }\n  )\n  const { stop: removeListener } = addEventListener(configuration, window, DOM_EVENT.POP_STATE, onHistoryChange)\n\n  return {\n    stop: () => {\n      stopInstrumentingPushState()\n      stopInstrumentingReplaceState()\n      removeListener()\n    },\n  }\n}\n\nfunction trackHash(configuration: RumConfiguration, onHashChange: () => void) {\n  return addEventListener(configuration, window, DOM_EVENT.HASH_CHANGE, onHashChange)\n}\n\nfunction getHistoryInstrumentationTarget(methodName: 'pushState' | 'replaceState') {\n  // Ideally we should always instument the method on the prototype, however some frameworks (e.g [Next.js](https://github.com/vercel/next.js/blob/d3f5532065f3e3bb84fb54bd2dfd1a16d0f03a21/packages/next/src/client/components/app-router.tsx#L429))\n  // are wrapping the instance method. In that case we should also wrap the instance method.\n  return Object.prototype.hasOwnProperty.call(history, methodName) ? history : History.prototype\n}\n", "import type { ContextValue, Context } from '@datadog/browser-core'\nimport { HookNames, SESSION_TIME_OUT_DELAY, SKIPPED, createValueHistory, isEmptyObject } from '@datadog/browser-core'\nimport type { LifeCycle } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\nimport { RumEventType } from '../../rawRumEvent.types'\nimport type { RumConfiguration } from '../configuration'\nimport type { DefaultRumEventAttributes, Hooks } from '../hooks'\n\nexport const FEATURE_FLAG_CONTEXT_TIME_OUT_DELAY = SESSION_TIME_OUT_DELAY\nexport const BYTES_COMPUTATION_THROTTLING_DELAY = 200\n\nexport type FeatureFlagContext = Context\n\nexport interface FeatureFlagContexts {\n  addFeatureFlagEvaluation: (key: string, value: ContextValue) => void\n}\n\n/**\n * Start feature flag contexts\n *\n * Feature flag contexts follow the life of views.\n * A new context is added when a view is created and ended when the view is ended\n *\n * Note: we choose not to add a new context at each evaluation to save memory\n */\nexport function startFeatureFlagContexts(\n  lifeCycle: LifeCycle,\n  hooks: Hooks,\n  configuration: RumConfiguration\n): FeatureFlagContexts {\n  const featureFlagContexts = createValueHistory<FeatureFlagContext>({\n    expireDelay: FEATURE_FLAG_CONTEXT_TIME_OUT_DELAY,\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.BEFORE_VIEW_CREATED, ({ startClocks }) => {\n    featureFlagContexts.add({}, startClocks.relative)\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.AFTER_VIEW_ENDED, ({ endClocks }) => {\n    featureFlagContexts.closeActive(endClocks.relative)\n  })\n\n  hooks.register(HookNames.Assemble, ({ startTime, eventType }): DefaultRumEventAttributes | SKIPPED => {\n    const trackFeatureFlagsForEvents = (configuration.trackFeatureFlagsForEvents as RumEventType[]).concat([\n      RumEventType.VIEW,\n      RumEventType.ERROR,\n    ])\n    if (!trackFeatureFlagsForEvents.includes(eventType as RumEventType)) {\n      return SKIPPED\n    }\n\n    const featureFlagContext = featureFlagContexts.find(startTime)\n    if (!featureFlagContext || isEmptyObject(featureFlagContext)) {\n      return SKIPPED\n    }\n\n    return {\n      type: eventType,\n      feature_flags: featureFlagContext,\n    }\n  })\n\n  return {\n    addFeatureFlagEvaluation: (key: string, value: ContextValue) => {\n      const currentContext = featureFlagContexts.find()\n      if (currentContext) {\n        currentContext[key] = value\n      }\n    },\n  }\n}\n", "import type { FlushEvent, Observable, Telemetry } from '@datadog/browser-core'\nimport { performDraw, ONE_SECOND, addTelemetryDebug, setInterval } from '@datadog/browser-core'\nimport type { RumConfiguration } from './configuration'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\n\nexport const MEASURES_PERIOD_DURATION = 10 * ONE_SECOND\n\ntype Measure = {\n  min: number\n  max: number\n  sum: number\n}\n\ntype CurrentPeriodMeasures = {\n  batchCount: number\n  batchBytesCount: Measure\n  batchMessagesCount: Measure\n}\n\nlet currentPeriodMeasures: CurrentPeriodMeasures\nlet batchHasRumEvent: boolean\n\nexport function startCustomerDataTelemetry(\n  configuration: RumConfiguration,\n  telemetry: Telemetry,\n  lifeCycle: LifeCycle,\n  batchFlushObservable: Observable<FlushEvent>\n) {\n  const customerDataTelemetryEnabled = telemetry.enabled && performDraw(configuration.customerDataTelemetrySampleRate)\n  if (!customerDataTelemetryEnabled) {\n    return\n  }\n\n  initCurrentPeriodMeasures()\n  batchHasRumEvent = false\n  // We measure the data of every view updates even if there could only be one per batch due to the upsert\n  // It means that contexts bytes count sums can be higher than it really is\n  lifeCycle.subscribe(LifeCycleEventType.RUM_EVENT_COLLECTED, () => {\n    batchHasRumEvent = true\n  })\n\n  batchFlushObservable.subscribe(({ bytesCount, messagesCount }) => {\n    // Don't measure batch that only contains telemetry events to avoid batch sending loop\n    // It could happen because after each batch we are adding a customer data measures telemetry event to the next one\n    if (!batchHasRumEvent) {\n      return\n    }\n    currentPeriodMeasures.batchCount += 1\n    updateMeasure(currentPeriodMeasures.batchBytesCount, bytesCount)\n    updateMeasure(currentPeriodMeasures.batchMessagesCount, messagesCount)\n  })\n\n  setInterval(sendCurrentPeriodMeasures, MEASURES_PERIOD_DURATION)\n}\n\nfunction sendCurrentPeriodMeasures() {\n  if (currentPeriodMeasures.batchCount === 0) {\n    return\n  }\n\n  addTelemetryDebug('Customer data measures', currentPeriodMeasures)\n  initCurrentPeriodMeasures()\n}\n\nfunction createMeasure(): Measure {\n  return { min: Infinity, max: 0, sum: 0 }\n}\n\nfunction updateMeasure(measure: Measure, value: number) {\n  measure.sum += value\n  measure.min = Math.min(measure.min, value)\n  measure.max = Math.max(measure.max, value)\n}\n\nfunction initCurrentPeriodMeasures() {\n  currentPeriodMeasures = {\n    batchCount: 0,\n    batchBytesCount: createMeasure(),\n    batchMessagesCount: createMeasure(),\n  }\n}\n", "import type { Duration, RelativeTime } from '@datadog/browser-core'\nimport {\n  SKIPPED,\n  elapsed,\n  createValueHistory,\n  SESSION_TIME_OUT_DELAY,\n  toServerDuration,\n  addEventListeners,\n  relativeNow,\n  DOM_EVENT,\n  HookNames,\n} from '@datadog/browser-core'\nimport type { RumConfiguration } from '../configuration'\nimport { supportPerformanceTimingEvent, RumPerformanceEntryType } from '../../browser/performanceObservable'\nimport { RumEventType, type PageStateServerEntry } from '../../rawRumEvent.types'\nimport type { DefaultRumEventAttributes, Hooks } from '../hooks'\n\n// Arbitrary value to cap number of element for memory consumption in the browser\nexport const MAX_PAGE_STATE_ENTRIES = 4000\n// Arbitrary value to cap number of element for backend & to save bandwidth\nexport const MAX_PAGE_STATE_ENTRIES_SELECTABLE = 500\n\nexport const PAGE_STATE_CONTEXT_TIME_OUT_DELAY = SESSION_TIME_OUT_DELAY\n\nexport const enum PageState {\n  ACTIVE = 'active',\n  PASSIVE = 'passive',\n  HIDDEN = 'hidden',\n  FROZEN = 'frozen',\n  TERMINATED = 'terminated',\n}\n\nexport type PageStateEntry = { state: PageState; startTime: RelativeTime }\n\nexport interface PageStateHistory {\n  wasInPageStateDuringPeriod: (state: PageState, startTime: RelativeTime, duration: Duration) => boolean\n  addPageState(nextPageState: PageState, startTime?: RelativeTime): void\n  stop: () => void\n}\n\nexport function startPageStateHistory(\n  hooks: Hooks,\n  configuration: RumConfiguration,\n  maxPageStateEntriesSelectable = MAX_PAGE_STATE_ENTRIES_SELECTABLE\n): PageStateHistory {\n  const pageStateEntryHistory = createValueHistory<PageStateEntry>({\n    expireDelay: PAGE_STATE_CONTEXT_TIME_OUT_DELAY,\n    maxEntries: MAX_PAGE_STATE_ENTRIES,\n  })\n\n  let currentPageState: PageState\n\n  if (supportPerformanceTimingEvent(RumPerformanceEntryType.VISIBILITY_STATE)) {\n    const visibilityEntries = performance.getEntriesByType(\n      RumPerformanceEntryType.VISIBILITY_STATE\n    ) as PerformanceEntry[]\n\n    visibilityEntries.forEach((entry) => {\n      const state = entry.name === 'hidden' ? PageState.HIDDEN : PageState.ACTIVE\n      addPageState(state, entry.startTime as RelativeTime)\n    })\n  }\n\n  addPageState(getPageState(), relativeNow())\n\n  const { stop: stopEventListeners } = addEventListeners(\n    configuration,\n    window,\n    [\n      DOM_EVENT.PAGE_SHOW,\n      DOM_EVENT.FOCUS,\n      DOM_EVENT.BLUR,\n      DOM_EVENT.VISIBILITY_CHANGE,\n      DOM_EVENT.RESUME,\n      DOM_EVENT.FREEZE,\n      DOM_EVENT.PAGE_HIDE,\n    ],\n    (event) => {\n      addPageState(computePageState(event), event.timeStamp as RelativeTime)\n    },\n    { capture: true }\n  )\n\n  function addPageState(nextPageState: PageState, startTime = relativeNow()) {\n    if (nextPageState === currentPageState) {\n      return\n    }\n\n    currentPageState = nextPageState\n    pageStateEntryHistory.closeActive(startTime)\n    pageStateEntryHistory.add({ state: currentPageState, startTime }, startTime)\n  }\n\n  function wasInPageStateDuringPeriod(state: PageState, startTime: RelativeTime, duration: Duration) {\n    return pageStateEntryHistory.findAll(startTime, duration).some((pageState) => pageState.state === state)\n  }\n\n  hooks.register(\n    HookNames.Assemble,\n    ({ startTime, duration = 0 as Duration, eventType }): DefaultRumEventAttributes | SKIPPED => {\n      if (eventType === RumEventType.VIEW) {\n        const pageStates = pageStateEntryHistory.findAll(startTime, duration)\n        return {\n          type: eventType,\n          _dd: { page_states: processPageStates(pageStates, startTime, maxPageStateEntriesSelectable) },\n        }\n      }\n\n      if (eventType === RumEventType.ACTION || eventType === RumEventType.ERROR) {\n        return {\n          type: eventType,\n          view: { in_foreground: wasInPageStateDuringPeriod(PageState.ACTIVE, startTime, 0 as Duration) },\n        }\n      }\n\n      return SKIPPED\n    }\n  )\n\n  return {\n    wasInPageStateDuringPeriod,\n    addPageState,\n    stop: () => {\n      stopEventListeners()\n      pageStateEntryHistory.stop()\n    },\n  }\n}\n\nfunction processPageStates(\n  pageStateEntries: PageStateEntry[],\n  eventStartTime: RelativeTime,\n  maxPageStateEntriesSelectable: number\n): PageStateServerEntry[] | undefined {\n  if (pageStateEntries.length === 0) {\n    return\n  }\n\n  return pageStateEntries\n    .slice(-maxPageStateEntriesSelectable)\n    .reverse()\n    .map(({ state, startTime }) => ({\n      state,\n      start: toServerDuration(elapsed(eventStartTime, startTime)),\n    }))\n}\n\nfunction computePageState(event: Event & { type: DOM_EVENT }) {\n  if (event.type === DOM_EVENT.FREEZE) {\n    return PageState.FROZEN\n  } else if (event.type === DOM_EVENT.PAGE_HIDE) {\n    return (event as PageTransitionEvent).persisted ? PageState.FROZEN : PageState.TERMINATED\n  }\n  return getPageState()\n}\n\nfunction getPageState() {\n  if (document.visibilityState === 'hidden') {\n    return PageState.HIDDEN\n  }\n\n  if (document.hasFocus()) {\n    return PageState.ACTIVE\n  }\n\n  return PageState.PASSIVE\n}\n", "import { HookNames, monitor } from '@datadog/browser-core'\nimport type { RumConfiguration } from '../configuration'\nimport type { ViewportDimension } from '../../browser/viewportObservable'\nimport { getViewportDimension, initViewportObservable } from '../../browser/viewportObservable'\nimport type { DefaultRumEventAttributes, Hooks } from '../hooks'\n\nexport type DisplayContext = ReturnType<typeof startDisplayContext>\n\nexport function startDisplayContext(hooks: Hooks, configuration: RumConfiguration) {\n  let viewport: ViewportDimension | undefined\n  // Use requestAnimationFrame to delay the calculation of viewport dimensions until after SDK initialization, preventing long tasks.\n  const animationFrameId = requestAnimationFrame(\n    monitor(() => {\n      viewport = getViewportDimension()\n    })\n  )\n\n  const unsubscribeViewport = initViewportObservable(configuration).subscribe((viewportDimension) => {\n    viewport = viewportDimension\n  }).unsubscribe\n\n  hooks.register(\n    HookNames.Assemble,\n    ({ eventType }): DefaultRumEventAttributes => ({\n      type: eventType,\n      display: viewport ? { viewport } : undefined,\n    })\n  )\n\n  return {\n    stop: () => {\n      unsubscribeViewport()\n      if (animationFrameId) {\n        cancelAnimationFrame(animationFrameId)\n      }\n    },\n  }\n}\n", "import type { Configuration, CookieStore } from '@datadog/browser-core'\nimport {\n  setInterval,\n  clearInterval,\n  Observable,\n  addEventListener,\n  ONE_SECOND,\n  findCommaSeparatedValue,\n  DOM_EVENT,\n} from '@datadog/browser-core'\n\nexport interface CookieStoreWindow extends Window {\n  cookieStore?: CookieStore\n}\n\nexport type CookieObservable = ReturnType<typeof createCookieObservable>\n\nexport function createCookieObservable(configuration: Configuration, cookieName: string) {\n  const detectCookieChangeStrategy = (window as CookieStoreWindow).cookieStore\n    ? listenToCookieStoreChange(configuration)\n    : watchCookieFallback\n\n  return new Observable<string | undefined>((observable) =>\n    detectCookieChangeStrategy(cookieName, (event) => observable.notify(event))\n  )\n}\n\nfunction listenToCookieStoreChange(configuration: Configuration) {\n  return (cookieName: string, callback: (event: string | undefined) => void) => {\n    const listener = addEventListener(\n      configuration,\n      (window as CookieStoreWindow).cookieStore!,\n      DOM_EVENT.CHANGE,\n      (event) => {\n        // Based on our experimentation, we're assuming that entries for the same cookie cannot be in both the 'changed' and 'deleted' arrays.\n        // However, due to ambiguity in the specification, we asked for clarification: https://github.com/WICG/cookie-store/issues/226\n        const changeEvent =\n          event.changed.find((event) => event.name === cookieName) ||\n          event.deleted.find((event) => event.name === cookieName)\n        if (changeEvent) {\n          callback(changeEvent.value)\n        }\n      }\n    )\n    return listener.stop\n  }\n}\n\nexport const WATCH_COOKIE_INTERVAL_DELAY = ONE_SECOND\n\nfunction watchCookieFallback(cookieName: string, callback: (event: string | undefined) => void) {\n  const previousCookieValue = findCommaSeparatedValue(document.cookie, cookieName)\n  const watchCookieIntervalId = setInterval(() => {\n    const cookieValue = findCommaSeparatedValue(document.cookie, cookieName)\n    if (cookieValue !== previousCookieValue) {\n      callback(cookieValue)\n    }\n  }, WATCH_COOKIE_INTERVAL_DELAY)\n\n  return () => {\n    clearInterval(watchCookieIntervalId)\n  }\n}\n", "import { getInitCookie, HookNames, SKIPPED } from '@datadog/browser-core'\nimport type { Configuration } from '@datadog/browser-core'\nimport { createCookieObservable } from '../../browser/cookieObservable'\nimport { SessionType } from '../rumSessionManager'\nimport type { DefaultRumEventAttributes, Hooks } from '../hooks'\n\nexport const CI_VISIBILITY_TEST_ID_COOKIE_NAME = 'datadog-ci-visibility-test-execution-id'\n\nexport interface CiTestWindow extends Window {\n  Cypress?: {\n    env: (key: string) => string | undefined\n  }\n}\n\nexport type CiVisibilityContext = ReturnType<typeof startCiVisibilityContext>\n\nexport function startCiVisibilityContext(\n  configuration: Configuration,\n  hooks: Hooks,\n  cookieObservable = createCookieObservable(configuration, CI_VISIBILITY_TEST_ID_COOKIE_NAME)\n) {\n  let testExecutionId =\n    getInitCookie(CI_VISIBILITY_TEST_ID_COOKIE_NAME) || (window as CiTestWindow).Cypress?.env('traceId')\n\n  const cookieObservableSubscription = cookieObservable.subscribe((value) => {\n    testExecutionId = value\n  })\n\n  hooks.register(HookNames.Assemble, ({ eventType }): DefaultRumEventAttributes | SKIPPED => {\n    if (typeof testExecutionId !== 'string') {\n      return SKIPPED\n    }\n\n    return {\n      type: eventType,\n      session: {\n        type: SessionType.CI_TEST,\n      },\n      ci_test: {\n        test_execution_id: testExecutionId,\n      },\n    }\n  })\n\n  return {\n    stop: () => {\n      cookieObservableSubscription.unsubscribe()\n    },\n  }\n}\n", "import { toServerDuration, relativeToClocks, generateUUID } from '@datadog/browser-core'\nimport type { RawRumLongAnimationFrameEvent } from '../../rawRumEvent.types'\nimport { RumEventType, RumLongTaskEntryType } from '../../rawRumEvent.types'\nimport type { LifeCycle } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\nimport { createPerformanceObservable, RumPerformanceEntryType } from '../../browser/performanceObservable'\nimport type { RumConfiguration } from '../configuration'\n\nexport function startLongAnimationFrameCollection(lifeCycle: LifeCycle, configuration: RumConfiguration) {\n  const performanceResourceSubscription = createPerformanceObservable(configuration, {\n    type: RumPerformanceEntryType.LONG_ANIMATION_FRAME,\n    buffered: true,\n  }).subscribe((entries) => {\n    for (const entry of entries) {\n      const startClocks = relativeToClocks(entry.startTime)\n\n      const rawRumEvent: RawRumLongAnimationFrameEvent = {\n        date: startClocks.timeStamp,\n        long_task: {\n          id: generateUUID(),\n          entry_type: RumLongTaskEntryType.LONG_ANIMATION_FRAME,\n          duration: toServerDuration(entry.duration),\n          blocking_duration: toServerDuration(entry.blockingDuration),\n          first_ui_event_timestamp: toServerDuration(entry.firstUIEventTimestamp),\n          render_start: toServerDuration(entry.renderStart),\n          style_and_layout_start: toServerDuration(entry.styleAndLayoutStart),\n          start_time: toServerDuration(entry.startTime),\n          scripts: entry.scripts.map((script) => ({\n            duration: toServerDuration(script.duration),\n            pause_duration: toServerDuration(script.pauseDuration),\n            forced_style_and_layout_duration: toServerDuration(script.forcedStyleAndLayoutDuration),\n            start_time: toServerDuration(script.startTime),\n            execution_start: toServerDuration(script.executionStart),\n            source_url: script.sourceURL,\n            source_function_name: script.sourceFunctionName,\n            source_char_position: script.sourceCharPosition,\n            invoker: script.invoker,\n            invoker_type: script.invokerType,\n            window_attribution: script.windowAttribution,\n          })),\n        },\n        type: RumEventType.LONG_TASK,\n        _dd: {\n          discarded: false,\n        },\n      }\n\n      lifeCycle.notify(LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, {\n        rawRumEvent,\n        startTime: startClocks.relative,\n        duration: entry.duration,\n        domainContext: { performanceEntry: entry },\n      })\n    }\n  })\n\n  return { stop: () => performanceResourceSubscription.unsubscribe() }\n}\n", "import { toServerDuration, relativeToClocks, generateUUID } from '@datadog/browser-core'\nimport type { RawRumLongTaskEvent } from '../../rawRumEvent.types'\nimport { RumEventType, RumLongTaskEntryType } from '../../rawRumEvent.types'\nimport type { LifeCycle } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\nimport { createPerformanceObservable, RumPerformanceEntryType } from '../../browser/performanceObservable'\nimport type { RumConfiguration } from '../configuration'\nexport function startLongTaskCollection(lifeCycle: LifeCycle, configuration: RumConfiguration) {\n  const performanceLongTaskSubscription = createPerformanceObservable(configuration, {\n    type: RumPerformanceEntryType.LONG_TASK,\n    buffered: true,\n  }).subscribe((entries) => {\n    for (const entry of entries) {\n      if (entry.entryType !== RumPerformanceEntryType.LONG_TASK) {\n        break\n      }\n      if (!configuration.trackLongTasks) {\n        break\n      }\n      const startClocks = relativeToClocks(entry.startTime)\n      const rawRumEvent: RawRumLongTaskEvent = {\n        date: startClocks.timeStamp,\n        long_task: {\n          id: generateUUID(),\n          entry_type: RumLongTaskEntryType.LONG_TASK,\n          duration: toServerDuration(entry.duration),\n        },\n        type: RumEventType.LONG_TASK,\n        _dd: {\n          discarded: false,\n        },\n      }\n      lifeCycle.notify(LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, {\n        rawRumEvent,\n        startTime: startClocks.relative,\n        duration: entry.duration,\n        domainContext: { performanceEntry: entry },\n      })\n    }\n  })\n\n  return {\n    stop() {\n      performanceLongTaskSubscription.unsubscribe()\n    },\n  }\n}\n", "import {\n  SKIPPED,\n  getSyntheticsResultId,\n  getSyntheticsTestId,\n  HookNames,\n  willSyntheticsInjectRum,\n  isSyntheticsTest,\n} from '@datadog/browser-core'\nimport { SessionType } from '../rumSessionManager'\nimport type { DefaultRumEventAttributes, Hooks } from '../hooks'\n\nexport function startSyntheticsContext(hooks: Hooks) {\n  hooks.register(HookNames.Assemble, ({ eventType }): DefaultRumEventAttributes | SKIPPED => {\n    if (!isSyntheticsTest()) {\n      return SKIPPED\n    }\n\n    const testId = getSyntheticsTestId()\n    const resultId = getSyntheticsResultId()\n\n    return {\n      type: eventType,\n      session: {\n        type: SessionType.SYNTHETICS,\n      },\n      synthetics: {\n        test_id: testId!,\n        result_id: resultId!,\n        injected: willSyntheticsInjectRum(),\n      },\n    }\n  })\n}\n", "import { sanitize, deepClone, getType, objectEntries } from '@datadog/browser-core'\nimport type { Context } from '@datadog/browser-core'\n\nexport type ModifiableFieldPaths = Record<string, 'string' | 'object'>\n\n/**\n * Allows declaring and enforcing modifications to specific fields of an object.\n * Only supports modifying properties of an object (even if nested in an array).\n * Does not support array manipulation (adding/removing items).\n */\nexport function limitModification<T extends Context, Result>(\n  object: T,\n  modifiableFieldPaths: ModifiableFieldPaths,\n  modifier: (object: T) => Result\n): Result | undefined {\n  const clone = deepClone(object)\n  const result = modifier(clone)\n\n  objectEntries(modifiableFieldPaths).forEach(([fieldPath, fieldType]) =>\n    // Traverse both object and clone simultaneously up to the path and apply the modification from the clone to the original object when the type is valid\n    setValueAtPath(object, clone, fieldPath.split(/\\.|(?=\\[\\])/), fieldType)\n  )\n\n  return result\n}\n\nfunction setValueAtPath(object: unknown, clone: unknown, pathSegments: string[], fieldType: 'string' | 'object') {\n  const [field, ...restPathSegments] = pathSegments\n\n  if (field === '[]') {\n    if (Array.isArray(object) && Array.isArray(clone)) {\n      object.forEach((item, i) => setValueAtPath(item, clone[i], restPathSegments, fieldType))\n    }\n\n    return\n  }\n\n  if (!isValidObject(object) || !isValidObject(clone)) {\n    return\n  }\n\n  if (restPathSegments.length > 0) {\n    return setValueAtPath(object[field], clone[field], restPathSegments, fieldType)\n  }\n\n  setNestedValue(object, field, clone[field], fieldType)\n}\n\nfunction setNestedValue(\n  object: Record<string, unknown>,\n  field: string,\n  value: unknown,\n  fieldType: 'string' | 'object'\n) {\n  const newType = getType(value)\n\n  if (newType === fieldType) {\n    object[field] = sanitize(value)\n  } else if (fieldType === 'object' && (newType === 'undefined' || newType === 'null')) {\n    object[field] = {}\n  }\n}\n\nfunction isValidObject(object: unknown): object is Record<string, unknown> {\n  return getType(object) === 'object'\n}\n", "import type { Context, RawError, EventRateLimiter } from '@datadog/browser-core'\nimport {\n  combine,\n  isEmptyObject,\n  display,\n  createEventRateLimiter,\n  isExperimentalFeatureEnabled,\n  ExperimentalFeature,\n  HookNames,\n  DISCARDED,\n} from '@datadog/browser-core'\nimport type { RumEventDomainContext } from '../domainContext.types'\nimport { RumEventType } from '../rawRumEvent.types'\nimport type { RumEvent } from '../rumEvent.types'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\nimport type { RumConfiguration } from './configuration'\nimport type { ModifiableFieldPaths } from './limitModification'\nimport { limitModification } from './limitModification'\nimport type { Hooks } from './hooks'\n\nconst VIEW_MODIFIABLE_FIELD_PATHS: ModifiableFieldPaths = {\n  'view.name': 'string',\n  'view.url': 'string',\n  'view.referrer': 'string',\n}\n\nconst USER_CUSTOMIZABLE_FIELD_PATHS: ModifiableFieldPaths = {\n  context: 'object',\n}\n\nconst ROOT_MODIFIABLE_FIELD_PATHS: ModifiableFieldPaths = {\n  service: 'string',\n  version: 'string',\n}\n\nlet modifiableFieldPathsByEvent: { [key in RumEventType]: ModifiableFieldPaths }\n\nexport function startRumAssembly(\n  configuration: RumConfiguration,\n  lifeCycle: LifeCycle,\n  hooks: Hooks,\n  reportError: (error: RawError) => void\n) {\n  modifiableFieldPathsByEvent = {\n    [RumEventType.VIEW]: {\n      'view.performance.lcp.resource_url': 'string',\n      ...USER_CUSTOMIZABLE_FIELD_PATHS,\n      ...VIEW_MODIFIABLE_FIELD_PATHS,\n      ...ROOT_MODIFIABLE_FIELD_PATHS,\n    },\n    [RumEventType.ERROR]: {\n      'error.message': 'string',\n      'error.stack': 'string',\n      'error.resource.url': 'string',\n      'error.fingerprint': 'string',\n      ...USER_CUSTOMIZABLE_FIELD_PATHS,\n      ...VIEW_MODIFIABLE_FIELD_PATHS,\n      ...ROOT_MODIFIABLE_FIELD_PATHS,\n    },\n    [RumEventType.RESOURCE]: {\n      'resource.url': 'string',\n      ...(isExperimentalFeatureEnabled(ExperimentalFeature.WRITABLE_RESOURCE_GRAPHQL)\n        ? { 'resource.graphql': 'object' }\n        : {}),\n      ...USER_CUSTOMIZABLE_FIELD_PATHS,\n      ...VIEW_MODIFIABLE_FIELD_PATHS,\n      ...ROOT_MODIFIABLE_FIELD_PATHS,\n    },\n    [RumEventType.ACTION]: {\n      'action.target.name': 'string',\n      ...USER_CUSTOMIZABLE_FIELD_PATHS,\n      ...VIEW_MODIFIABLE_FIELD_PATHS,\n      ...ROOT_MODIFIABLE_FIELD_PATHS,\n    },\n    [RumEventType.LONG_TASK]: {\n      'long_task.scripts[].source_url': 'string',\n      'long_task.scripts[].invoker': 'string',\n      ...USER_CUSTOMIZABLE_FIELD_PATHS,\n      ...VIEW_MODIFIABLE_FIELD_PATHS,\n    },\n    [RumEventType.VITAL]: {\n      ...USER_CUSTOMIZABLE_FIELD_PATHS,\n      ...VIEW_MODIFIABLE_FIELD_PATHS,\n    },\n  }\n  const eventRateLimiters = {\n    [RumEventType.ERROR]: createEventRateLimiter(\n      RumEventType.ERROR,\n      configuration.eventRateLimiterThreshold,\n      reportError\n    ),\n    [RumEventType.ACTION]: createEventRateLimiter(\n      RumEventType.ACTION,\n      configuration.eventRateLimiterThreshold,\n      reportError\n    ),\n    [RumEventType.VITAL]: createEventRateLimiter(\n      RumEventType.VITAL,\n      configuration.eventRateLimiterThreshold,\n      reportError\n    ),\n  }\n\n  lifeCycle.subscribe(\n    LifeCycleEventType.RAW_RUM_EVENT_COLLECTED,\n    ({ startTime, duration, rawRumEvent, domainContext, customerContext }) => {\n      const defaultRumEventAttributes = hooks.triggerHook(HookNames.Assemble, {\n        eventType: rawRumEvent.type,\n        startTime,\n        duration,\n      })!\n\n      if (defaultRumEventAttributes === DISCARDED) {\n        return\n      }\n\n      const serverRumEvent = combine(defaultRumEventAttributes, { context: customerContext }, rawRumEvent) as RumEvent &\n        Context\n\n      if (shouldSend(serverRumEvent, configuration.beforeSend, domainContext, eventRateLimiters)) {\n        if (isEmptyObject(serverRumEvent.context!)) {\n          delete serverRumEvent.context\n        }\n        lifeCycle.notify(LifeCycleEventType.RUM_EVENT_COLLECTED, serverRumEvent)\n      }\n    }\n  )\n}\n\nfunction shouldSend(\n  event: RumEvent & Context,\n  beforeSend: RumConfiguration['beforeSend'],\n  domainContext: RumEventDomainContext,\n  eventRateLimiters: { [key in RumEventType]?: EventRateLimiter }\n) {\n  if (beforeSend) {\n    const result = limitModification(event, modifiableFieldPathsByEvent[event.type], (event) =>\n      beforeSend(event, domainContext)\n    )\n    if (result === false && event.type !== RumEventType.VIEW) {\n      return false\n    }\n    if (result === false) {\n      display.warn(\"Can't dismiss view events using beforeSend!\")\n    }\n  }\n\n  const rateLimitReached = eventRateLimiters[event.type]?.isLimitReached()\n\n  return !rateLimitReached\n}\n", "import { DISCARDED, HookNames } from '@datadog/browser-core'\nimport { SessionReplayState, SessionType } from '../rumSessionManager'\nimport type { RumSessionManager } from '../rumSessionManager'\nimport { RumEventType } from '../../rawRumEvent.types'\nimport type { RecorderApi } from '../../boot/rumPublicApi'\nimport type { DefaultRumEventAttributes, Hooks } from '../hooks'\nimport type { ViewHistory } from './viewHistory'\n\nexport function startSessionContext(\n  hooks: Hooks,\n  sessionManager: RumSessionManager,\n  recorderApi: RecorderApi,\n  viewHistory: ViewHistory\n) {\n  hooks.register(HookNames.Assemble, ({ eventType, startTime }): DefaultRumEventAttributes | DISCARDED => {\n    const session = sessionManager.findTrackedSession(startTime)\n    const view = viewHistory.findView(startTime)\n\n    if (!session || !view) {\n      return DISCARDED\n    }\n\n    let hasReplay\n    let sampledForReplay\n    let isActive\n    if (eventType === RumEventType.VIEW) {\n      hasReplay = recorderApi.getReplayStats(view.id) ? true : undefined\n      sampledForReplay = session.sessionReplay === SessionReplayState.SAMPLED\n      isActive = view.sessionIsActive ? undefined : false\n    } else {\n      hasReplay = recorderApi.isRecording() ? true : undefined\n    }\n\n    return {\n      type: eventType,\n      session: {\n        id: session.id,\n        type: SessionType.USER,\n        has_replay: hasReplay,\n        sampled_for_replay: sampledForReplay,\n        is_active: isActive,\n      },\n    }\n  })\n}\n", "import { getConnectivity, HookNames } from '@datadog/browser-core'\nimport type { DefaultRumEventAttributes, Hooks } from '../hooks'\n\nexport function startConnectivityContext(hooks: Hooks) {\n  hooks.register(\n    HookNames.Assemble,\n    ({ eventType }): DefaultRumEventAttributes => ({\n      type: eventType,\n      connectivity: getConnectivity(),\n    })\n  )\n}\n", "import { canUseEventBridge, currentDrift, HookNames, round, timeStampNow } from '@datadog/browser-core'\nimport type { RumConfiguration } from '../configuration'\nimport type { DefaultRumEventAttributes, Hooks } from '../hooks'\n\n// replaced at build time\ndeclare const __BUILD_ENV__SDK_VERSION__: string\n\nexport function startDefaultContext(\n  hooks: Hooks,\n  configuration: RumConfiguration,\n  sdkName: 'rum' | 'rum-slim' | 'rum-synthetics' | undefined\n) {\n  hooks.register(\n    HookNames.Assemble,\n    ({ eventType }): DefaultRumEventAttributes => ({\n      type: eventType,\n      _dd: {\n        format_version: 2,\n        drift: currentDrift(),\n        configuration: {\n          session_sample_rate: round(configuration.sessionSampleRate, 3),\n          session_replay_sample_rate: round(configuration.sessionReplaySampleRate, 3),\n          profiling_sample_rate: round(configuration.profilingSampleRate, 3),\n        },\n        browser_sdk_version: canUseEventBridge() ? __BUILD_ENV__SDK_VERSION__ : undefined,\n        sdk_name: sdkName,\n      },\n      application: {\n        id: configuration.applicationId,\n      },\n      date: timeStampNow(),\n      source: 'browser',\n    })\n  )\n}\n", "import type {\n  DISCARDED,\n  Duration,\n  HookNamesAsConst,\n  RecursivePartialExcept,\n  RelativeTime,\n  SKIPPED,\n} from '@datadog/browser-core'\nimport { abstractHooks } from '@datadog/browser-core'\nimport type { RumEvent } from '../rumEvent.types'\n\n// Define a partial RUM event type.\n// Ensuring the `type` field is always present improves type checking, especially in conditional logic in hooks (e.g., `if (eventType === 'view')`).\nexport type DefaultRumEventAttributes = RecursivePartialExcept<RumEvent, 'type'>\n\nexport type HookCallbackMap = {\n  [HookNamesAsConst.ASSEMBLE]: (param: {\n    eventType: RumEvent['type']\n    startTime: RelativeTime\n    duration?: Duration | undefined\n  }) => DefaultRumEventAttributes | SKIPPED | DISCARDED\n}\n\nexport type Hooks = ReturnType<typeof createHooks>\n\nexport const createHooks = abstractHooks<HookCallbackMap, DefaultRumEventAttributes>\n", "import type { Context, Duration, RelativeTime } from '@datadog/browser-core'\nimport type { RumEventDomainContext } from '../../domainContext.types'\nimport type { LifeCycle } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\n\nimport type {\n  RawRumActionEvent,\n  RawRumErrorEvent,\n  RawRumLongAnimationFrameEvent,\n  RawRumLongTaskEvent,\n  RawRumResourceEvent,\n  RawRumVitalEvent,\n} from '../../rawRumEvent.types'\nimport { RumEventType } from '../../rawRumEvent.types'\n\nconst allowedEventTypes = [\n  RumEventType.ACTION,\n  RumEventType.ERROR,\n  RumEventType.LONG_TASK,\n  RumEventType.RESOURCE,\n  RumEventType.VITAL,\n] as const\n\nexport type AllowedRawRumEvent = (\n  | RawRumErrorEvent\n  | RawRumResourceEvent\n  | RawRumLongTaskEvent\n  | RawRumLongAnimationFrameEvent\n  | RawRumActionEvent\n  | RawRumVitalEvent\n) & { context?: Context }\n\nexport function startEventCollection(lifeCycle: LifeCycle) {\n  return {\n    addEvent: (\n      startTime: RelativeTime,\n      event: AllowedRawRumEvent,\n      domainContext: RumEventDomainContext,\n      duration?: Duration\n    ) => {\n      if (!allowedEventTypes.includes(event.type)) {\n        return\n      }\n\n      lifeCycle.notify(LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, {\n        startTime,\n        rawRumEvent: event,\n        domainContext,\n        duration,\n      })\n    },\n  }\n}\n", "import type { Observable, RawError, DeflateEncoderStreamId, Encoder, TrackingConsentState } from '@datadog/browser-core'\nimport {\n  sendToExtension,\n  createPageMayExitObservable,\n  TelemetryService,\n  startTelemetry,\n  canUseEventBridge,\n  addTelemetryDebug,\n  startAccountContext,\n  startGlobalContext,\n  startUserContext,\n} from '@datadog/browser-core'\nimport type { RumMutationRecord } from '../browser/domMutationObservable'\nimport { createDOMMutationObservable } from '../browser/domMutationObservable'\nimport { createWindowOpenObservable } from '../browser/windowOpenObservable'\nimport { startInternalContext } from '../domain/contexts/internalContext'\nimport { LifeCycle, LifeCycleEventType } from '../domain/lifeCycle'\nimport { startViewHistory } from '../domain/contexts/viewHistory'\nimport { startRequestCollection } from '../domain/requestCollection'\nimport { startActionCollection } from '../domain/action/actionCollection'\nimport { startErrorCollection } from '../domain/error/errorCollection'\nimport { startResourceCollection } from '../domain/resource/resourceCollection'\nimport { startViewCollection } from '../domain/view/viewCollection'\nimport { startRumSessionManager, startRumSessionManagerStub } from '../domain/rumSessionManager'\nimport { startRumBatch } from '../transport/startRumBatch'\nimport { startRumEventBridge } from '../transport/startRumEventBridge'\nimport { startUrlContexts } from '../domain/contexts/urlContexts'\nimport { createLocationChangeObservable } from '../browser/locationChangeObservable'\nimport type { RumConfiguration } from '../domain/configuration'\nimport type { ViewOptions } from '../domain/view/trackViews'\nimport { startFeatureFlagContexts } from '../domain/contexts/featureFlagContext'\nimport { startCustomerDataTelemetry } from '../domain/startCustomerDataTelemetry'\nimport type { PageStateHistory } from '../domain/contexts/pageStateHistory'\nimport { startPageStateHistory } from '../domain/contexts/pageStateHistory'\nimport { startDisplayContext } from '../domain/contexts/displayContext'\nimport type { CustomVitalsState } from '../domain/vital/vitalCollection'\nimport { startVitalCollection } from '../domain/vital/vitalCollection'\nimport { startCiVisibilityContext } from '../domain/contexts/ciVisibilityContext'\nimport { startLongAnimationFrameCollection } from '../domain/longAnimationFrame/longAnimationFrameCollection'\nimport { RumPerformanceEntryType, supportPerformanceTimingEvent } from '../browser/performanceObservable'\nimport { startLongTaskCollection } from '../domain/longTask/longTaskCollection'\nimport { startSyntheticsContext } from '../domain/contexts/syntheticsContext'\nimport { startRumAssembly } from '../domain/assembly'\nimport { startSessionContext } from '../domain/contexts/sessionContext'\nimport { startConnectivityContext } from '../domain/contexts/connectivityContext'\nimport { startDefaultContext } from '../domain/contexts/defaultContext'\nimport type { Hooks } from '../domain/hooks'\nimport { createHooks } from '../domain/hooks'\nimport { startEventCollection } from '../domain/event/eventCollection'\nimport type { RecorderApi, ProfilerApi } from './rumPublicApi'\n\nexport type StartRum = typeof startRum\nexport type StartRumResult = ReturnType<StartRum>\n\nexport function startRum(\n  configuration: RumConfiguration,\n  recorderApi: RecorderApi,\n  profilerApi: ProfilerApi,\n  initialViewOptions: ViewOptions | undefined,\n  createEncoder: (streamId: DeflateEncoderStreamId) => Encoder,\n\n  // `startRum` and its subcomponents assume tracking consent is granted initially and starts\n  // collecting logs unconditionally. As such, `startRum` should be called with a\n  // `trackingConsentState` set to \"granted\".\n  trackingConsentState: TrackingConsentState,\n  customVitalsState: CustomVitalsState,\n  sdkName: 'rum' | 'rum-slim' | 'rum-synthetics' | undefined\n) {\n  const cleanupTasks: Array<() => void> = []\n  const lifeCycle = new LifeCycle()\n  const hooks = createHooks()\n\n  lifeCycle.subscribe(LifeCycleEventType.RUM_EVENT_COLLECTED, (event) => sendToExtension('rum', event))\n\n  const reportError = (error: RawError) => {\n    lifeCycle.notify(LifeCycleEventType.RAW_ERROR_COLLECTED, { error })\n    addTelemetryDebug('Error reported to customer', { 'error.message': error.message })\n  }\n\n  const pageMayExitObservable = createPageMayExitObservable(configuration)\n  const pageMayExitSubscription = pageMayExitObservable.subscribe((event) => {\n    lifeCycle.notify(LifeCycleEventType.PAGE_MAY_EXIT, event)\n  })\n  cleanupTasks.push(() => pageMayExitSubscription.unsubscribe())\n\n  const telemetry = startTelemetry(\n    TelemetryService.RUM,\n    configuration,\n    reportError,\n    pageMayExitObservable,\n    createEncoder\n  )\n  cleanupTasks.push(telemetry.stop)\n  telemetry.setContextProvider('application.id', () => configuration.applicationId)\n\n  const session = !canUseEventBridge()\n    ? startRumSessionManager(configuration, lifeCycle, trackingConsentState)\n    : startRumSessionManagerStub()\n\n  telemetry.setContextProvider('session.id', () => session.findTrackedSession()?.id)\n  telemetry.setContextProvider('usr.anonymous_id', () => session.findTrackedSession()?.anonymousId)\n\n  if (!canUseEventBridge()) {\n    const batch = startRumBatch(\n      configuration,\n      lifeCycle,\n      reportError,\n      pageMayExitObservable,\n      session.expireObservable,\n      createEncoder\n    )\n    cleanupTasks.push(() => batch.stop())\n    startCustomerDataTelemetry(configuration, telemetry, lifeCycle, batch.flushObservable)\n  } else {\n    startRumEventBridge(lifeCycle)\n  }\n\n  const domMutationObservable = createDOMMutationObservable()\n  const locationChangeObservable = createLocationChangeObservable(configuration, location)\n  const { observable: windowOpenObservable, stop: stopWindowOpen } = createWindowOpenObservable()\n  cleanupTasks.push(stopWindowOpen)\n\n  startDefaultContext(hooks, configuration, sdkName)\n  const pageStateHistory = startPageStateHistory(hooks, configuration)\n  const viewHistory = startViewHistory(lifeCycle)\n  cleanupTasks.push(() => viewHistory.stop())\n  telemetry.setContextProvider('view.id', () => viewHistory.findView()?.id)\n  const urlContexts = startUrlContexts(lifeCycle, hooks, locationChangeObservable, location)\n  cleanupTasks.push(() => urlContexts.stop())\n  const featureFlagContexts = startFeatureFlagContexts(lifeCycle, hooks, configuration)\n  startSessionContext(hooks, session, recorderApi, viewHistory)\n  startConnectivityContext(hooks)\n  const globalContext = startGlobalContext(hooks, configuration, 'rum', true)\n  const userContext = startUserContext(hooks, configuration, session, 'rum')\n  const accountContext = startAccountContext(hooks, configuration, 'rum')\n\n  const {\n    actionContexts,\n    addAction,\n    addEvent,\n    stop: stopRumEventCollection,\n  } = startRumEventCollection(\n    lifeCycle,\n    hooks,\n    configuration,\n    pageStateHistory,\n    domMutationObservable,\n    windowOpenObservable,\n    reportError\n  )\n  cleanupTasks.push(stopRumEventCollection)\n  telemetry.setContextProvider('action.id', () => actionContexts.findActionId())\n\n  const {\n    addTiming,\n    startView,\n    setViewName,\n    setViewContext,\n    setViewContextProperty,\n    getViewContext,\n    stop: stopViewCollection,\n  } = startViewCollection(\n    lifeCycle,\n    hooks,\n    configuration,\n    location,\n    domMutationObservable,\n    windowOpenObservable,\n    locationChangeObservable,\n    recorderApi,\n    viewHistory,\n    initialViewOptions\n  )\n\n  cleanupTasks.push(stopViewCollection)\n\n  const { stop: stopResourceCollection } = startResourceCollection(lifeCycle, configuration, pageStateHistory)\n  cleanupTasks.push(stopResourceCollection)\n\n  if (configuration.trackLongTasks) {\n    if (supportPerformanceTimingEvent(RumPerformanceEntryType.LONG_ANIMATION_FRAME)) {\n      const { stop: stopLongAnimationFrameCollection } = startLongAnimationFrameCollection(lifeCycle, configuration)\n      cleanupTasks.push(stopLongAnimationFrameCollection)\n    } else {\n      startLongTaskCollection(lifeCycle, configuration)\n    }\n  }\n\n  const { addError } = startErrorCollection(lifeCycle, configuration)\n\n  startRequestCollection(lifeCycle, configuration, session, userContext, accountContext)\n\n  const vitalCollection = startVitalCollection(lifeCycle, pageStateHistory, customVitalsState)\n  const internalContext = startInternalContext(\n    configuration.applicationId,\n    session,\n    viewHistory,\n    actionContexts,\n    urlContexts\n  )\n\n  // Add Clean-up tasks for Profiler API.\n  cleanupTasks.push(() => profilerApi.stop())\n\n  return {\n    addAction,\n    addEvent,\n    addError,\n    addTiming,\n    addFeatureFlagEvaluation: featureFlagContexts.addFeatureFlagEvaluation,\n    startView,\n    setViewContext,\n    setViewContextProperty,\n    getViewContext,\n    setViewName,\n    lifeCycle,\n    viewHistory,\n    session,\n    stopSession: () => session.expire(),\n    getInternalContext: internalContext.get,\n    startDurationVital: vitalCollection.startDurationVital,\n    stopDurationVital: vitalCollection.stopDurationVital,\n    addDurationVital: vitalCollection.addDurationVital,\n    globalContext,\n    userContext,\n    accountContext,\n    stop: () => {\n      cleanupTasks.forEach((task) => task())\n    },\n    hooks,\n  }\n}\n\nexport function startRumEventCollection(\n  lifeCycle: LifeCycle,\n  hooks: Hooks,\n  configuration: RumConfiguration,\n  pageStateHistory: PageStateHistory,\n  domMutationObservable: Observable<RumMutationRecord[]>,\n  windowOpenObservable: Observable<void>,\n  reportError: (error: RawError) => void\n) {\n  const actionCollection = startActionCollection(\n    lifeCycle,\n    hooks,\n    domMutationObservable,\n    windowOpenObservable,\n    configuration\n  )\n\n  const eventCollection = startEventCollection(lifeCycle)\n\n  const displayContext = startDisplayContext(hooks, configuration)\n  const ciVisibilityContext = startCiVisibilityContext(configuration, hooks)\n  startSyntheticsContext(hooks)\n\n  startRumAssembly(configuration, lifeCycle, hooks, reportError)\n\n  return {\n    pageStateHistory,\n    addAction: actionCollection.addAction,\n    addEvent: eventCollection.addEvent,\n    actionContexts: actionCollection.actionContexts,\n    stop: () => {\n      actionCollection.stop()\n      ciVisibilityContext.stop()\n      displayContext.stop()\n      pageStateHistory.stop()\n    },\n  }\n}\n", "import { INTAKE_SITE_STAGING, INTAKE_SITE_US1, INTAKE_SITE_EU1 } from '@datadog/browser-core'\nimport type { RumConfiguration } from './configuration'\nimport type { ViewHistoryEntry } from './contexts/viewHistory'\nimport type { RumSession } from './rumSessionManager'\n\nexport function getSessionReplayUrl(\n  configuration: RumConfiguration,\n  {\n    session,\n    viewContext,\n    errorType,\n  }: {\n    session?: RumSession\n    viewContext?: ViewHistoryEntry\n    errorType?: string\n  }\n): string {\n  const sessionId = session ? session.id : 'no-session-id'\n  const parameters: string[] = []\n  if (errorType !== undefined) {\n    parameters.push(`error-type=${errorType}`)\n  }\n  if (viewContext) {\n    parameters.push(`seed=${viewContext.id}`)\n    parameters.push(`from=${viewContext.startClocks.timeStamp}`)\n  }\n\n  const origin = getDatadogSiteUrl(configuration)\n  const path = `/rum/replay/sessions/${sessionId}`\n  return `${origin}${path}?${parameters.join('&')}`\n}\n\nexport function getDatadogSiteUrl(rumConfiguration: RumConfiguration) {\n  const site = rumConfiguration.site\n  const subdomain = rumConfiguration.subdomain || getSiteDefaultSubdomain(rumConfiguration)\n  return `https://${subdomain ? `${subdomain}.` : ''}${site}`\n}\n\nfunction getSiteDefaultSubdomain(configuration: RumConfiguration): string | undefined {\n  switch (configuration.site) {\n    case INTAKE_SITE_US1:\n    case INTAKE_SITE_EU1:\n      return 'app'\n    case INTAKE_SITE_STAGING:\n      return 'dd'\n    default:\n      return undefined\n  }\n}\n"],
  "mappings": "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",
  "names": ["e", "observer", "send", "configuration", "ExperimentalFeature", "merged", "navigator", "telemetryService", "runtimeEnvInfo", "cleanupTasks", "computeTrackingType", "observer", "endTime", "computeTrackingType", "tracingOption", "_a", "bufferContextCalls", "options", "configuration", "RumPerformanceEntryType", "observer", "observer", "element", "sibling", "relativeTimestamp", "history", "isRage", "document", "endTime", "location", "locationChangeObservable", "name", "location", "RUM_SESSION_KEY", "location", "location", "event", "beforeSend", "event", "cleanupTasks"]
}
