import {
  RumPerformanceEntryType,
  supportPerformanceTimingEvent
} from "./chunk-ATFHSDKA.js";
import {
  addEventListener,
  addTelemetryDebug,
  clearTimeout,
  clocksNow,
  clocksOrigin,
  currentDrift,
  display,
  elapsed,
  getGlobalObject,
  monitorError,
  relativeToClocks,
  setTimeout
} from "./chunk-Z3Q3XVIP.js";
import "./chunk-5WRI5ZAA.js";

// node_modules/@datadog/browser-rum/esm/domain/profiling/utils/getNumberOfSamples.js
function getNumberOfSamples(samples) {
  let numberOfSamples = 0;
  for (const sample of samples) {
    if (sample.stackId !== void 0) {
      numberOfSamples++;
    }
  }
  return numberOfSamples;
}

// node_modules/@datadog/browser-rum/esm/domain/profiling/utils/longTaskRegistry.js
var registry = /* @__PURE__ */ new Map();
function setLongTaskId(longTaskId, startTime) {
  registry.set(startTime, longTaskId);
}
function getLongTaskId(startTime) {
  return registry.get(startTime);
}
function cleanupLongTaskRegistryAfterCollection(collectionRelativeTime) {
  for (const performanceStartTime of registry.keys()) {
    if (performanceStartTime < collectionRelativeTime) {
      registry.delete(performanceStartTime);
    }
  }
}

// node_modules/@datadog/browser-rum/esm/domain/profiling/profilingCorrelation.js
function mayStoreLongTaskIdForProfilerCorrelation({ rawRumEvent, startTime }) {
  if (rawRumEvent.type !== "long_task") {
    return;
  }
  const longTaskId = rawRumEvent.long_task.id;
  setLongTaskId(longTaskId, startTime);
}

// node_modules/@datadog/browser-rum/esm/domain/profiling/transport/transport.js
var sendProfile = (profilerTrace, endpointBuilder, applicationId, sessionId) => {
  const event = buildProfileEvent(profilerTrace, endpointBuilder, applicationId, sessionId);
  const payload = buildProfilingPayload(profilerTrace, event);
  const profilingIntakeURL = endpointBuilder.build("fetch", payload);
  addTelemetryDebug("Sending profile to public profiling intake", { profilingIntakeURL, applicationId, sessionId });
  return fetch(profilingIntakeURL, {
    body: payload.data,
    method: "POST"
  });
};
function buildProfileEvent(profilerTrace, endpointBuilder, applicationId, sessionId) {
  const tags = endpointBuilder.tags;
  const profileAttributes = buildProfileEventAttributes(profilerTrace, applicationId, sessionId);
  const profileEventTags = buildProfileEventTags(tags);
  const profileEvent = {
    ...profileAttributes,
    attachments: ["wall-time.json"],
    start: new Date(profilerTrace.startClocks.timeStamp).toISOString(),
    end: new Date(profilerTrace.endClocks.timeStamp).toISOString(),
    family: "chrome",
    runtime: "chrome",
    format: "json",
    version: 4,
    // Ingestion event version (not the version application tag)
    tags_profiler: profileEventTags.join(","),
    _dd: {
      clock_drift: currentDrift()
    }
  };
  return profileEvent;
}
function buildProfileEventTags(tags) {
  const profileEventTags = tags.concat(["language:javascript", "runtime:chrome", "family:chrome", "host:browser"]);
  return profileEventTags;
}
function buildProfilingPayload(profilerTrace, profileEvent) {
  const profilerTraceBlob = new Blob([JSON.stringify(profilerTrace)], {
    type: "application/json"
  });
  const formData = new FormData();
  formData.append("event", new Blob([JSON.stringify(profileEvent)], { type: "application/json" }), "event.json");
  formData.append("wall-time.json", profilerTraceBlob, "wall-time.json");
  return { data: formData, bytesCount: 0 };
}
function buildProfileEventAttributes(profilerTrace, applicationId, sessionId) {
  const attributes = {
    application: {
      id: applicationId
    }
  };
  if (sessionId) {
    attributes.session = {
      id: sessionId
    };
  }
  const viewIds = Array.from(new Set(profilerTrace.views.map((viewEntry) => viewEntry.viewId)));
  if (viewIds.length) {
    attributes.view = {
      id: viewIds
    };
  }
  const longTaskIds = profilerTrace.longTasks.map((longTask) => longTask.id).filter((id) => id !== void 0);
  if (longTaskIds.length) {
    attributes.long_task = { id: longTaskIds };
  }
  return attributes;
}
var transport = {
  sendProfile
};

// node_modules/@datadog/browser-rum/esm/domain/profiling/profiler.js
var DEFAULT_RUM_PROFILER_CONFIGURATION = {
  sampleIntervalMs: 10,
  // Sample stack trace every 10ms
  collectIntervalMs: 6e4,
  // Collect data every minute
  minProfileDurationMs: 5e3,
  // Require at least 5 seconds of profile data to reduce noise and cost
  minNumberOfSamples: 50
  // Require at least 50 samples (~500 ms) to report a profile to reduce noise and cost
};
function createRumProfiler(configuration, lifeCycle, session, profilerConfiguration = DEFAULT_RUM_PROFILER_CONFIGURATION) {
  const isLongAnimationFrameEnabled = supportPerformanceTimingEvent(RumPerformanceEntryType.LONG_ANIMATION_FRAME);
  let lastViewEntry;
  const globalCleanupTasks = [];
  let instance = { state: "stopped" };
  function start(viewEntry) {
    if (instance.state === "running") {
      return;
    }
    lastViewEntry = viewEntry ? { startClocks: viewEntry.startClocks, viewId: viewEntry.id, viewName: viewEntry.name } : void 0;
    globalCleanupTasks.push(addEventListener(configuration, window, "visibilitychange", handleVisibilityChange).stop, addEventListener(configuration, window, "beforeunload", handleBeforeUnload).stop);
    startNextProfilerInstance();
  }
  async function stop() {
    await stopProfilerInstance("stopped");
    globalCleanupTasks.forEach((task) => task());
    cleanupLongTaskRegistryAfterCollection(clocksNow().relative);
  }
  function addEventListeners(existingInstance) {
    if (existingInstance.state === "running") {
      return {
        cleanupTasks: existingInstance.cleanupTasks,
        observer: existingInstance.observer
      };
    }
    const cleanupTasks = [];
    let observer;
    if (configuration.trackLongTasks) {
      observer = new PerformanceObserver(handlePerformance);
      observer.observe({
        entryTypes: [getLongTaskEntryType()]
      });
      const rawEventCollectedSubscription = lifeCycle.subscribe(12, (data) => {
        mayStoreLongTaskIdForProfilerCorrelation(data);
      });
      cleanupTasks.push(() => observer === null || observer === void 0 ? void 0 : observer.disconnect());
      cleanupTasks.push(rawEventCollectedSubscription.unsubscribe);
    }
    const viewUpdatedSubscription = lifeCycle.subscribe(2, (view) => {
      collectViewEntry({ viewId: view.id, viewName: view.name, startClocks: view.startClocks });
    });
    cleanupTasks.push(viewUpdatedSubscription.unsubscribe);
    return {
      cleanupTasks,
      observer
    };
  }
  function startNextProfilerInstance() {
    const globalThisProfiler = getGlobalObject().Profiler;
    if (!globalThisProfiler) {
      throw new Error("RUM Profiler is not supported in this browser.");
    }
    collectProfilerInstance(instance).catch(monitorError);
    const { cleanupTasks, observer } = addEventListeners(instance);
    let profiler;
    try {
      profiler = new globalThisProfiler({
        sampleInterval: profilerConfiguration.sampleIntervalMs,
        // Keep buffer size at 1.5 times of minimum required to collect data for a profiling instance
        maxBufferSize: Math.round(profilerConfiguration.collectIntervalMs * 1.5 / profilerConfiguration.sampleIntervalMs)
      });
    } catch (e) {
      display.warn("[DD_RUM] Profiler startup failed. Ensure your server includes the `Document-Policy: js-profiling` response header when serving HTML pages.", e);
      return;
    }
    instance = {
      state: "running",
      startClocks: clocksNow(),
      profiler,
      timeoutId: setTimeout(startNextProfilerInstance, profilerConfiguration.collectIntervalMs),
      longTasks: [],
      views: [],
      cleanupTasks,
      observer
    };
    collectViewEntry(lastViewEntry);
    profiler.addEventListener("samplebufferfull", handleSampleBufferFull);
  }
  async function collectProfilerInstance(lastInstance) {
    var _a, _b;
    if (lastInstance.state !== "running") {
      return;
    }
    handleLongTaskEntries((_b = (_a = lastInstance.observer) === null || _a === void 0 ? void 0 : _a.takeRecords()) !== null && _b !== void 0 ? _b : []);
    clearTimeout(lastInstance.timeoutId);
    lastInstance.profiler.removeEventListener("samplebufferfull", handleSampleBufferFull);
    const { startClocks, longTasks, views } = lastInstance;
    const collectClocks = clocksNow();
    await lastInstance.profiler.stop().then((trace) => {
      const endClocks = clocksNow();
      const hasLongTasks = longTasks.length > 0;
      const isBelowDurationThreshold = elapsed(startClocks.timeStamp, endClocks.timeStamp) < profilerConfiguration.minProfileDurationMs;
      const isBelowSampleThreshold = getNumberOfSamples(trace.samples) < profilerConfiguration.minNumberOfSamples;
      if (!hasLongTasks && (isBelowDurationThreshold || isBelowSampleThreshold)) {
        return;
      }
      handleProfilerTrace(
        // Enrich trace with time and instance data
        Object.assign(trace, {
          startClocks,
          endClocks,
          clocksOrigin: clocksOrigin(),
          longTasks,
          views,
          sampleInterval: profilerConfiguration.sampleIntervalMs
        })
      );
      cleanupLongTaskRegistryAfterCollection(collectClocks.relative);
    }).catch(monitorError);
  }
  async function stopProfilerInstance(nextState) {
    if (instance.state !== "running") {
      return;
    }
    instance.cleanupTasks.forEach((cleanupTask) => cleanupTask());
    await collectProfilerInstance(instance);
    instance = { state: nextState };
  }
  function collectViewEntry(viewEntry) {
    if (instance.state !== "running" || !viewEntry) {
      return;
    }
    instance.views.push(viewEntry);
  }
  function handleProfilerTrace(trace) {
    var _a;
    const sessionId = (_a = session.findTrackedSession()) === null || _a === void 0 ? void 0 : _a.id;
    transport.sendProfile(trace, configuration.profilingEndpointBuilder, configuration.applicationId, sessionId).catch(monitorError);
  }
  function handleSampleBufferFull() {
    startNextProfilerInstance();
  }
  function handlePerformance(list) {
    handleLongTaskEntries(list.getEntries());
  }
  function handleLongTaskEntries(entries) {
    if (instance.state !== "running") {
      return;
    }
    for (const entry of entries) {
      if (entry.duration < profilerConfiguration.sampleIntervalMs) {
        continue;
      }
      const startClocks = relativeToClocks(entry.startTime);
      const longTaskId = getLongTaskId(startClocks.relative);
      instance.longTasks.push({
        id: longTaskId,
        duration: entry.duration,
        entryType: entry.entryType,
        startClocks
      });
    }
  }
  function handleVisibilityChange() {
    if (document.visibilityState === "hidden" && instance.state === "running") {
      stopProfilerInstance("paused").catch(monitorError);
    } else if (document.visibilityState === "visible" && instance.state === "paused") {
      startNextProfilerInstance();
    }
  }
  function handleBeforeUnload() {
    startNextProfilerInstance();
  }
  function getLongTaskEntryType() {
    return isLongAnimationFrameEnabled ? "long-animation-frame" : "longtask";
  }
  function isStopped() {
    return instance.state === "stopped";
  }
  function isRunning() {
    return instance.state === "running";
  }
  function isPaused() {
    return instance.state === "paused";
  }
  return { start, stop, isStopped, isRunning, isPaused };
}
export {
  DEFAULT_RUM_PROFILER_CONFIGURATION,
  createRumProfiler
};
//# sourceMappingURL=profiler-ZEAL7KZJ.js.map
