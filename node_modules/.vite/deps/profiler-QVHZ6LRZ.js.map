{
  "version": 3,
  "sources": ["../../@datadog/browser-rum/src/domain/profiling/utils/getNumberOfSamples.ts", "../../@datadog/browser-rum/src/domain/profiling/utils/longTaskRegistry.ts", "../../@datadog/browser-rum/src/domain/profiling/profilingCorrelation.ts", "../../@datadog/browser-rum/src/domain/profiling/transport/transport.ts", "../../@datadog/browser-rum/src/domain/profiling/profiler.ts"],
  "sourcesContent": ["import type { ProfilerSample } from '../types'\n\n/**\n * Counts number of samples when the thread was not idle (stackId is defined)\n * @param samples Array of collected samples\n * @returns Number of samples\n */\nexport function getNumberOfSamples(samples: ProfilerSample[]): number {\n  let numberOfSamples = 0\n  for (const sample of samples) {\n    if (sample.stackId !== undefined) {\n      numberOfSamples++\n    }\n  }\n  return numberOfSamples\n}\n", "import type { RelativeTime } from '@datadog/browser-core'\n\ntype PerformanceEntryStartTime = RelativeTime\n\n// Maps PerformanceEntry start-time to the corresponding long task id (from RUM LongTaskEvent),\n// We need this to link RUM Long Tasks with RUM Profiler stack traces\n// Given that long task takes at least 50ms and we export profile at least every 60 seconds, we can have up to 1200 entries (60s / 50ms = 1200).\nconst registry = new Map<PerformanceEntryStartTime, string>()\n\nexport function disableLongTaskRegistry() {\n  registry.clear() // Free-up the memory\n}\n\n/**\n * Store the long task ID in the registry for the Profiler to link it with the corresponding Profile.\n */\nexport function setLongTaskId(longTaskId: string, startTime: PerformanceEntryStartTime) {\n  registry.set(startTime, longTaskId)\n}\n\nexport function getLongTaskId(startTime: PerformanceEntryStartTime): string | undefined {\n  return registry.get(startTime)\n}\n\n/**\n * Delete the Long Task from the registry once we have collected it.\n *\n * @param collectionRelativeTime The relative time of the collection\n */\nexport function cleanupLongTaskRegistryAfterCollection(collectionRelativeTime: RelativeTime) {\n  for (const performanceStartTime of registry.keys()) {\n    if (performanceStartTime < collectionRelativeTime) {\n      // We collected this Long Task already, no need to keep it in the registry.\n      registry.delete(performanceStartTime)\n    }\n  }\n}\n", "import type { RawRumEvent } from '@datadog/browser-rum-core'\nimport { RumEventType } from '@datadog/browser-rum-core'\nimport type { RelativeTime } from '@datadog/browser-core'\nimport { setLongTaskId } from './utils/longTaskRegistry'\n\n/**\n * Store the Long Task ID in the registry for the Profiler to link it with the corresponding Profile.\n *\n * @param rawRumEvent The Raw RUM event\n * @param startTime The start time of the event (in this case the Long Task Performance Entry start time)\n */\nexport function mayStoreLongTaskIdForProfilerCorrelation({\n  rawRumEvent,\n  startTime,\n}: {\n  rawRumEvent: RawRumEvent\n  startTime: RelativeTime\n}) {\n  if (rawRumEvent.type !== RumEventType.LONG_TASK) {\n    return\n  }\n\n  const longTaskId = rawRumEvent.long_task.id\n\n  // Store longTaskId in the registry for the Profiler to link it with the corresponding Profile.\n  setLongTaskId(longTaskId, startTime)\n}\n", "import { addTelemetryDebug, currentDrift, type EndpointBuilder, type Payload } from '@datadog/browser-core'\nimport type { RumProfilerTrace } from '../types'\n\ninterface ProfileEventAttributes {\n  application: { id: string }\n  session?: { id: string }\n  view?: { id: string[] }\n  long_task?: { id: string[] }\n}\ninterface ProfileEvent extends ProfileEventAttributes {\n  attachments: string[]\n  start: string // ISO date\n  end: string // ISO date\n  family: 'chrome'\n  runtime: 'chrome'\n  format: 'json'\n  version: 4\n  tags_profiler: string\n  _dd: {\n    clock_drift: number\n  }\n}\n\ntype SendProfileFunction = (\n  trace: RumProfilerTrace,\n  endpointBuilder: EndpointBuilder,\n  applicationId: string,\n  sessionId: string | undefined\n) => Promise<unknown>\n\n/**\n * Send RUM profile as JSON to public profiling intake.\n */\nconst sendProfile: SendProfileFunction = (profilerTrace, endpointBuilder, applicationId, sessionId) => {\n  const event = buildProfileEvent(profilerTrace, endpointBuilder, applicationId, sessionId)\n  const payload = buildProfilingPayload(profilerTrace, event)\n\n  // Create URL, public profiling intake.\n  const profilingIntakeURL = endpointBuilder.build('fetch', payload)\n\n  addTelemetryDebug('Sending profile to public profiling intake', { profilingIntakeURL, applicationId, sessionId })\n\n  // Send payload (event + profile as attachment).\n  return fetch(profilingIntakeURL, {\n    body: payload.data,\n    method: 'POST',\n  })\n}\n\nfunction buildProfileEvent(\n  profilerTrace: RumProfilerTrace,\n  endpointBuilder: EndpointBuilder,\n  applicationId: string,\n  sessionId: string | undefined\n): ProfileEvent {\n  const tags = endpointBuilder.tags\n  const profileAttributes = buildProfileEventAttributes(profilerTrace, applicationId, sessionId)\n  const profileEventTags = buildProfileEventTags(tags)\n\n  const profileEvent: ProfileEvent = {\n    ...profileAttributes,\n    attachments: ['wall-time.json'],\n    start: new Date(profilerTrace.startClocks.timeStamp).toISOString(),\n    end: new Date(profilerTrace.endClocks.timeStamp).toISOString(),\n    family: 'chrome',\n    runtime: 'chrome',\n    format: 'json',\n    version: 4, // Ingestion event version (not the version application tag)\n    tags_profiler: profileEventTags.join(','),\n    _dd: {\n      clock_drift: currentDrift(),\n    },\n  }\n\n  return profileEvent\n}\n\n/**\n * Builds tags for the Profile Event.\n * @param tags RUM tags\n * @returns Combined tags for the Profile Event.\n */\nfunction buildProfileEventTags(tags: string[]): string[] {\n  // Tags already contains the common tags for all events. (service, env, version, etc.)\n  // Here we are adding some specific-to-profiling tags.\n  const profileEventTags = tags.concat(['language:javascript', 'runtime:chrome', 'family:chrome', 'host:browser'])\n\n  return profileEventTags\n}\n\n/**\n * Builds payload for Profiling intake. It includes the profile event and the profiler trace as attachment.\n * @param profilerTrace Profiler trace\n * @param profileEvent Profiling event.\n * @returns Payload to be sent to the intake.\n */\nfunction buildProfilingPayload(profilerTrace: RumProfilerTrace, profileEvent: ProfileEvent): Payload {\n  const profilerTraceBlob = new Blob([JSON.stringify(profilerTrace)], {\n    type: 'application/json',\n  })\n  const formData = new FormData()\n  formData.append('event', new Blob([JSON.stringify(profileEvent)], { type: 'application/json' }), 'event.json')\n  formData.append('wall-time.json', profilerTraceBlob, 'wall-time.json')\n\n  return { data: formData, bytesCount: 0 }\n}\n\n/**\n * Builds attributes for the Profile Event.\n * @param profilerTrace Profiler trace\n * @param applicationId application id.\n * @param sessionId session id.\n * @returns Additional attributes.\n */\nfunction buildProfileEventAttributes(\n  profilerTrace: RumProfilerTrace,\n  applicationId: string,\n  sessionId: string | undefined\n): ProfileEventAttributes {\n  const attributes: ProfileEventAttributes = {\n    application: {\n      id: applicationId,\n    },\n  }\n  if (sessionId) {\n    attributes.session = {\n      id: sessionId,\n    }\n  }\n  const viewIds = Array.from(new Set(profilerTrace.views.map((viewEntry) => viewEntry.viewId)))\n  if (viewIds.length) {\n    attributes.view = {\n      id: viewIds,\n    }\n  }\n  const longTaskIds: string[] = profilerTrace.longTasks.map((longTask) => longTask.id).filter((id) => id !== undefined)\n\n  if (longTaskIds.length) {\n    attributes.long_task = { id: longTaskIds }\n  }\n  return attributes\n}\n\nexport const transport = {\n  sendProfile,\n}\n", "import type { Duration, RelativeTime } from '@datadog/browser-core'\nimport {\n  addEventListener,\n  clearTimeout,\n  setTimeout,\n  DOM_EVENT,\n  monitorError,\n  display,\n  getGlobalObject,\n  relativeToClocks,\n  clocksOrigin,\n  clocksNow,\n  elapsed,\n} from '@datadog/browser-core'\n\nimport type { LifeCycle, RumConfiguration, RumSessionManager, ViewHistoryEntry } from '@datadog/browser-rum-core'\nimport { LifeCycleEventType, RumPerformanceEntryType, supportPerformanceTimingEvent } from '@datadog/browser-rum-core'\nimport type {\n  RumProfilerTrace,\n  RumProfilerInstance,\n  Profiler,\n  RUMProfiler,\n  RUMProfilerConfiguration,\n  RumViewEntry,\n} from './types'\nimport { getNumberOfSamples } from './utils/getNumberOfSamples'\nimport { cleanupLongTaskRegistryAfterCollection, getLongTaskId } from './utils/longTaskRegistry'\nimport { mayStoreLongTaskIdForProfilerCorrelation } from './profilingCorrelation'\nimport { transport } from './transport/transport'\nimport type { ProfilingContextManager } from './profilingContext'\n\nexport const DEFAULT_RUM_PROFILER_CONFIGURATION: RUMProfilerConfiguration = {\n  sampleIntervalMs: 10, // Sample stack trace every 10ms\n  collectIntervalMs: 60000, // Collect data every minute\n  minProfileDurationMs: 5000, // Require at least 5 seconds of profile data to reduce noise and cost\n  minNumberOfSamples: 50, // Require at least 50 samples (~500 ms) to report a profile to reduce noise and cost\n}\n\nexport function createRumProfiler(\n  configuration: RumConfiguration,\n  lifeCycle: LifeCycle,\n  session: RumSessionManager,\n  profilingContextManager: ProfilingContextManager,\n  profilerConfiguration: RUMProfilerConfiguration = DEFAULT_RUM_PROFILER_CONFIGURATION\n): RUMProfiler {\n  const isLongAnimationFrameEnabled = supportPerformanceTimingEvent(RumPerformanceEntryType.LONG_ANIMATION_FRAME)\n\n  let lastViewEntry: RumViewEntry | undefined\n\n  // Global clean-up tasks for listeners that are not specific to a profiler instance (eg. visibility change, before unload)\n  const globalCleanupTasks: Array<() => void> = []\n\n  let instance: RumProfilerInstance = { state: 'stopped' }\n\n  function start(viewEntry: ViewHistoryEntry | undefined): void {\n    if (instance.state === 'running') {\n      return\n    }\n\n    // Add initial view\n    // Note: `viewEntry.name` is only filled when users use manual view creation via `startView` method.\n    lastViewEntry = viewEntry\n      ? { startClocks: viewEntry.startClocks, viewId: viewEntry.id, viewName: viewEntry.name }\n      : undefined\n\n    // Add global clean-up tasks for listeners that are not specific to a profiler instance (eg. visibility change, before unload)\n    globalCleanupTasks.push(\n      addEventListener(configuration, window, DOM_EVENT.VISIBILITY_CHANGE, handleVisibilityChange).stop,\n      addEventListener(configuration, window, DOM_EVENT.BEFORE_UNLOAD, handleBeforeUnload).stop\n    )\n\n    // Start profiler instance\n    startNextProfilerInstance()\n  }\n\n  async function stop() {\n    // Stop current profiler instance\n    await stopProfilerInstance('stopped')\n\n    // Cleanup global listeners\n    globalCleanupTasks.forEach((task) => task())\n\n    // Cleanup Long Task Registry as we no longer need to correlate them with RUM\n    cleanupLongTaskRegistryAfterCollection(clocksNow().relative)\n\n    // Update Profiling status once the Profiler has been stopped.\n    profilingContextManager.set({ status: 'stopped', error_reason: undefined })\n  }\n\n  /**\n   * Whenever a new Profiler instance is started, we need to add event listeners to surroundings (RUM Events, Long Tasks, etc) to enrich the Profiler data.\n   * If the instance is already running, we can keep the same event listeners.\n   */\n  function addEventListeners(existingInstance: RumProfilerInstance) {\n    if (existingInstance.state === 'running') {\n      // Instance is already running, so we can keep same event listeners.\n      return {\n        cleanupTasks: existingInstance.cleanupTasks,\n        observer: existingInstance.observer,\n      }\n    }\n\n    // Store clean-up tasks for this instance (tasks to be executed when the Profiler is stopped or paused.)\n    const cleanupTasks = []\n    let observer: PerformanceObserver | undefined\n\n    // Register everything linked to Long Tasks correlations with RUM, when enabled.\n    if (configuration.trackLongTasks) {\n      // Setup event listeners, and since we only listen to Long Tasks for now, we activate the Performance Observer only when they are tracked.\n      observer = new PerformanceObserver(handlePerformance)\n      observer.observe({\n        entryTypes: [getLongTaskEntryType()],\n      })\n\n      // Whenever an Event is collected, when it's a Long Task, we may store the long task id for profiler correlation.\n      const rawEventCollectedSubscription = lifeCycle.subscribe(LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, (data) => {\n        mayStoreLongTaskIdForProfilerCorrelation(data)\n      })\n\n      cleanupTasks.push(() => observer?.disconnect())\n      cleanupTasks.push(rawEventCollectedSubscription.unsubscribe)\n    }\n\n    // Whenever the View is updated, we add a views entry to the profiler instance.\n    const viewUpdatedSubscription = lifeCycle.subscribe(LifeCycleEventType.VIEW_CREATED, (view) => {\n      // Note: `view.name` is only filled when users use manual view creation via `startView` method.\n      collectViewEntry({ viewId: view.id, viewName: view.name, startClocks: view.startClocks })\n    })\n    cleanupTasks.push(viewUpdatedSubscription.unsubscribe)\n\n    return {\n      cleanupTasks,\n      observer,\n    }\n  }\n\n  function startNextProfilerInstance(): void {\n    // These APIs might be unavailable in some browsers\n    const globalThisProfiler: Profiler | undefined = getGlobalObject<any>().Profiler\n\n    if (!globalThisProfiler) {\n      profilingContextManager.set({ status: 'error', error_reason: 'not-supported-by-browser' })\n      throw new Error('RUM Profiler is not supported in this browser.')\n    }\n\n    // Don't wait for data collection to start next instance\n    collectProfilerInstance(instance).catch(monitorError)\n\n    const { cleanupTasks, observer } = addEventListeners(instance)\n\n    let profiler: Profiler\n    try {\n      // We have to create new Profiler each time we start a new instance\n      profiler = new globalThisProfiler({\n        sampleInterval: profilerConfiguration.sampleIntervalMs,\n        // Keep buffer size at 1.5 times of minimum required to collect data for a profiling instance\n        maxBufferSize: Math.round(\n          (profilerConfiguration.collectIntervalMs * 1.5) / profilerConfiguration.sampleIntervalMs\n        ),\n      })\n    } catch (e) {\n      if (e instanceof Error && e.message.includes('disabled by Document Policy')) {\n        // Missing Response Header (`js-profiling`) that is required to enable the profiler.\n        // We should suggest the user to enable the Response Header in their server configuration.\n        display.warn(\n          '[DD_RUM] Profiler startup failed. Ensure your server includes the `Document-Policy: js-profiling` response header when serving HTML pages.',\n          e\n        )\n        profilingContextManager.set({ status: 'error', error_reason: 'missing-document-policy-header' })\n      } else {\n        profilingContextManager.set({ status: 'error', error_reason: 'unexpected-exception' })\n      }\n      return\n    }\n\n    profilingContextManager.set({ status: 'running', error_reason: undefined })\n\n    // Kick-off the new instance\n    instance = {\n      state: 'running',\n      startClocks: clocksNow(),\n      profiler,\n      timeoutId: setTimeout(startNextProfilerInstance, profilerConfiguration.collectIntervalMs),\n      longTasks: [],\n      views: [],\n      cleanupTasks,\n      observer,\n    }\n\n    // Add last view entry\n    collectViewEntry(lastViewEntry)\n\n    // Add event handler case we overflow the buffer\n    profiler.addEventListener('samplebufferfull', handleSampleBufferFull)\n  }\n\n  async function collectProfilerInstance(lastInstance: RumProfilerInstance) {\n    if (lastInstance.state !== 'running') {\n      return\n    }\n\n    // Empty the performance observer buffer\n    handleLongTaskEntries(lastInstance.observer?.takeRecords() ?? [])\n\n    // Cleanup instance\n    clearTimeout(lastInstance.timeoutId)\n    lastInstance.profiler.removeEventListener('samplebufferfull', handleSampleBufferFull)\n\n    // Store instance data snapshot in local variables to use in async callback\n    const { startClocks, longTasks, views } = lastInstance\n\n    // Capturing when we stop the profiler so we use this time as a reference to clean-up long task registry, eg. remove the long tasks that we collected already\n    const collectClocks = clocksNow()\n\n    // Stop current profiler to get trace\n    await lastInstance.profiler\n      .stop()\n      .then((trace) => {\n        const endClocks = clocksNow()\n\n        const hasLongTasks = longTasks.length > 0\n        const isBelowDurationThreshold =\n          elapsed(startClocks.timeStamp, endClocks.timeStamp) < profilerConfiguration.minProfileDurationMs\n        const isBelowSampleThreshold = getNumberOfSamples(trace.samples) < profilerConfiguration.minNumberOfSamples\n\n        if (!hasLongTasks && (isBelowDurationThreshold || isBelowSampleThreshold)) {\n          // Skip very short profiles to reduce noise and cost, but keep them if they contain long tasks.\n          return\n        }\n\n        handleProfilerTrace(\n          // Enrich trace with time and instance data\n          Object.assign(trace, {\n            startClocks,\n            endClocks,\n            clocksOrigin: clocksOrigin(),\n            longTasks,\n            views,\n            sampleInterval: profilerConfiguration.sampleIntervalMs,\n          })\n        )\n\n        // Clear long task registry, remove entries that we collected already (eg. avoid slowly growing memory usage by keeping outdated entries)\n        cleanupLongTaskRegistryAfterCollection(collectClocks.relative)\n      })\n      .catch(monitorError)\n  }\n\n  async function stopProfilerInstance(nextState: 'paused' | 'stopped') {\n    if (instance.state !== 'running') {\n      return\n    }\n\n    // Cleanup tasks\n    instance.cleanupTasks.forEach((cleanupTask) => cleanupTask())\n\n    await collectProfilerInstance(instance)\n\n    instance = { state: nextState }\n  }\n\n  function collectViewEntry(viewEntry: RumViewEntry | undefined): void {\n    if (instance.state !== 'running' || !viewEntry) {\n      return\n    }\n\n    // Add entry to views\n    instance.views.push(viewEntry)\n  }\n\n  function handleProfilerTrace(trace: RumProfilerTrace): void {\n    // Find current session to assign it to the Profile.\n    const sessionId = session.findTrackedSession()?.id\n\n    // Send JSON Profile to intake.\n    transport\n      .sendProfile(trace, configuration.profilingEndpointBuilder, configuration.applicationId, sessionId)\n      .catch(monitorError)\n  }\n\n  function handleSampleBufferFull(): void {\n    startNextProfilerInstance()\n  }\n\n  function handlePerformance(list: PerformanceObserverEntryList): void {\n    handleLongTaskEntries(list.getEntries())\n  }\n\n  function handleLongTaskEntries(entries: PerformanceEntryList): void {\n    if (instance.state !== 'running') {\n      return\n    }\n\n    for (const entry of entries) {\n      if (entry.duration < profilerConfiguration.sampleIntervalMs) {\n        // Skip entries shorter than sample interval to reduce noise and size of profile\n        continue\n      }\n\n      const startClocks = relativeToClocks(entry.startTime as RelativeTime)\n\n      const longTaskId = getLongTaskId(startClocks.relative)\n\n      // Store Long Task entry, which is a lightweight version of the PerformanceEntry\n      instance.longTasks.push({\n        id: longTaskId,\n        duration: entry.duration as Duration,\n        entryType: entry.entryType,\n        startClocks,\n      })\n    }\n  }\n\n  function handleVisibilityChange(): void {\n    if (document.visibilityState === 'hidden' && instance.state === 'running') {\n      // Pause when tab is hidden. We use paused state to distinguish between\n      // paused by visibility change and stopped by user.\n      // If profiler is paused by the visibility change, we should resume when\n      // tab becomes visible again. That's not the case when user stops the profiler.\n      stopProfilerInstance('paused').catch(monitorError)\n    } else if (document.visibilityState === 'visible' && instance.state === 'paused') {\n      // Resume when tab becomes visible again\n      startNextProfilerInstance()\n    }\n  }\n\n  function handleBeforeUnload(): void {\n    // `unload` can in some cases be triggered while the page is still active (link to a different protocol like mailto:).\n    // We can immediately flush (by starting a new profiler instance) to make sure we receive the data, and at the same time keep the profiler active.\n    // In case of the regular unload, the profiler will be shut down anyway.\n    startNextProfilerInstance()\n  }\n\n  function getLongTaskEntryType(): 'long-animation-frame' | 'longtask' {\n    return isLongAnimationFrameEnabled ? 'long-animation-frame' : 'longtask'\n  }\n\n  function isStopped() {\n    return instance.state === 'stopped'\n  }\n\n  function isRunning() {\n    return instance.state === 'running'\n  }\n\n  function isPaused() {\n    return instance.state === 'paused'\n  }\n\n  return { start, stop, isStopped, isRunning, isPaused }\n}\n"],
  "mappings": "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",
  "names": []
}
