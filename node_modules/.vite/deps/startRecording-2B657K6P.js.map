{
  "version": 3,
  "sources": ["../../@datadog/browser-rum/src/domain/record/serialization/serializationUtils.ts", "../../@datadog/browser-rum/src/types/sessionReplayConstants.ts", "../../@datadog/browser-rum/src/domain/record/serialization/serializeStyleSheets.ts", "../../@datadog/browser-rum/src/domain/record/serialization/serializeAttribute.ts", "../../@datadog/browser-rum/src/domain/record/serialization/serializeAttributes.ts", "../../@datadog/browser-rum/src/domain/record/serialization/serializeNode.ts", "../../@datadog/browser-rum/src/domain/record/serialization/serializeDocument.ts", "../../@datadog/browser-rum/src/domain/record/eventsUtils.ts", "../../@datadog/browser-rum/src/domain/record/viewports.ts", "../../@datadog/browser-rum/src/domain/record/assembly.ts", "../../@datadog/browser-rum/src/domain/record/trackers/trackMove.ts", "../../@datadog/browser-rum/src/domain/record/trackers/trackMouseInteraction.ts", "../../@datadog/browser-rum/src/domain/record/trackers/trackScroll.ts", "../../@datadog/browser-rum/src/domain/record/trackers/trackViewportResize.ts", "../../@datadog/browser-rum/src/domain/record/trackers/trackMediaInteraction.ts", "../../@datadog/browser-rum/src/domain/record/trackers/trackStyleSheet.ts", "../../@datadog/browser-rum/src/domain/record/trackers/trackFocus.ts", "../../@datadog/browser-rum/src/domain/record/trackers/trackFrustration.ts", "../../@datadog/browser-rum/src/domain/record/trackers/trackViewEnd.ts", "../../@datadog/browser-rum/src/domain/record/trackers/trackInput.ts", "../../@datadog/browser-rum/src/domain/record/mutationBatch.ts", "../../@datadog/browser-rum/src/domain/record/trackers/trackMutation.ts", "../../@datadog/browser-rum/src/domain/record/elementsScrollPositions.ts", "../../@datadog/browser-rum/src/domain/record/shadowRootsController.ts", "../../@datadog/browser-rum/src/domain/record/startFullSnapshots.ts", "../../@datadog/browser-rum/src/domain/record/recordIds.ts", "../../@datadog/browser-rum/src/domain/record/record.ts", "../../@datadog/browser-rum/src/domain/segmentCollection/buildReplayPayload.ts", "../../@datadog/browser-rum/src/domain/segmentCollection/segment.ts", "../../@datadog/browser-rum/src/domain/segmentCollection/segmentCollection.ts", "../../@datadog/browser-rum/src/domain/startRecordBridge.ts", "../../@datadog/browser-rum/src/boot/startRecording.ts"],
  "sourcesContent": ["import { buildUrl } from '@datadog/browser-core'\nimport { getParentNode, isNodeShadowRoot, CENSORED_STRING_MARK, shouldMaskNode } from '@datadog/browser-rum-core'\nimport type { NodePrivacyLevel } from '@datadog/browser-rum-core'\nimport type { NodeWithSerializedNode } from './serialization.types'\n\nconst serializedNodeIds = new WeakMap<Node, number>()\n\nexport function hasSerializedNode(node: Node): node is NodeWithSerializedNode {\n  return serializedNodeIds.has(node)\n}\n\nexport function nodeAndAncestorsHaveSerializedNode(node: Node): node is NodeWithSerializedNode {\n  let current: Node | null = node\n  while (current) {\n    if (!hasSerializedNode(current) && !isNodeShadowRoot(current)) {\n      return false\n    }\n    current = getParentNode(current)\n  }\n  return true\n}\n\nexport function getSerializedNodeId(node: NodeWithSerializedNode): number\nexport function getSerializedNodeId(node: Node): number | undefined\nexport function getSerializedNodeId(node: Node) {\n  return serializedNodeIds.get(node)\n}\n\nexport function setSerializedNodeId(node: Node, serializeNodeId: number) {\n  serializedNodeIds.set(node, serializeNodeId)\n}\n\n/**\n * Get the element \"value\" to be serialized as an attribute or an input update record. It respects\n * the input privacy mode of the element.\n * PERFROMANCE OPTIMIZATION: Assumes that privacy level `HIDDEN` is never encountered because of earlier checks.\n */\nexport function getElementInputValue(element: Element, nodePrivacyLevel: NodePrivacyLevel) {\n  /*\n   BROWSER SPEC NOTE: <input>, <select>\n   For some <input> elements, the `value` is an exceptional property/attribute that has the\n   value synced between el.value and el.getAttribute()\n   input[type=button,checkbox,hidden,image,radio,reset,submit]\n   */\n  const tagName = element.tagName\n  const value = (element as HTMLInputElement | HTMLTextAreaElement).value\n\n  if (shouldMaskNode(element, nodePrivacyLevel)) {\n    const type = (element as HTMLInputElement | HTMLTextAreaElement).type\n    if (tagName === 'INPUT' && (type === 'button' || type === 'submit' || type === 'reset')) {\n      // Overrule `MASK` privacy level for button-like element values, as they are used during replay\n      // to display their label. They can still be hidden via the \"hidden\" privacy attribute or class name.\n      return value\n    } else if (!value || tagName === 'OPTION') {\n      // <Option> value provides no benefit\n      return\n    }\n    return CENSORED_STRING_MARK\n  }\n\n  if (tagName === 'OPTION' || tagName === 'SELECT') {\n    return (element as HTMLOptionElement | HTMLSelectElement).value\n  }\n\n  if (tagName !== 'INPUT' && tagName !== 'TEXTAREA') {\n    return\n  }\n\n  return value\n}\n\nexport const URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")([^\"]*)\"|([^)]*))\\)/gm\nexport const ABSOLUTE_URL = /^[A-Za-z]+:|^\\/\\//\nexport const DATA_URI = /^[\"']?data:.*,/i\n\nexport function switchToAbsoluteUrl(cssText: string, cssHref: string | null): string {\n  return cssText.replace(\n    URL_IN_CSS_REF,\n    (\n      matchingSubstring: string,\n      singleQuote: string | undefined,\n      urlWrappedInSingleQuotes: string | undefined,\n      doubleQuote: string | undefined,\n      urlWrappedInDoubleQuotes: string | undefined,\n      urlNotWrappedInQuotes: string | undefined\n    ) => {\n      const url = urlWrappedInSingleQuotes || urlWrappedInDoubleQuotes || urlNotWrappedInQuotes\n\n      if (!cssHref || !url || ABSOLUTE_URL.test(url) || DATA_URI.test(url)) {\n        return matchingSubstring\n      }\n\n      const quote = singleQuote || doubleQuote || ''\n      return `url(${quote}${makeUrlAbsolute(url, cssHref)}${quote})`\n    }\n  )\n}\n\nexport function makeUrlAbsolute(url: string, baseUrl: string): string {\n  try {\n    return buildUrl(url, baseUrl).href\n  } catch {\n    return url\n  }\n}\n\nconst TAG_NAME_REGEX = /[^a-z1-6-_]/\nexport function getValidTagName(tagName: string): string {\n  const processedTagName = tagName.toLowerCase().trim()\n\n  if (TAG_NAME_REGEX.test(processedTagName)) {\n    // if the tag name is odd and we cannot extract\n    // anything from the string, then we return a\n    // generic div\n    return 'div'\n  }\n\n  return processedTagName\n}\n\nexport function censoredImageForSize(width: number, height: number) {\n  return `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='${width}' height='${height}' style='background-color:silver'%3E%3C/svg%3E`\n}\n", "import type * as SessionReplay from './sessionReplay'\n\nexport const RecordType: {\n  FullSnapshot: SessionReplay.BrowserFullSnapshotRecord['type']\n  IncrementalSnapshot: SessionReplay.BrowserIncrementalSnapshotRecord['type']\n  Meta: SessionReplay.MetaRecord['type']\n  Focus: SessionReplay.FocusRecord['type']\n  ViewEnd: SessionReplay.ViewEndRecord['type']\n  VisualViewport: SessionReplay.VisualViewportRecord['type']\n  FrustrationRecord: SessionReplay.FrustrationRecord['type']\n} = {\n  FullSnapshot: 2,\n  IncrementalSnapshot: 3,\n  Meta: 4,\n  Focus: 6,\n  ViewEnd: 7,\n  VisualViewport: 8,\n  FrustrationRecord: 9,\n} as const\n\nexport type RecordType = (typeof RecordType)[keyof typeof RecordType]\n\nexport const NodeType: {\n  Document: SessionReplay.DocumentNode['type']\n  DocumentType: SessionReplay.DocumentTypeNode['type']\n  Element: SessionReplay.ElementNode['type']\n  Text: SessionReplay.TextNode['type']\n  CDATA: SessionReplay.CDataNode['type']\n  DocumentFragment: SessionReplay.DocumentFragmentNode['type']\n} = {\n  Document: 0,\n  DocumentType: 1,\n  Element: 2,\n  Text: 3,\n  CDATA: 4,\n  DocumentFragment: 11,\n} as const\n\nexport type NodeType = (typeof NodeType)[keyof typeof NodeType]\n\nexport const IncrementalSource: {\n  Mutation: SessionReplay.BrowserMutationData['source']\n  MouseMove: Exclude<SessionReplay.MousemoveData['source'], 6>\n  MouseInteraction: SessionReplay.MouseInteractionData['source']\n  Scroll: SessionReplay.ScrollData['source']\n  ViewportResize: SessionReplay.ViewportResizeData['source']\n  Input: SessionReplay.InputData['source']\n  TouchMove: Exclude<SessionReplay.MousemoveData['source'], 1>\n  MediaInteraction: SessionReplay.MediaInteractionData['source']\n  StyleSheetRule: SessionReplay.StyleSheetRuleData['source']\n} = {\n  Mutation: 0,\n  MouseMove: 1,\n  MouseInteraction: 2,\n  Scroll: 3,\n  ViewportResize: 4,\n  Input: 5,\n  TouchMove: 6,\n  MediaInteraction: 7,\n  StyleSheetRule: 8,\n  // CanvasMutation : 9,\n  // Font : 10,\n} as const\n\nexport type IncrementalSource = (typeof IncrementalSource)[keyof typeof IncrementalSource]\n\nexport const MouseInteractionType = {\n  MouseUp: 0,\n  MouseDown: 1,\n  Click: 2,\n  ContextMenu: 3,\n  DblClick: 4,\n  Focus: 5,\n  Blur: 6,\n  TouchStart: 7,\n  TouchEnd: 9,\n} as const\n\nexport type MouseInteractionType = (typeof MouseInteractionType)[keyof typeof MouseInteractionType]\n\nexport const MediaInteractionType = {\n  Play: 0,\n  Pause: 1,\n} as const\n\nexport type MediaInteractionType = (typeof MediaInteractionType)[keyof typeof MediaInteractionType]\n", "import type { StyleSheet } from '../../../types'\n\nexport function serializeStyleSheets(cssStyleSheets: CSSStyleSheet[] | undefined): StyleSheet[] | undefined {\n  if (cssStyleSheets === undefined || cssStyleSheets.length === 0) {\n    return undefined\n  }\n  return cssStyleSheets.map((cssStyleSheet) => {\n    const rules = cssStyleSheet.cssRules || cssStyleSheet.rules\n    const cssRules = Array.from(rules, (cssRule) => cssRule.cssText)\n\n    const styleSheet: StyleSheet = {\n      cssRules,\n      disabled: cssStyleSheet.disabled || undefined,\n      media: cssStyleSheet.media.length > 0 ? Array.from(cssStyleSheet.media) : undefined,\n    }\n    return styleSheet\n  })\n}\n", "import {\n  NodePrivacyLevel,\n  PRIVACY_ATTR_NAME,\n  CENSORED_STRING_MARK,\n  CENSORED_IMG_MARK,\n  STABLE_ATTRIBUTES,\n  sanitizeIfLongDataUrl,\n} from '@datadog/browser-rum-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport { censoredImageForSize } from './serializationUtils'\n\n// TODO: temporarily bump the Session Replay limit to 1Mb for dataUrls\n// This limit should be removed after [PANA-2843] is implemented\nexport const MAX_ATTRIBUTE_VALUE_CHAR_LENGTH = 1_000_000\n\nexport function serializeAttribute(\n  element: Element,\n  nodePrivacyLevel: NodePrivacyLevel,\n  attributeName: string,\n  configuration: RumConfiguration\n): string | number | boolean | null {\n  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    // dup condition for direct access case\n    return null\n  }\n  const attributeValue = element.getAttribute(attributeName)\n  if (\n    nodePrivacyLevel === NodePrivacyLevel.MASK &&\n    attributeName !== PRIVACY_ATTR_NAME &&\n    !STABLE_ATTRIBUTES.includes(attributeName) &&\n    attributeName !== configuration.actionNameAttribute\n  ) {\n    const tagName = element.tagName\n\n    switch (attributeName) {\n      // Mask Attribute text content\n      case 'title':\n      case 'alt':\n      case 'placeholder':\n        return CENSORED_STRING_MARK\n    }\n\n    // mask image URLs\n    if (tagName === 'IMG' && (attributeName === 'src' || attributeName === 'srcset')) {\n      // generate image with similar dimension than the original to have the same rendering behaviour\n      const image = element as HTMLImageElement\n      if (image.naturalWidth > 0) {\n        return censoredImageForSize(image.naturalWidth, image.naturalHeight)\n      }\n      const { width, height } = element.getBoundingClientRect()\n      if (width > 0 || height > 0) {\n        return censoredImageForSize(width, height)\n      }\n      // if we can't get the image size, fallback to the censored image\n      return CENSORED_IMG_MARK\n    }\n\n    // mask source URLs\n    if (tagName === 'SOURCE' && (attributeName === 'src' || attributeName === 'srcset')) {\n      return CENSORED_IMG_MARK\n    }\n\n    // mask <a> URLs\n    if (tagName === 'A' && attributeName === 'href') {\n      return CENSORED_STRING_MARK\n    }\n\n    // mask data-* attributes\n    if (attributeValue && attributeName.startsWith('data-')) {\n      // Exception: it's safe to reveal the `${PRIVACY_ATTR_NAME}` attr\n      return CENSORED_STRING_MARK\n    }\n\n    // mask iframe srcdoc\n    if (tagName === 'IFRAME' && attributeName === 'srcdoc') {\n      return CENSORED_STRING_MARK\n    }\n  }\n\n  if (!attributeValue || typeof attributeValue !== 'string') {\n    return attributeValue\n  }\n\n  return sanitizeIfLongDataUrl(attributeValue, MAX_ATTRIBUTE_VALUE_CHAR_LENGTH)\n}\n", "import { NodePrivacyLevel, shouldMaskNode } from '@datadog/browser-rum-core'\nimport { isSafari } from '@datadog/browser-core'\nimport { getElementInputValue, switchToAbsoluteUrl, getValidTagName } from './serializationUtils'\nimport type { SerializeOptions } from './serialization.types'\nimport { SerializationContextStatus } from './serialization.types'\nimport { serializeAttribute } from './serializeAttribute'\n\nexport function serializeAttributes(\n  element: Element,\n  nodePrivacyLevel: NodePrivacyLevel,\n  options: SerializeOptions\n): Record<string, string | number | boolean> {\n  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    return {}\n  }\n  const safeAttrs: Record<string, string | number | boolean> = {}\n  const tagName = getValidTagName(element.tagName)\n  const doc = element.ownerDocument\n\n  for (let i = 0; i < element.attributes.length; i += 1) {\n    const attribute = element.attributes.item(i)!\n    const attributeName = attribute.name\n    const attributeValue = serializeAttribute(element, nodePrivacyLevel, attributeName, options.configuration)\n    if (attributeValue !== null) {\n      safeAttrs[attributeName] = attributeValue\n    }\n  }\n\n  if (\n    (element as HTMLInputElement).value &&\n    (tagName === 'textarea' || tagName === 'select' || tagName === 'option' || tagName === 'input')\n  ) {\n    const formValue = getElementInputValue(element, nodePrivacyLevel)\n    if (formValue !== undefined) {\n      safeAttrs.value = formValue\n    }\n  }\n\n  /**\n   * <Option> can be selected, which occurs if its `value` matches ancestor `<Select>.value`\n   */\n  if (tagName === 'option' && nodePrivacyLevel === NodePrivacyLevel.ALLOW) {\n    // For privacy=`MASK`, all the values would be the same, so skip.\n    const optionElement = element as HTMLOptionElement\n    if (optionElement.selected) {\n      safeAttrs.selected = optionElement.selected\n    }\n  }\n\n  // remote css\n  if (tagName === 'link') {\n    const stylesheet = Array.from(doc.styleSheets).find((s) => s.href === (element as HTMLLinkElement).href)\n    const cssText = getCssRulesString(stylesheet)\n    if (cssText && stylesheet) {\n      safeAttrs._cssText = cssText\n    }\n  }\n\n  // dynamic stylesheet\n  if (tagName === 'style' && (element as HTMLStyleElement).sheet) {\n    const cssText = getCssRulesString((element as HTMLStyleElement).sheet)\n    if (cssText) {\n      safeAttrs._cssText = cssText\n    }\n  }\n\n  /**\n   * Forms: input[type=checkbox,radio]\n   * The `checked` property for <input> is a little bit special:\n   * 1. el.checked is a setter that returns if truthy.\n   * 2. getAttribute returns the string value\n   * getAttribute('checked') does not sync with `Element.checked`, so use JS property\n   * NOTE: `checked` property exists on `HTMLInputElement`. For serializer assumptions, we check for type=radio|check.\n   */\n  const inputElement = element as HTMLInputElement\n  if (tagName === 'input' && (inputElement.type === 'radio' || inputElement.type === 'checkbox')) {\n    if (nodePrivacyLevel === NodePrivacyLevel.ALLOW) {\n      safeAttrs.checked = !!inputElement.checked\n    } else if (shouldMaskNode(inputElement, nodePrivacyLevel)) {\n      delete safeAttrs.checked\n    }\n  }\n\n  /**\n   * Serialize the media playback state\n   */\n  if (tagName === 'audio' || tagName === 'video') {\n    const mediaElement = element as HTMLMediaElement\n    safeAttrs.rr_mediaState = mediaElement.paused ? 'paused' : 'played'\n  }\n\n  /**\n   * Serialize the scroll state for each element only for full snapshot\n   */\n  let scrollTop: number | undefined\n  let scrollLeft: number | undefined\n  const serializationContext = options.serializationContext\n  switch (serializationContext.status) {\n    case SerializationContextStatus.INITIAL_FULL_SNAPSHOT:\n      scrollTop = Math.round(element.scrollTop)\n      scrollLeft = Math.round(element.scrollLeft)\n      if (scrollTop || scrollLeft) {\n        serializationContext.elementsScrollPositions.set(element, { scrollTop, scrollLeft })\n      }\n      break\n    case SerializationContextStatus.SUBSEQUENT_FULL_SNAPSHOT:\n      if (serializationContext.elementsScrollPositions.has(element)) {\n        ;({ scrollTop, scrollLeft } = serializationContext.elementsScrollPositions.get(element)!)\n      }\n      break\n  }\n  if (scrollLeft) {\n    safeAttrs.rr_scrollLeft = scrollLeft\n  }\n  if (scrollTop) {\n    safeAttrs.rr_scrollTop = scrollTop\n  }\n\n  return safeAttrs\n}\n\nexport function getCssRulesString(cssStyleSheet: CSSStyleSheet | undefined | null): string | null {\n  if (!cssStyleSheet) {\n    return null\n  }\n  let rules: CSSRuleList | undefined\n  try {\n    rules = cssStyleSheet.rules || cssStyleSheet.cssRules\n  } catch {\n    // if css is protected by CORS we cannot access cssRules see: https://www.w3.org/TR/cssom-1/#the-cssstylesheet-interface\n  }\n  if (!rules) {\n    return null\n  }\n  const styleSheetCssText = Array.from(rules, isSafari() ? getCssRuleStringForSafari : getCssRuleString).join('')\n  return switchToAbsoluteUrl(styleSheetCssText, cssStyleSheet.href)\n}\n\nfunction getCssRuleStringForSafari(rule: CSSRule): string {\n  // Safari does not escape attribute selectors containing : properly\n  // https://bugs.webkit.org/show_bug.cgi?id=184604\n  if (isCSSStyleRule(rule) && rule.selectorText.includes(':')) {\n    // This regex replaces [foo:bar] by [foo\\\\:bar]\n    const escapeColon = /(\\[[\\w-]+[^\\\\])(:[^\\]]+\\])/g\n    return rule.cssText.replace(escapeColon, '$1\\\\$2')\n  }\n\n  return getCssRuleString(rule)\n}\n\nfunction getCssRuleString(rule: CSSRule): string {\n  // If it's an @import rule, try to inline sub-rules recursively with `getCssRulesString`. This\n  // operation can fail if the imported stylesheet is protected by CORS, in which case we fallback\n  // to the @import rule CSS text.\n  return (isCSSImportRule(rule) && getCssRulesString(rule.styleSheet)) || rule.cssText\n}\n\nfunction isCSSImportRule(rule: CSSRule): rule is CSSImportRule {\n  return 'styleSheet' in rule\n}\n\nfunction isCSSStyleRule(rule: CSSRule): rule is CSSStyleRule {\n  return 'selectorText' in rule\n}\n", "import {\n  reducePrivacyLevel,\n  getNodeSelfPrivacyLevel,\n  getTextContent,\n  isNodeShadowRoot,\n  hasChildNodes,\n  forEachChildNodes,\n  NodePrivacyLevel,\n  PRIVACY_ATTR_NAME,\n  PRIVACY_ATTR_VALUE_HIDDEN,\n} from '@datadog/browser-rum-core'\nimport type {\n  DocumentFragmentNode,\n  DocumentNode,\n  SerializedNode,\n  SerializedNodeWithId,\n  CDataNode,\n  DocumentTypeNode,\n  ElementNode,\n  TextNode,\n} from '../../../types'\nimport { NodeType } from '../../../types'\nimport { getSerializedNodeId, getValidTagName, setSerializedNodeId } from './serializationUtils'\nimport type { SerializeOptions } from './serialization.types'\nimport { serializeStyleSheets } from './serializeStyleSheets'\nimport { serializeAttributes } from './serializeAttributes'\n\nexport function serializeNodeWithId(node: Node, options: SerializeOptions): SerializedNodeWithId | null {\n  const serializedNode = serializeNode(node, options)\n  if (!serializedNode) {\n    return null\n  }\n\n  // Try to reuse the previous id\n  const id = getSerializedNodeId(node) || generateNextId()\n  const serializedNodeWithId = serializedNode as SerializedNodeWithId\n  serializedNodeWithId.id = id\n  setSerializedNodeId(node, id)\n  if (options.serializedNodeIds) {\n    options.serializedNodeIds.add(id)\n  }\n  return serializedNodeWithId\n}\n\nlet _nextId = 1\nexport function generateNextId(): number {\n  return _nextId++\n}\n\nexport function serializeChildNodes(node: Node, options: SerializeOptions): SerializedNodeWithId[] {\n  const result: SerializedNodeWithId[] = []\n  forEachChildNodes(node, (childNode) => {\n    const serializedChildNode = serializeNodeWithId(childNode, options)\n    if (serializedChildNode) {\n      result.push(serializedChildNode)\n    }\n  })\n  return result\n}\n\nfunction serializeNode(node: Node, options: SerializeOptions): SerializedNode | undefined {\n  switch (node.nodeType) {\n    case node.DOCUMENT_NODE:\n      return serializeDocumentNode(node as Document, options)\n    case node.DOCUMENT_FRAGMENT_NODE:\n      return serializeDocumentFragmentNode(node as DocumentFragment, options)\n    case node.DOCUMENT_TYPE_NODE:\n      return serializeDocumentTypeNode(node as DocumentType)\n    case node.ELEMENT_NODE:\n      return serializeElementNode(node as Element, options)\n    case node.TEXT_NODE:\n      return serializeTextNode(node as Text, options)\n    case node.CDATA_SECTION_NODE:\n      return serializeCDataNode()\n  }\n}\n\nexport function serializeDocumentNode(document: Document, options: SerializeOptions): DocumentNode {\n  return {\n    type: NodeType.Document,\n    childNodes: serializeChildNodes(document, options),\n    adoptedStyleSheets: serializeStyleSheets(document.adoptedStyleSheets),\n  }\n}\n\nfunction serializeDocumentFragmentNode(\n  element: DocumentFragment,\n  options: SerializeOptions\n): DocumentFragmentNode | undefined {\n  const isShadowRoot = isNodeShadowRoot(element)\n  if (isShadowRoot) {\n    options.serializationContext.shadowRootsController.addShadowRoot(element)\n  }\n\n  return {\n    type: NodeType.DocumentFragment,\n    childNodes: serializeChildNodes(element, options),\n    isShadowRoot,\n    adoptedStyleSheets: isShadowRoot ? serializeStyleSheets(element.adoptedStyleSheets) : undefined,\n  }\n}\n\nfunction serializeDocumentTypeNode(documentType: DocumentType): DocumentTypeNode {\n  return {\n    type: NodeType.DocumentType,\n    name: documentType.name,\n    publicId: documentType.publicId,\n    systemId: documentType.systemId,\n  }\n}\n\n/**\n * Serializing Element nodes involves capturing:\n * 1. HTML ATTRIBUTES:\n * 2. JS STATE:\n * - scroll offsets\n * - Form fields (input value, checkbox checked, option selection, range)\n * - Canvas state,\n * - Media (video/audio) play mode + currentTime\n * - iframe contents\n * - webcomponents\n * 3. CUSTOM PROPERTIES:\n * - height+width for when `hidden` to cover the element\n * 4. EXCLUDED INTERACTION STATE:\n * - focus (possible, but not worth perf impact)\n * - hover (tracked only via mouse activity)\n * - fullscreen mode\n */\n\nfunction serializeElementNode(element: Element, options: SerializeOptions): ElementNode | undefined {\n  const tagName = getValidTagName(element.tagName)\n  const isSVG = isSVGElement(element) || undefined\n\n  // For performance reason, we don't use getNodePrivacyLevel directly: we leverage the\n  // parentNodePrivacyLevel option to avoid iterating over all parents\n  const nodePrivacyLevel = reducePrivacyLevel(getNodeSelfPrivacyLevel(element), options.parentNodePrivacyLevel)\n\n  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    const { width, height } = element.getBoundingClientRect()\n    return {\n      type: NodeType.Element,\n      tagName,\n      attributes: {\n        rr_width: `${width}px`,\n        rr_height: `${height}px`,\n        [PRIVACY_ATTR_NAME]: PRIVACY_ATTR_VALUE_HIDDEN,\n      },\n      childNodes: [],\n      isSVG,\n    }\n  }\n\n  // Ignore Elements like Script and some Link, Metas\n  if (nodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n    return\n  }\n\n  const attributes = serializeAttributes(element, nodePrivacyLevel, options)\n\n  let childNodes: SerializedNodeWithId[] = []\n  if (\n    hasChildNodes(element) &&\n    // Do not serialize style children as the css rules are already in the _cssText attribute\n    tagName !== 'style'\n  ) {\n    // OBJECT POOLING OPTIMIZATION:\n    // We should not create a new object systematically as it could impact performances. Try to reuse\n    // the same object as much as possible, and clone it only if we need to.\n    let childNodesSerializationOptions\n    if (options.parentNodePrivacyLevel === nodePrivacyLevel && options.ignoreWhiteSpace === (tagName === 'head')) {\n      childNodesSerializationOptions = options\n    } else {\n      childNodesSerializationOptions = {\n        ...options,\n        parentNodePrivacyLevel: nodePrivacyLevel,\n        ignoreWhiteSpace: tagName === 'head',\n      }\n    }\n    childNodes = serializeChildNodes(element, childNodesSerializationOptions)\n  }\n\n  return {\n    type: NodeType.Element,\n    tagName,\n    attributes,\n    childNodes,\n    isSVG,\n  }\n}\n\nfunction isSVGElement(el: Element): boolean {\n  return el.tagName === 'svg' || el instanceof SVGElement\n}\n\n/**\n * Text Nodes are dependant on Element nodes\n * Privacy levels are set on elements so we check the parentElement of a text node\n * for privacy level.\n */\n\nfunction serializeTextNode(textNode: Text, options: SerializeOptions): TextNode | undefined {\n  const textContent = getTextContent(textNode, options.ignoreWhiteSpace || false, options.parentNodePrivacyLevel)\n  if (textContent === undefined) {\n    return\n  }\n  return {\n    type: NodeType.Text,\n    textContent,\n  }\n}\n\nfunction serializeCDataNode(): CDataNode {\n  return {\n    type: NodeType.CDATA,\n    textContent: '',\n  }\n}\n", "import type { RumConfiguration } from '@datadog/browser-rum-core'\nimport type { SerializedNodeWithId } from '../../../types'\nimport type { SerializationContext } from './serialization.types'\nimport { serializeNodeWithId } from './serializeNode'\n\nexport function serializeDocument(\n  document: Document,\n  configuration: RumConfiguration,\n  serializationContext: SerializationContext\n): SerializedNodeWithId {\n  // We are sure that Documents are never ignored, so this function never returns null\n  return serializeNodeWithId(document, {\n    serializationContext,\n    parentNodePrivacyLevel: configuration.defaultPrivacyLevel,\n    configuration,\n  })!\n}\n", "import { isNodeShadowHost } from '@datadog/browser-rum-core'\n\nexport function isTouchEvent(event: MouseEvent | TouchEvent): event is TouchEvent {\n  return Boolean((event as TouchEvent).changedTouches)\n}\n\nexport function getEventTarget(event: Event): Node {\n  if (event.composed === true && isNodeShadowHost(event.target as Node)) {\n    return event.composedPath()[0] as Node\n  }\n  return event.target as Node\n}\n", "/**\n * Browsers have not standardized various dimension properties. Mobile devices typically report\n * dimensions in reference to the visual viewport, while desktop uses the layout viewport. For example,\n * Mobile Chrome will change innerWidth when a pinch zoom takes place, while Chrome Desktop (mac) will not.\n *\n * With the new Viewport API, we now calculate and normalize dimension properties to the layout viewport.\n * If the VisualViewport API is not supported by a browser, it isn't reasonably possible to detect or normalize\n * which viewport is being measured. Therefore these exported functions will fallback to assuming that the layout\n * viewport is being measured by the browser\n */\n\nimport type { VisualViewportRecord } from '../../types'\n\n// Scrollbar widths vary across properties on different devices and browsers\nconst TOLERANCE = 25\n\n/**\n * Use the Visual Viewport API's properties to measure scrollX/Y in reference to the layout viewport\n * in order to determine if window.scrollX/Y is measuring the layout or visual viewport.\n * This finding corresponds to which viewport mouseEvent.clientX/Y and window.innerWidth/Height measures.\n */\nfunction isVisualViewportFactoredIn(visualViewport: VisualViewport) {\n  return (\n    Math.abs(visualViewport.pageTop - visualViewport.offsetTop - window.scrollY) > TOLERANCE ||\n    Math.abs(visualViewport.pageLeft - visualViewport.offsetLeft - window.scrollX) > TOLERANCE\n  )\n}\n\ninterface LayoutCoordinates {\n  layoutViewportX: number\n  layoutViewportY: number\n  visualViewportX: number\n  visualViewportY: number\n}\n\nexport const convertMouseEventToLayoutCoordinates = (clientX: number, clientY: number): LayoutCoordinates => {\n  const visualViewport = window.visualViewport\n  const normalized: LayoutCoordinates = {\n    layoutViewportX: clientX,\n    layoutViewportY: clientY,\n    visualViewportX: clientX,\n    visualViewportY: clientY,\n  }\n\n  if (!visualViewport) {\n    // On old browsers, we cannot normalize, so fallback to clientX/Y\n    return normalized\n  } else if (isVisualViewportFactoredIn(visualViewport)) {\n    // Typically Mobile Devices\n    normalized.layoutViewportX = Math.round(clientX + visualViewport.offsetLeft)\n    normalized.layoutViewportY = Math.round(clientY + visualViewport.offsetTop)\n  } else {\n    // Typically Desktop Devices\n    normalized.visualViewportX = Math.round(clientX - visualViewport.offsetLeft)\n    normalized.visualViewportY = Math.round(clientY - visualViewport.offsetTop)\n  }\n  return normalized\n}\n\nexport const getVisualViewport = (visualViewport: VisualViewport): VisualViewportRecord['data'] => ({\n  scale: visualViewport.scale,\n  offsetLeft: visualViewport.offsetLeft,\n  offsetTop: visualViewport.offsetTop,\n  pageLeft: visualViewport.pageLeft,\n  pageTop: visualViewport.pageTop,\n  height: visualViewport.height,\n  width: visualViewport.width,\n})\n", "import { timeStampNow } from '@datadog/browser-core'\nimport type { BrowserIncrementalData, BrowserIncrementalSnapshotRecord } from '../../types'\nimport { RecordType } from '../../types'\n\nexport function assembleIncrementalSnapshot<Data extends BrowserIncrementalData>(\n  source: Data['source'],\n  data: Omit<Data, 'source'>\n): BrowserIncrementalSnapshotRecord {\n  return {\n    data: {\n      source,\n      ...data,\n    } as Data,\n    type: RecordType.IncrementalSnapshot,\n    timestamp: timeStampNow(),\n  }\n}\n", "import { addEventListeners, addTelemetryDebug, DOM_EVENT, throttle } from '@datadog/browser-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization'\nimport type { BrowserIncrementalSnapshotRecord, MousemoveData, MousePosition } from '../../../types'\nimport { IncrementalSource } from '../../../types'\nimport { getEventTarget, isTouchEvent } from '../eventsUtils'\nimport { convertMouseEventToLayoutCoordinates } from '../viewports'\nimport { assembleIncrementalSnapshot } from '../assembly'\nimport type { Tracker } from './tracker.types'\n\nconst MOUSE_MOVE_OBSERVER_THRESHOLD = 50\n\nexport type MousemoveCallBack = (incrementalSnapshotRecord: BrowserIncrementalSnapshotRecord) => void\n\nexport function trackMove(configuration: RumConfiguration, moveCb: MousemoveCallBack): Tracker {\n  const { throttled: updatePosition, cancel: cancelThrottle } = throttle(\n    (event: MouseEvent | TouchEvent) => {\n      const target = getEventTarget(event)\n      if (hasSerializedNode(target)) {\n        const coordinates = tryToComputeCoordinates(event)\n        if (!coordinates) {\n          return\n        }\n        const position: MousePosition = {\n          id: getSerializedNodeId(target),\n          timeOffset: 0,\n          x: coordinates.x,\n          y: coordinates.y,\n        }\n\n        moveCb(\n          assembleIncrementalSnapshot<MousemoveData>(\n            isTouchEvent(event) ? IncrementalSource.TouchMove : IncrementalSource.MouseMove,\n            { positions: [position] }\n          )\n        )\n      }\n    },\n    MOUSE_MOVE_OBSERVER_THRESHOLD,\n    {\n      trailing: false,\n    }\n  )\n\n  const { stop: removeListener } = addEventListeners(\n    configuration,\n    document,\n    [DOM_EVENT.MOUSE_MOVE, DOM_EVENT.TOUCH_MOVE],\n    updatePosition,\n    {\n      capture: true,\n      passive: true,\n    }\n  )\n\n  return {\n    stop: () => {\n      removeListener()\n      cancelThrottle()\n    },\n  }\n}\n\nexport function tryToComputeCoordinates(event: MouseEvent | TouchEvent) {\n  let { clientX: x, clientY: y } = isTouchEvent(event) ? event.changedTouches[0] : event\n  if (window.visualViewport) {\n    const { visualViewportX, visualViewportY } = convertMouseEventToLayoutCoordinates(x, y)\n    x = visualViewportX\n    y = visualViewportY\n  }\n  if (!Number.isFinite(x) || !Number.isFinite(y)) {\n    if (event.isTrusted) {\n      addTelemetryDebug('mouse/touch event without x/y')\n    }\n    return undefined\n  }\n  return { x, y }\n}\n", "import { addEventListeners, DOM_EVENT } from '@datadog/browser-core'\nimport { getNodePrivacyLevel, NodePrivacyLevel } from '@datadog/browser-rum-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport type { MouseInteraction, MouseInteractionData, BrowserIncrementalSnapshotRecord } from '../../../types'\nimport { IncrementalSource, MouseInteractionType } from '../../../types'\nimport { assembleIncrementalSnapshot } from '../assembly'\nimport { getEventTarget } from '../eventsUtils'\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization'\nimport type { RecordIds } from '../recordIds'\nimport { tryToComputeCoordinates } from './trackMove'\nimport type { Tracker } from './tracker.types'\n\nconst eventTypeToMouseInteraction = {\n  // Listen for pointerup DOM events instead of mouseup for MouseInteraction/MouseUp records. This\n  // allows to reference such records from Frustration records.\n  //\n  // In the context of supporting Mobile Session Replay, we introduced `PointerInteraction` records\n  // used by the Mobile SDKs in place of `MouseInteraction`. In the future, we should replace\n  // `MouseInteraction` by `PointerInteraction` in the Browser SDK so we have an uniform way to\n  // convey such interaction. This would cleanly solve the issue since we would have\n  // `PointerInteraction/Up` records that we could reference from `Frustration` records.\n  [DOM_EVENT.POINTER_UP]: MouseInteractionType.MouseUp,\n\n  [DOM_EVENT.MOUSE_DOWN]: MouseInteractionType.MouseDown,\n  [DOM_EVENT.CLICK]: MouseInteractionType.Click,\n  [DOM_EVENT.CONTEXT_MENU]: MouseInteractionType.ContextMenu,\n  [DOM_EVENT.DBL_CLICK]: MouseInteractionType.DblClick,\n  [DOM_EVENT.FOCUS]: MouseInteractionType.Focus,\n  [DOM_EVENT.BLUR]: MouseInteractionType.Blur,\n  [DOM_EVENT.TOUCH_START]: MouseInteractionType.TouchStart,\n  [DOM_EVENT.TOUCH_END]: MouseInteractionType.TouchEnd,\n}\n\nexport type MouseInteractionCallback = (record: BrowserIncrementalSnapshotRecord) => void\n\nexport function trackMouseInteraction(\n  configuration: RumConfiguration,\n  mouseInteractionCb: MouseInteractionCallback,\n  recordIds: RecordIds\n): Tracker {\n  const handler = (event: MouseEvent | TouchEvent | FocusEvent) => {\n    const target = getEventTarget(event)\n    if (\n      getNodePrivacyLevel(target, configuration.defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN ||\n      !hasSerializedNode(target)\n    ) {\n      return\n    }\n    const id = getSerializedNodeId(target)\n    const type = eventTypeToMouseInteraction[event.type as keyof typeof eventTypeToMouseInteraction]\n\n    let interaction: MouseInteraction\n    if (type !== MouseInteractionType.Blur && type !== MouseInteractionType.Focus) {\n      const coordinates = tryToComputeCoordinates(event as MouseEvent | TouchEvent)\n      if (!coordinates) {\n        return\n      }\n      interaction = { id, type, x: coordinates.x, y: coordinates.y }\n    } else {\n      interaction = { id, type }\n    }\n\n    const record = {\n      id: recordIds.getIdForEvent(event),\n      ...assembleIncrementalSnapshot<MouseInteractionData>(IncrementalSource.MouseInteraction, interaction),\n    }\n\n    mouseInteractionCb(record)\n  }\n  return addEventListeners(\n    configuration,\n    document,\n    Object.keys(eventTypeToMouseInteraction) as Array<keyof typeof eventTypeToMouseInteraction>,\n    handler,\n    {\n      capture: true,\n      passive: true,\n    }\n  )\n}\n", "import { DOM_EVENT, throttle, addEventListener } from '@datadog/browser-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport { getScrollX, getScrollY, getNodePrivacyLevel, NodePrivacyLevel } from '@datadog/browser-rum-core'\nimport type { ElementsScrollPositions } from '../elementsScrollPositions'\nimport { getEventTarget } from '../eventsUtils'\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization'\nimport { IncrementalSource } from '../../../types'\nimport type { BrowserIncrementalSnapshotRecord, ScrollData } from '../../../types'\nimport { assembleIncrementalSnapshot } from '../assembly'\nimport type { Tracker } from './tracker.types'\n\nconst SCROLL_OBSERVER_THRESHOLD = 100\n\nexport type ScrollCallback = (incrementalSnapshotRecord: BrowserIncrementalSnapshotRecord) => void\n\nexport function trackScroll(\n  configuration: RumConfiguration,\n  scrollCb: ScrollCallback,\n  elementsScrollPositions: ElementsScrollPositions,\n  target: Document | ShadowRoot = document\n): Tracker {\n  const { throttled: updatePosition, cancel: cancelThrottle } = throttle((event: Event) => {\n    const target = getEventTarget(event) as HTMLElement | Document\n    if (\n      !target ||\n      getNodePrivacyLevel(target, configuration.defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN ||\n      !hasSerializedNode(target)\n    ) {\n      return\n    }\n    const id = getSerializedNodeId(target)\n    const scrollPositions =\n      target === document\n        ? {\n            scrollTop: getScrollY(),\n            scrollLeft: getScrollX(),\n          }\n        : {\n            scrollTop: Math.round((target as HTMLElement).scrollTop),\n            scrollLeft: Math.round((target as HTMLElement).scrollLeft),\n          }\n    elementsScrollPositions.set(target, scrollPositions)\n    scrollCb(\n      assembleIncrementalSnapshot<ScrollData>(IncrementalSource.Scroll, {\n        id,\n        x: scrollPositions.scrollLeft,\n        y: scrollPositions.scrollTop,\n      })\n    )\n  }, SCROLL_OBSERVER_THRESHOLD)\n\n  const { stop: removeListener } = addEventListener(configuration, target, DOM_EVENT.SCROLL, updatePosition, {\n    capture: true,\n    passive: true,\n  })\n\n  return {\n    stop: () => {\n      removeListener()\n      cancelThrottle()\n    },\n  }\n}\n", "import { throttle, DOM_EVENT, addEventListeners, timeStampNow, noop } from '@datadog/browser-core'\nimport type { RumConfiguration, ViewportDimension } from '@datadog/browser-rum-core'\nimport { initViewportObservable } from '@datadog/browser-rum-core'\nimport { IncrementalSource, RecordType } from '../../../types'\nimport type { BrowserIncrementalSnapshotRecord, ViewportResizeData, VisualViewportRecord } from '../../../types'\nimport { getVisualViewport } from '../viewports'\nimport { assembleIncrementalSnapshot } from '../assembly'\nimport type { Tracker } from './tracker.types'\n\nconst VISUAL_VIEWPORT_OBSERVER_THRESHOLD = 200\n\nexport type ViewportResizeCallback = (incrementalSnapshotRecord: BrowserIncrementalSnapshotRecord) => void\n\nexport type VisualViewportResizeCallback = (visualViewportRecord: VisualViewportRecord) => void\n\nexport function trackViewportResize(\n  configuration: RumConfiguration,\n  viewportResizeCb: ViewportResizeCallback\n): Tracker {\n  const viewportResizeSubscription = initViewportObservable(configuration).subscribe((data: ViewportDimension) => {\n    viewportResizeCb(assembleIncrementalSnapshot<ViewportResizeData>(IncrementalSource.ViewportResize, data))\n  })\n\n  return {\n    stop: () => {\n      viewportResizeSubscription.unsubscribe()\n    },\n  }\n}\n\nexport function trackVisualViewportResize(\n  configuration: RumConfiguration,\n  visualViewportResizeCb: VisualViewportResizeCallback\n): Tracker {\n  const visualViewport = window.visualViewport\n  if (!visualViewport) {\n    return { stop: noop }\n  }\n  const { throttled: updateDimension, cancel: cancelThrottle } = throttle(\n    () => {\n      visualViewportResizeCb({\n        data: getVisualViewport(visualViewport),\n        type: RecordType.VisualViewport,\n        timestamp: timeStampNow(),\n      })\n    },\n    VISUAL_VIEWPORT_OBSERVER_THRESHOLD,\n    {\n      trailing: false,\n    }\n  )\n  const { stop: removeListener } = addEventListeners(\n    configuration,\n    visualViewport,\n    [DOM_EVENT.RESIZE, DOM_EVENT.SCROLL],\n    updateDimension,\n    {\n      capture: true,\n      passive: true,\n    }\n  )\n\n  return {\n    stop: () => {\n      removeListener()\n      cancelThrottle()\n    },\n  }\n}\n", "import { DOM_EVENT, addEventListeners } from '@datadog/browser-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport { NodePrivacyLevel, getNodePrivacyLevel } from '@datadog/browser-rum-core'\nimport type { BrowserIncrementalSnapshotRecord, MediaInteractionData } from '../../../types'\nimport { IncrementalSource, MediaInteractionType } from '../../../types'\nimport { getEventTarget } from '../eventsUtils'\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization'\nimport { assembleIncrementalSnapshot } from '../assembly'\nimport type { Tracker } from './tracker.types'\n\nexport type MediaInteractionCallback = (incrementalSnapshotRecord: BrowserIncrementalSnapshotRecord) => void\n\nexport function trackMediaInteraction(\n  configuration: RumConfiguration,\n  mediaInteractionCb: MediaInteractionCallback\n): Tracker {\n  return addEventListeners(\n    configuration,\n    document,\n    [DOM_EVENT.PLAY, DOM_EVENT.PAUSE],\n    (event) => {\n      const target = getEventTarget(event)\n      if (\n        !target ||\n        getNodePrivacyLevel(target, configuration.defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN ||\n        !hasSerializedNode(target)\n      ) {\n        return\n      }\n      mediaInteractionCb(\n        assembleIncrementalSnapshot<MediaInteractionData>(IncrementalSource.MediaInteraction, {\n          id: getSerializedNodeId(target),\n          type: event.type === DOM_EVENT.PLAY ? MediaInteractionType.Play : MediaInteractionType.Pause,\n        })\n      )\n    },\n    {\n      capture: true,\n      passive: true,\n    }\n  )\n}\n", "import { instrumentMethod } from '@datadog/browser-core'\nimport { IncrementalSource } from '../../../types'\nimport type { StyleSheetRuleData, BrowserIncrementalSnapshotRecord } from '../../../types'\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization'\nimport { assembleIncrementalSnapshot } from '../assembly'\nimport type { Tracker } from './tracker.types'\n\ntype GroupingCSSRuleTypes = typeof CSSGroupingRule | typeof CSSMediaRule | typeof CSSSupportsRule\n\nexport type StyleSheetCallback = (incrementalSnapshotRecord: BrowserIncrementalSnapshotRecord) => void\n\nexport function trackStyleSheet(styleSheetCb: StyleSheetCallback): Tracker {\n  function checkStyleSheetAndCallback(styleSheet: CSSStyleSheet | null, callback: (id: number) => void): void {\n    if (styleSheet && hasSerializedNode(styleSheet.ownerNode!)) {\n      callback(getSerializedNodeId(styleSheet.ownerNode))\n    }\n  }\n\n  const instrumentationStoppers = [\n    instrumentMethod(CSSStyleSheet.prototype, 'insertRule', ({ target: styleSheet, parameters: [rule, index] }) => {\n      checkStyleSheetAndCallback(styleSheet, (id) =>\n        styleSheetCb(\n          assembleIncrementalSnapshot<StyleSheetRuleData>(IncrementalSource.StyleSheetRule, {\n            id,\n            adds: [{ rule, index }],\n          })\n        )\n      )\n    }),\n\n    instrumentMethod(CSSStyleSheet.prototype, 'deleteRule', ({ target: styleSheet, parameters: [index] }) => {\n      checkStyleSheetAndCallback(styleSheet, (id) =>\n        styleSheetCb(\n          assembleIncrementalSnapshot<StyleSheetRuleData>(IncrementalSource.StyleSheetRule, {\n            id,\n            removes: [{ index }],\n          })\n        )\n      )\n    }),\n  ]\n\n  if (typeof CSSGroupingRule !== 'undefined') {\n    instrumentGroupingCSSRuleClass(CSSGroupingRule)\n  } else {\n    instrumentGroupingCSSRuleClass(CSSMediaRule)\n    instrumentGroupingCSSRuleClass(CSSSupportsRule)\n  }\n\n  function instrumentGroupingCSSRuleClass(cls: GroupingCSSRuleTypes) {\n    instrumentationStoppers.push(\n      instrumentMethod(cls.prototype, 'insertRule', ({ target: styleSheet, parameters: [rule, index] }) => {\n        checkStyleSheetAndCallback(styleSheet.parentStyleSheet, (id) => {\n          const path = getPathToNestedCSSRule(styleSheet)\n          if (path) {\n            path.push(index || 0)\n            styleSheetCb(\n              assembleIncrementalSnapshot<StyleSheetRuleData>(IncrementalSource.StyleSheetRule, {\n                id,\n                adds: [{ rule, index: path }],\n              })\n            )\n          }\n        })\n      }),\n\n      instrumentMethod(cls.prototype, 'deleteRule', ({ target: styleSheet, parameters: [index] }) => {\n        checkStyleSheetAndCallback(styleSheet.parentStyleSheet, (id) => {\n          const path = getPathToNestedCSSRule(styleSheet)\n          if (path) {\n            path.push(index)\n            styleSheetCb(\n              assembleIncrementalSnapshot<StyleSheetRuleData>(IncrementalSource.StyleSheetRule, {\n                id,\n                removes: [{ index: path }],\n              })\n            )\n          }\n        })\n      })\n    )\n  }\n\n  return {\n    stop: () => {\n      instrumentationStoppers.forEach((stopper) => stopper.stop())\n    },\n  }\n}\n\nexport function getPathToNestedCSSRule(rule: CSSRule): number[] | undefined {\n  const path: number[] = []\n  let currentRule = rule\n  while (currentRule.parentRule) {\n    const rules = Array.from((currentRule.parentRule as CSSGroupingRule).cssRules)\n    const index = rules.indexOf(currentRule)\n    path.unshift(index)\n    currentRule = currentRule.parentRule\n  }\n  // A rule may not be attached to a stylesheet\n  if (!currentRule.parentStyleSheet) {\n    return\n  }\n\n  const rules = Array.from(currentRule.parentStyleSheet.cssRules)\n  const index = rules.indexOf(currentRule)\n  path.unshift(index)\n\n  return path\n}\n", "import { DOM_EVENT, addEventListeners, timeStampNow } from '@datadog/browser-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport { RecordType, type FocusRecord } from '../../../types'\nimport type { Tracker } from './tracker.types'\n\nexport type FocusCallback = (data: FocusRecord) => void\n\nexport function trackFocus(configuration: RumConfiguration, focusCb: FocusCallback): Tracker {\n  return addEventListeners(configuration, window, [DOM_EVENT.FOCUS, DOM_EVENT.BLUR], () => {\n    focusCb({\n      data: { has_focus: document.hasFocus() },\n      type: RecordType.Focus,\n      timestamp: timeStampNow(),\n    })\n  })\n}\n", "import type { LifeCycle } from '@datadog/browser-rum-core'\nimport { ActionType, RumEventType, LifeCycleEventType } from '@datadog/browser-rum-core'\nimport type { FrustrationRecord } from '../../../types'\nimport { RecordType } from '../../../types'\nimport type { RecordIds } from '../recordIds'\nimport type { Tracker } from './tracker.types'\n\nexport type FrustrationCallback = (record: FrustrationRecord) => void\n\nexport function trackFrustration(\n  lifeCycle: LifeCycle,\n  frustrationCb: FrustrationCallback,\n  recordIds: RecordIds\n): Tracker {\n  const frustrationSubscription = lifeCycle.subscribe(LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, (data) => {\n    if (\n      data.rawRumEvent.type === RumEventType.ACTION &&\n      data.rawRumEvent.action.type === ActionType.CLICK &&\n      data.rawRumEvent.action.frustration?.type?.length &&\n      'events' in data.domainContext &&\n      data.domainContext.events &&\n      data.domainContext.events.length\n    ) {\n      frustrationCb({\n        timestamp: data.rawRumEvent.date,\n        type: RecordType.FrustrationRecord,\n        data: {\n          frustrationTypes: data.rawRumEvent.action.frustration.type,\n          recordIds: data.domainContext.events.map((e) => recordIds.getIdForEvent(e)),\n        },\n      })\n    }\n  })\n\n  return {\n    stop: () => {\n      frustrationSubscription.unsubscribe()\n    },\n  }\n}\n", "import { timeStampNow } from '@datadog/browser-core'\nimport type { LifeCycle } from '@datadog/browser-rum-core'\nimport { LifeCycleEventType } from '@datadog/browser-rum-core'\nimport type { ViewEndRecord } from '../../../types'\nimport { RecordType } from '../../../types'\nimport type { Tracker } from './tracker.types'\n\nexport type ViewEndCallback = (record: ViewEndRecord) => void\n\nexport function trackViewEnd(lifeCycle: LifeCycle, viewEndCb: ViewEndCallback): Tracker {\n  const viewEndSubscription = lifeCycle.subscribe(LifeCycleEventType.VIEW_ENDED, () => {\n    viewEndCb({\n      timestamp: timeStampNow(),\n      type: RecordType.ViewEnd,\n    })\n  })\n\n  return {\n    stop: () => {\n      viewEndSubscription.unsubscribe()\n    },\n  }\n}\n", "import { instrumentSetter, DOM_EVENT, addEventListeners, noop } from '@datadog/browser-core'\nimport { NodePrivacyLevel, getNodePrivacyLevel, shouldMaskNode } from '@datadog/browser-rum-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport { IncrementalSource } from '../../../types'\nimport type { BrowserIncrementalSnapshotRecord, InputData, InputState } from '../../../types'\nimport { getEventTarget } from '../eventsUtils'\nimport { getElementInputValue, getSerializedNodeId, hasSerializedNode } from '../serialization'\nimport { assembleIncrementalSnapshot } from '../assembly'\nimport type { Tracker } from './tracker.types'\n\nexport type InputCallback = (incrementalSnapshotRecord: BrowserIncrementalSnapshotRecord) => void\n\nexport function trackInput(\n  configuration: RumConfiguration,\n  inputCb: InputCallback,\n  target: Document | ShadowRoot = document\n): Tracker {\n  const defaultPrivacyLevel = configuration.defaultPrivacyLevel\n  const lastInputStateMap: WeakMap<Node, InputState> = new WeakMap()\n\n  const isShadowRoot = target !== document\n\n  const { stop: stopEventListeners } = addEventListeners(\n    configuration,\n    target,\n    // The 'input' event bubbles across shadow roots, so we don't have to listen for it on shadow\n    // roots since it will be handled by the event listener that we did add to the document. Only\n    // the 'change' event is blocked and needs to be handled on shadow roots.\n    isShadowRoot ? [DOM_EVENT.CHANGE] : [DOM_EVENT.INPUT, DOM_EVENT.CHANGE],\n    (event) => {\n      const target = getEventTarget(event)\n      if (\n        target instanceof HTMLInputElement ||\n        target instanceof HTMLTextAreaElement ||\n        target instanceof HTMLSelectElement\n      ) {\n        onElementChange(target)\n      }\n    },\n    {\n      capture: true,\n      passive: true,\n    }\n  )\n\n  let stopPropertySetterInstrumentation: () => void\n  if (!isShadowRoot) {\n    const instrumentationStoppers = [\n      instrumentSetter(HTMLInputElement.prototype, 'value', onElementChange),\n      instrumentSetter(HTMLInputElement.prototype, 'checked', onElementChange),\n      instrumentSetter(HTMLSelectElement.prototype, 'value', onElementChange),\n      instrumentSetter(HTMLTextAreaElement.prototype, 'value', onElementChange),\n      instrumentSetter(HTMLSelectElement.prototype, 'selectedIndex', onElementChange),\n    ]\n    stopPropertySetterInstrumentation = () => {\n      instrumentationStoppers.forEach((stopper) => stopper.stop())\n    }\n  } else {\n    stopPropertySetterInstrumentation = noop\n  }\n\n  return {\n    stop: () => {\n      stopPropertySetterInstrumentation()\n      stopEventListeners()\n    },\n  }\n\n  function onElementChange(target: HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement) {\n    const nodePrivacyLevel = getNodePrivacyLevel(target, defaultPrivacyLevel)\n    if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n      return\n    }\n\n    const type = target.type\n\n    let inputState: InputState\n    if (type === 'radio' || type === 'checkbox') {\n      if (shouldMaskNode(target, nodePrivacyLevel)) {\n        return\n      }\n      inputState = { isChecked: (target as HTMLInputElement).checked }\n    } else {\n      const value = getElementInputValue(target, nodePrivacyLevel)\n      if (value === undefined) {\n        return\n      }\n      inputState = { text: value }\n    }\n\n    // Can be multiple changes on the same node within the same batched mutation observation.\n    cbWithDedup(target, inputState)\n\n    // If a radio was checked, other radios with the same name attribute will be unchecked.\n    const name = target.name\n    if (type === 'radio' && name && (target as HTMLInputElement).checked) {\n      document.querySelectorAll(`input[type=\"radio\"][name=\"${CSS.escape(name)}\"]`).forEach((el: Element) => {\n        if (el !== target) {\n          // TODO: Consider the privacy implications for various differing input privacy levels\n          cbWithDedup(el, { isChecked: false })\n        }\n      })\n    }\n  }\n\n  /**\n   * There can be multiple changes on the same node within the same batched mutation observation.\n   */\n  function cbWithDedup(target: Node, inputState: InputState) {\n    if (!hasSerializedNode(target)) {\n      return\n    }\n    const lastInputState = lastInputStateMap.get(target)\n    if (\n      !lastInputState ||\n      (lastInputState as { text?: string }).text !== (inputState as { text?: string }).text ||\n      (lastInputState as { isChecked?: boolean }).isChecked !== (inputState as { isChecked?: boolean }).isChecked\n    ) {\n      lastInputStateMap.set(target, inputState)\n      inputCb(\n        assembleIncrementalSnapshot<InputData>(IncrementalSource.Input, {\n          id: getSerializedNodeId(target),\n          ...inputState,\n        })\n      )\n    }\n  }\n}\n", "import { noop, throttle, requestIdleCallback } from '@datadog/browser-core'\nimport type { RumMutationRecord } from '@datadog/browser-rum-core'\n\n/**\n * Maximum duration to wait before processing mutations. If the browser is idle, mutations will be\n * processed more quickly. If the browser is busy executing small tasks (ex: rendering frames), the\n * mutations will wait MUTATION_PROCESS_MAX_DELAY milliseconds before being processed. If the\n * browser is busy executing a longer task, mutations will be processed after this task.\n */\nconst MUTATION_PROCESS_MAX_DELAY = 100\n/**\n * Minimum duration to wait before processing mutations. This is used to batch mutations together\n * and be able to deduplicate them to save processing time and bandwidth.\n * 16ms is the duration of a frame at 60fps that ensure fluid UI.\n */\nexport const MUTATION_PROCESS_MIN_DELAY = 16\n\nexport function createMutationBatch(processMutationBatch: (mutations: RumMutationRecord[]) => void) {\n  let cancelScheduledFlush = noop\n  let pendingMutations: RumMutationRecord[] = []\n\n  function flush() {\n    cancelScheduledFlush()\n    processMutationBatch(pendingMutations)\n    pendingMutations = []\n  }\n\n  const { throttled: throttledFlush, cancel: cancelThrottle } = throttle(flush, MUTATION_PROCESS_MIN_DELAY, {\n    leading: false,\n  })\n\n  return {\n    addMutations: (mutations: RumMutationRecord[]) => {\n      if (pendingMutations.length === 0) {\n        cancelScheduledFlush = requestIdleCallback(throttledFlush, { timeout: MUTATION_PROCESS_MAX_DELAY })\n      }\n      pendingMutations.push(...mutations)\n    },\n\n    flush,\n\n    stop: () => {\n      cancelScheduledFlush()\n      cancelThrottle()\n    },\n  }\n}\n", "import { monitor, noop } from '@datadog/browser-core'\nimport type {\n  RumConfiguration,\n  NodePrivacyLevelCache,\n  RumMutationRecord,\n  RumChildListMutationRecord,\n  RumCharacterDataMutationRecord,\n  RumAttributesMutationRecord,\n} from '@datadog/browser-rum-core'\nimport {\n  isNodeShadowHost,\n  getMutationObserverConstructor,\n  getParentNode,\n  forEachChildNodes,\n  getNodePrivacyLevel,\n  getTextContent,\n  NodePrivacyLevel,\n} from '@datadog/browser-rum-core'\nimport { IncrementalSource } from '../../../types'\nimport type {\n  BrowserMutationData,\n  AddedNodeMutation,\n  AttributeMutation,\n  RemovedNodeMutation,\n  TextMutation,\n  BrowserIncrementalSnapshotRecord,\n} from '../../../types'\nimport type { NodeWithSerializedNode } from '../serialization'\nimport {\n  getElementInputValue,\n  getSerializedNodeId,\n  hasSerializedNode,\n  nodeAndAncestorsHaveSerializedNode,\n  serializeNodeWithId,\n  SerializationContextStatus,\n  serializeAttribute,\n} from '../serialization'\nimport { createMutationBatch } from '../mutationBatch'\nimport type { ShadowRootCallBack, ShadowRootsController } from '../shadowRootsController'\nimport { assembleIncrementalSnapshot } from '../assembly'\nimport type { Tracker } from './tracker.types'\n\nexport type MutationCallBack = (incrementalSnapshotRecord: BrowserIncrementalSnapshotRecord) => void\n\ntype WithSerializedTarget<T> = T & { target: NodeWithSerializedNode }\n\nexport type MutationTracker = Tracker & { flush: () => void }\n\n/**\n * Buffers and aggregate mutations generated by a MutationObserver into MutationPayload\n */\nexport function trackMutation(\n  mutationCallback: MutationCallBack,\n  configuration: RumConfiguration,\n  shadowRootsController: ShadowRootsController,\n  target: Node\n): MutationTracker {\n  const MutationObserver = getMutationObserverConstructor()\n  if (!MutationObserver) {\n    return { stop: noop, flush: noop }\n  }\n\n  const mutationBatch = createMutationBatch((mutations) => {\n    processMutations(\n      mutations.concat(observer.takeRecords() as RumMutationRecord[]),\n      mutationCallback,\n      configuration,\n      shadowRootsController\n    )\n  })\n\n  const observer = new MutationObserver(monitor(mutationBatch.addMutations) as (callback: RumMutationRecord[]) => void)\n\n  observer.observe(target, {\n    attributeOldValue: true,\n    attributes: true,\n    characterData: true,\n    characterDataOldValue: true,\n    childList: true,\n    subtree: true,\n  })\n\n  return {\n    stop: () => {\n      observer.disconnect()\n      mutationBatch.stop()\n    },\n    flush: () => {\n      mutationBatch.flush()\n    },\n  }\n}\n\nfunction processMutations(\n  mutations: RumMutationRecord[],\n  mutationCallback: MutationCallBack,\n  configuration: RumConfiguration,\n  shadowRootsController: ShadowRootsController\n) {\n  const nodePrivacyLevelCache: NodePrivacyLevelCache = new Map()\n\n  mutations\n    .filter((mutation): mutation is RumChildListMutationRecord => mutation.type === 'childList')\n    .forEach((mutation) => {\n      mutation.removedNodes.forEach((removedNode) => {\n        traverseRemovedShadowDom(removedNode, shadowRootsController.removeShadowRoot)\n      })\n    })\n\n  // Discard any mutation with a 'target' node that:\n  // * isn't injected in the current document or isn't known/serialized yet: those nodes are likely\n  // part of a mutation occurring in a parent Node\n  // * should be hidden or ignored\n  const filteredMutations = mutations.filter(\n    (mutation): mutation is WithSerializedTarget<RumMutationRecord> =>\n      mutation.target.isConnected &&\n      nodeAndAncestorsHaveSerializedNode(mutation.target) &&\n      getNodePrivacyLevel(mutation.target, configuration.defaultPrivacyLevel, nodePrivacyLevelCache) !==\n        NodePrivacyLevel.HIDDEN\n  )\n\n  const { adds, removes, hasBeenSerialized } = processChildListMutations(\n    filteredMutations.filter(\n      (mutation): mutation is WithSerializedTarget<RumChildListMutationRecord> => mutation.type === 'childList'\n    ),\n    configuration,\n    shadowRootsController,\n    nodePrivacyLevelCache\n  )\n\n  const texts = processCharacterDataMutations(\n    filteredMutations.filter(\n      (mutation): mutation is WithSerializedTarget<RumCharacterDataMutationRecord> =>\n        mutation.type === 'characterData' && !hasBeenSerialized(mutation.target)\n    ),\n    configuration,\n    nodePrivacyLevelCache\n  )\n\n  const attributes = processAttributesMutations(\n    filteredMutations.filter(\n      (mutation): mutation is WithSerializedTarget<RumAttributesMutationRecord> =>\n        mutation.type === 'attributes' && !hasBeenSerialized(mutation.target)\n    ),\n    configuration,\n    nodePrivacyLevelCache\n  )\n\n  if (!texts.length && !attributes.length && !removes.length && !adds.length) {\n    return\n  }\n\n  mutationCallback(\n    assembleIncrementalSnapshot<BrowserMutationData>(IncrementalSource.Mutation, { adds, removes, texts, attributes })\n  )\n}\n\nfunction processChildListMutations(\n  mutations: Array<WithSerializedTarget<RumChildListMutationRecord>>,\n  configuration: RumConfiguration,\n  shadowRootsController: ShadowRootsController,\n  nodePrivacyLevelCache: NodePrivacyLevelCache\n) {\n  // First, we iterate over mutations to collect:\n  //\n  // * nodes that have been added in the document and not removed by a subsequent mutation\n  // * nodes that have been removed from the document but were not added in a previous mutation\n  //\n  // For this second category, we also collect their previous parent (mutation.target) because we'll\n  // need it to emit a 'remove' mutation.\n  //\n  // Those two categories may overlap: if a node moved from a position to another, it is reported as\n  // two mutation records, one with a \"removedNodes\" and the other with \"addedNodes\". In this case,\n  // the node will be in both sets.\n  const addedAndMovedNodes = new Set<Node>()\n  const removedNodes = new Map<Node, NodeWithSerializedNode>()\n  for (const mutation of mutations) {\n    mutation.addedNodes.forEach((node) => {\n      addedAndMovedNodes.add(node)\n    })\n    mutation.removedNodes.forEach((node) => {\n      if (!addedAndMovedNodes.has(node)) {\n        removedNodes.set(node, mutation.target)\n      }\n      addedAndMovedNodes.delete(node)\n    })\n  }\n\n  // Then, we sort nodes that are still in the document by topological order, for two reasons:\n  //\n  // * We will serialize each added nodes with their descendants. We don't want to serialize a node\n  // twice, so we need to iterate over the parent nodes first and skip any node that is contained in\n  // a precedent node.\n  //\n  // * To emit \"add\" mutations, we need references to the parent and potential next sibling of each\n  // added node. So we need to iterate over the parent nodes first, and when multiple nodes are\n  // siblings, we want to iterate from last to first. This will ensure that any \"next\" node is\n  // already serialized and have an id.\n  const sortedAddedAndMovedNodes = Array.from(addedAndMovedNodes)\n  sortAddedAndMovedNodes(sortedAddedAndMovedNodes)\n\n  // Then, we iterate over our sorted node sets to emit mutations. We collect the newly serialized\n  // node ids in a set to be able to skip subsequent related mutations.\n  const serializedNodeIds = new Set<number>()\n\n  const addedNodeMutations: AddedNodeMutation[] = []\n  for (const node of sortedAddedAndMovedNodes) {\n    if (hasBeenSerialized(node)) {\n      continue\n    }\n\n    const parentNodePrivacyLevel = getNodePrivacyLevel(\n      node.parentNode!,\n      configuration.defaultPrivacyLevel,\n      nodePrivacyLevelCache\n    )\n    if (parentNodePrivacyLevel === NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n      continue\n    }\n\n    const serializedNode = serializeNodeWithId(node, {\n      serializedNodeIds,\n      parentNodePrivacyLevel,\n      serializationContext: { status: SerializationContextStatus.MUTATION, shadowRootsController },\n      configuration,\n    })\n    if (!serializedNode) {\n      continue\n    }\n\n    const parentNode = getParentNode(node)!\n    addedNodeMutations.push({\n      nextId: getNextSibling(node),\n      parentId: getSerializedNodeId(parentNode)!,\n      node: serializedNode,\n    })\n  }\n  // Finally, we emit remove mutations.\n  const removedNodeMutations: RemovedNodeMutation[] = []\n  removedNodes.forEach((parent, node) => {\n    if (hasSerializedNode(node)) {\n      removedNodeMutations.push({\n        parentId: getSerializedNodeId(parent),\n        id: getSerializedNodeId(node),\n      })\n    }\n  })\n\n  return { adds: addedNodeMutations, removes: removedNodeMutations, hasBeenSerialized }\n\n  function hasBeenSerialized(node: Node) {\n    return hasSerializedNode(node) && serializedNodeIds.has(getSerializedNodeId(node))\n  }\n\n  function getNextSibling(node: Node): null | number {\n    let nextSibling = node.nextSibling\n    while (nextSibling) {\n      if (hasSerializedNode(nextSibling)) {\n        return getSerializedNodeId(nextSibling)\n      }\n      nextSibling = nextSibling.nextSibling\n    }\n\n    return null\n  }\n}\n\nfunction processCharacterDataMutations(\n  mutations: Array<WithSerializedTarget<RumCharacterDataMutationRecord>>,\n  configuration: RumConfiguration,\n  nodePrivacyLevelCache: NodePrivacyLevelCache\n) {\n  const textMutations: TextMutation[] = []\n\n  // Deduplicate mutations based on their target node\n  const handledNodes = new Set<Node>()\n  const filteredMutations = mutations.filter((mutation) => {\n    if (handledNodes.has(mutation.target)) {\n      return false\n    }\n    handledNodes.add(mutation.target)\n    return true\n  })\n\n  // Emit mutations\n  for (const mutation of filteredMutations) {\n    const value = mutation.target.textContent\n    if (value === mutation.oldValue) {\n      continue\n    }\n\n    const parentNodePrivacyLevel = getNodePrivacyLevel(\n      getParentNode(mutation.target)!,\n      configuration.defaultPrivacyLevel,\n      nodePrivacyLevelCache\n    )\n    if (parentNodePrivacyLevel === NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n      continue\n    }\n\n    textMutations.push({\n      id: getSerializedNodeId(mutation.target),\n      // TODO: pass a valid \"ignoreWhiteSpace\" argument\n      value: getTextContent(mutation.target, false, parentNodePrivacyLevel) ?? null,\n    })\n  }\n\n  return textMutations\n}\n\nfunction processAttributesMutations(\n  mutations: Array<WithSerializedTarget<RumAttributesMutationRecord>>,\n  configuration: RumConfiguration,\n  nodePrivacyLevelCache: NodePrivacyLevelCache\n) {\n  const attributeMutations: AttributeMutation[] = []\n\n  // Deduplicate mutations based on their target node and changed attribute\n  const handledElements = new Map<Element, Set<string>>()\n  const filteredMutations = mutations.filter((mutation) => {\n    const handledAttributes = handledElements.get(mutation.target)\n    if (handledAttributes && handledAttributes.has(mutation.attributeName!)) {\n      return false\n    }\n    if (!handledAttributes) {\n      handledElements.set(mutation.target, new Set([mutation.attributeName!]))\n    } else {\n      handledAttributes.add(mutation.attributeName!)\n    }\n    return true\n  })\n\n  // Emit mutations\n  const emittedMutations = new Map<Element, AttributeMutation>()\n  for (const mutation of filteredMutations) {\n    const uncensoredValue = mutation.target.getAttribute(mutation.attributeName!)\n    if (uncensoredValue === mutation.oldValue) {\n      continue\n    }\n    const privacyLevel = getNodePrivacyLevel(mutation.target, configuration.defaultPrivacyLevel, nodePrivacyLevelCache)\n    const attributeValue = serializeAttribute(mutation.target, privacyLevel, mutation.attributeName!, configuration)\n\n    let transformedValue: string | null\n    if (mutation.attributeName === 'value') {\n      const inputValue = getElementInputValue(mutation.target, privacyLevel)\n      if (inputValue === undefined) {\n        continue\n      }\n      transformedValue = inputValue\n    } else if (typeof attributeValue === 'string') {\n      transformedValue = attributeValue\n    } else {\n      transformedValue = null\n    }\n\n    let emittedMutation = emittedMutations.get(mutation.target)\n    if (!emittedMutation) {\n      emittedMutation = {\n        id: getSerializedNodeId(mutation.target),\n        attributes: {},\n      }\n      attributeMutations.push(emittedMutation)\n      emittedMutations.set(mutation.target, emittedMutation)\n    }\n\n    emittedMutation.attributes[mutation.attributeName!] = transformedValue\n  }\n\n  return attributeMutations\n}\n\nexport function sortAddedAndMovedNodes(nodes: Node[]) {\n  nodes.sort((a, b) => {\n    const position = a.compareDocumentPosition(b)\n    /* eslint-disable no-bitwise */\n    if (position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n      return -1\n    } else if (position & Node.DOCUMENT_POSITION_CONTAINS) {\n      return 1\n    } else if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\n      return 1\n    } else if (position & Node.DOCUMENT_POSITION_PRECEDING) {\n      return -1\n    }\n    /* eslint-enable no-bitwise */\n    return 0\n  })\n}\n\nfunction traverseRemovedShadowDom(removedNode: Node, shadowDomRemovedCallback: ShadowRootCallBack) {\n  if (isNodeShadowHost(removedNode)) {\n    shadowDomRemovedCallback(removedNode.shadowRoot)\n  }\n  forEachChildNodes(removedNode, (childNode) => traverseRemovedShadowDom(childNode, shadowDomRemovedCallback))\n}\n", "export type ElementsScrollPositions = ReturnType<typeof createElementsScrollPositions>\nexport type ScrollPositions = { scrollLeft: number; scrollTop: number }\n\nexport function createElementsScrollPositions() {\n  const scrollPositionsByElement = new WeakMap<Element, ScrollPositions>()\n  return {\n    set(element: Element | Document, scrollPositions: ScrollPositions) {\n      if (element === document && !document.scrollingElement) {\n        // cf https://drafts.csswg.org/cssom-view/#dom-document-scrollingelement,\n        // in some cases scrolling elements can not be defined, we don't support those for now\n        return\n      }\n      scrollPositionsByElement.set(\n        element === document ? document.scrollingElement! : (element as Element),\n        scrollPositions\n      )\n    },\n    get(element: Element) {\n      return scrollPositionsByElement.get(element)\n    },\n    has(element: Element) {\n      return scrollPositionsByElement.has(element)\n    },\n  }\n}\n", "import type { RumConfiguration } from '@datadog/browser-rum-core'\nimport type { BrowserIncrementalSnapshotRecord } from '../../types'\nimport { trackInput, trackMutation, trackScroll } from './trackers'\nimport type { ElementsScrollPositions } from './elementsScrollPositions'\n\ninterface ShadowRootController {\n  stop: () => void\n  flush: () => void\n}\n\nexport type ShadowRootCallBack = (shadowRoot: ShadowRoot) => void\n\nexport interface ShadowRootsController {\n  addShadowRoot: ShadowRootCallBack\n  removeShadowRoot: ShadowRootCallBack\n  stop: () => void\n  flush: () => void\n}\n\nexport const initShadowRootsController = (\n  configuration: RumConfiguration,\n  callback: (record: BrowserIncrementalSnapshotRecord) => void,\n  elementsScrollPositions: ElementsScrollPositions\n): ShadowRootsController => {\n  const controllerByShadowRoot = new Map<ShadowRoot, ShadowRootController>()\n\n  const shadowRootsController: ShadowRootsController = {\n    addShadowRoot: (shadowRoot: ShadowRoot) => {\n      if (controllerByShadowRoot.has(shadowRoot)) {\n        return\n      }\n      const mutationTracker = trackMutation(callback, configuration, shadowRootsController, shadowRoot)\n      // The change event does not bubble up across the shadow root, we have to listen on the shadow root\n      const inputTracker = trackInput(configuration, callback, shadowRoot)\n      // The scroll event does not bubble up across the shadow root, we have to listen on the shadow root\n      const scrollTracker = trackScroll(configuration, callback, elementsScrollPositions, shadowRoot)\n      controllerByShadowRoot.set(shadowRoot, {\n        flush: () => mutationTracker.flush(),\n        stop: () => {\n          mutationTracker.stop()\n          inputTracker.stop()\n          scrollTracker.stop()\n        },\n      })\n    },\n    removeShadowRoot: (shadowRoot: ShadowRoot) => {\n      const entry = controllerByShadowRoot.get(shadowRoot)\n      if (!entry) {\n        // unidentified root cause: observed in some cases with shadow DOM added by browser extensions\n        return\n      }\n      entry.stop()\n      controllerByShadowRoot.delete(shadowRoot)\n    },\n    stop: () => {\n      controllerByShadowRoot.forEach(({ stop }) => stop())\n    },\n    flush: () => {\n      controllerByShadowRoot.forEach(({ flush }) => flush())\n    },\n  }\n  return shadowRootsController\n}\n", "import { LifeCycleEventType, getScrollX, getScrollY, getViewportDimension } from '@datadog/browser-rum-core'\nimport type { RumConfiguration, LifeCycle } from '@datadog/browser-rum-core'\nimport { timeStampNow } from '@datadog/browser-core'\nimport type { BrowserRecord } from '../../types'\nimport { RecordType } from '../../types'\nimport type { ElementsScrollPositions } from './elementsScrollPositions'\nimport type { ShadowRootsController } from './shadowRootsController'\nimport { SerializationContextStatus, serializeDocument } from './serialization'\nimport { getVisualViewport } from './viewports'\n\nexport function startFullSnapshots(\n  elementsScrollPositions: ElementsScrollPositions,\n  shadowRootsController: ShadowRootsController,\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  flushMutations: () => void,\n  fullSnapshotCallback: (records: BrowserRecord[]) => void\n) {\n  const takeFullSnapshot = (\n    timestamp = timeStampNow(),\n    serializationContext = {\n      status: SerializationContextStatus.INITIAL_FULL_SNAPSHOT,\n      elementsScrollPositions,\n      shadowRootsController,\n    }\n  ) => {\n    const { width, height } = getViewportDimension()\n    const records: BrowserRecord[] = [\n      {\n        data: {\n          height,\n          href: window.location.href,\n          width,\n        },\n        type: RecordType.Meta,\n        timestamp,\n      },\n      {\n        data: {\n          has_focus: document.hasFocus(),\n        },\n        type: RecordType.Focus,\n        timestamp,\n      },\n      {\n        data: {\n          node: serializeDocument(document, configuration, serializationContext),\n          initialOffset: {\n            left: getScrollX(),\n            top: getScrollY(),\n          },\n        },\n        type: RecordType.FullSnapshot,\n        timestamp,\n      },\n    ]\n\n    if (window.visualViewport) {\n      records.push({\n        data: getVisualViewport(window.visualViewport),\n        type: RecordType.VisualViewport,\n        timestamp,\n      })\n    }\n    return records\n  }\n\n  fullSnapshotCallback(takeFullSnapshot())\n\n  const { unsubscribe } = lifeCycle.subscribe(LifeCycleEventType.VIEW_CREATED, (view) => {\n    flushMutations()\n    fullSnapshotCallback(\n      takeFullSnapshot(view.startClocks.timeStamp, {\n        shadowRootsController,\n        status: SerializationContextStatus.SUBSEQUENT_FULL_SNAPSHOT,\n        elementsScrollPositions,\n      })\n    )\n  })\n\n  return {\n    stop: unsubscribe,\n  }\n}\n", "export type RecordIds = ReturnType<typeof initRecordIds>\n\nexport function initRecordIds() {\n  const recordIds = new WeakMap<Event, number>()\n  let nextId = 1\n\n  return {\n    getIdForEvent(event: Event): number {\n      if (!recordIds.has(event)) {\n        recordIds.set(event, nextId++)\n      }\n      return recordIds.get(event)!\n    },\n  }\n}\n", "import { sendToExtension } from '@datadog/browser-core'\nimport type { LifeCycle, RumConfiguration, ViewHistory } from '@datadog/browser-rum-core'\nimport type { BrowserRecord } from '../../types'\nimport * as replayStats from '../replayStats'\nimport type { Tracker } from './trackers'\nimport {\n  trackFocus,\n  trackFrustration,\n  trackInput,\n  trackMediaInteraction,\n  trackMouseInteraction,\n  trackMove,\n  trackMutation,\n  trackScroll,\n  trackStyleSheet,\n  trackViewEnd,\n  trackViewportResize,\n  trackVisualViewportResize,\n} from './trackers'\nimport { createElementsScrollPositions } from './elementsScrollPositions'\nimport type { ShadowRootsController } from './shadowRootsController'\nimport { initShadowRootsController } from './shadowRootsController'\nimport { startFullSnapshots } from './startFullSnapshots'\nimport { initRecordIds } from './recordIds'\n\nexport interface RecordOptions {\n  emit?: (record: BrowserRecord) => void\n  configuration: RumConfiguration\n  lifeCycle: LifeCycle\n  viewHistory: ViewHistory\n}\n\nexport interface RecordAPI {\n  stop: () => void\n  flushMutations: () => void\n  shadowRootsController: ShadowRootsController\n}\n\nexport function record(options: RecordOptions): RecordAPI {\n  const { emit, configuration, lifeCycle } = options\n  // runtime checks for user options\n  if (!emit) {\n    throw new Error('emit function is required')\n  }\n\n  const emitAndComputeStats = (record: BrowserRecord) => {\n    emit(record)\n    sendToExtension('record', { record })\n    const view = options.viewHistory.findView()!\n    replayStats.addRecord(view.id)\n  }\n\n  const elementsScrollPositions = createElementsScrollPositions()\n\n  const shadowRootsController = initShadowRootsController(configuration, emitAndComputeStats, elementsScrollPositions)\n\n  const { stop: stopFullSnapshots } = startFullSnapshots(\n    elementsScrollPositions,\n    shadowRootsController,\n    lifeCycle,\n    configuration,\n    flushMutations,\n    (records) => records.forEach((record) => emitAndComputeStats(record))\n  )\n\n  function flushMutations() {\n    shadowRootsController.flush()\n    mutationTracker.flush()\n  }\n\n  const recordIds = initRecordIds()\n  const mutationTracker = trackMutation(emitAndComputeStats, configuration, shadowRootsController, document)\n  const trackers: Tracker[] = [\n    mutationTracker,\n    trackMove(configuration, emitAndComputeStats),\n    trackMouseInteraction(configuration, emitAndComputeStats, recordIds),\n    trackScroll(configuration, emitAndComputeStats, elementsScrollPositions, document),\n    trackViewportResize(configuration, emitAndComputeStats),\n    trackInput(configuration, emitAndComputeStats),\n    trackMediaInteraction(configuration, emitAndComputeStats),\n    trackStyleSheet(emitAndComputeStats),\n    trackFocus(configuration, emitAndComputeStats),\n    trackVisualViewportResize(configuration, emitAndComputeStats),\n    trackFrustration(lifeCycle, emitAndComputeStats, recordIds),\n    trackViewEnd(lifeCycle, (viewEndRecord) => {\n      flushMutations()\n      emitAndComputeStats(viewEndRecord)\n    }),\n  ]\n\n  return {\n    stop: () => {\n      shadowRootsController.stop()\n      trackers.forEach((tracker) => tracker.stop())\n      stopFullSnapshots()\n    },\n    flushMutations,\n    shadowRootsController,\n  }\n}\n", "import type { Payload } from '@datadog/browser-core'\nimport type { BrowserSegmentMetadata } from '../../types'\n\nexport type BrowserSegmentMetadataAndSegmentSizes = BrowserSegmentMetadata & {\n  raw_segment_size: number\n  compressed_segment_size: number\n}\n\nexport function buildReplayPayload(\n  data: Uint8Array,\n  metadata: BrowserSegmentMetadata,\n  rawSegmentBytesCount: number\n): Payload {\n  const formData = new FormData()\n\n  formData.append(\n    'segment',\n    new Blob([data], {\n      type: 'application/octet-stream',\n    }),\n    `${metadata.session.id}-${metadata.start}`\n  )\n\n  const metadataAndSegmentSizes: BrowserSegmentMetadataAndSegmentSizes = {\n    raw_segment_size: rawSegmentBytesCount,\n    compressed_segment_size: data.byteLength,\n    ...metadata,\n  }\n\n  const serializedMetadataAndSegmentSizes = JSON.stringify(metadataAndSegmentSizes)\n  formData.append('event', new Blob([serializedMetadataAndSegmentSizes], { type: 'application/json' }))\n\n  return { data: formData, bytesCount: data.byteLength }\n}\n", "import type { Encoder, EncoderResult } from '@datadog/browser-core'\nimport type { BrowserRecord, BrowserSegmentMetadata, CreationReason, SegmentContext } from '../../types'\nimport { RecordType } from '../../types'\nimport * as replayStats from '../replayStats'\n\nexport type FlushReason = Exclude<CreationReason, 'init'> | 'stop'\nexport type FlushCallback = (metadata: BrowserSegmentMetadata, encoderResult: EncoderResult<Uint8Array>) => void\nexport type AddRecordCallback = (encodedBytesCount: number) => void\n\nexport interface Segment {\n  addRecord: (record: BrowserRecord, callback: AddRecordCallback) => void\n  flush: (callback: FlushCallback) => void\n}\n\nexport function createSegment({\n  context,\n  creationReason,\n  encoder,\n}: {\n  context: SegmentContext\n  creationReason: CreationReason\n  encoder: Encoder<Uint8Array>\n}): Segment {\n  let encodedBytesCount = 0\n  const viewId = context.view.id\n  const metadata: BrowserSegmentMetadata = {\n    start: Infinity,\n    end: -Infinity,\n    creation_reason: creationReason,\n    records_count: 0,\n    has_full_snapshot: false,\n    index_in_view: replayStats.getSegmentsCount(viewId),\n    source: 'browser' as const,\n    ...context,\n  }\n\n  replayStats.addSegment(viewId)\n\n  function addRecord(record: BrowserRecord, callback: AddRecordCallback): void {\n    metadata.start = Math.min(metadata.start, record.timestamp)\n    metadata.end = Math.max(metadata.end, record.timestamp)\n    metadata.records_count += 1\n    metadata.has_full_snapshot ||= record.type === RecordType.FullSnapshot\n\n    const prefix = encoder.isEmpty ? '{\"records\":[' : ','\n    encoder.write(prefix + JSON.stringify(record), (additionalEncodedBytesCount) => {\n      encodedBytesCount += additionalEncodedBytesCount\n      callback(encodedBytesCount)\n    })\n  }\n\n  function flush(callback: FlushCallback) {\n    if (encoder.isEmpty) {\n      throw new Error('Empty segment flushed')\n    }\n\n    encoder.write(`],${JSON.stringify(metadata).slice(1)}\\n`)\n    encoder.finish((encoderResult) => {\n      replayStats.addWroteData(metadata.view.id, encoderResult.rawBytesCount)\n      callback(metadata, encoderResult)\n    })\n  }\n\n  return { addRecord, flush }\n}\n", "import type { DeflateEncoder, HttpRequest, TimeoutId } from '@datadog/browser-core'\nimport { isPageExitReason, ONE_SECOND, clearTimeout, setTimeout } from '@datadog/browser-core'\nimport type { LifeCycle, ViewHistory, RumSessionManager, RumConfiguration } from '@datadog/browser-rum-core'\nimport { LifeCycleEventType } from '@datadog/browser-rum-core'\nimport type { BrowserRecord, CreationReason, SegmentContext } from '../../types'\nimport { buildReplayPayload } from './buildReplayPayload'\nimport type { FlushReason, Segment } from './segment'\nimport { createSegment } from './segment'\n\nexport const SEGMENT_DURATION_LIMIT = 5 * ONE_SECOND\n/**\n * beacon payload max queue size implementation is 64kb\n * ensure that we leave room for logs, rum and potential other users\n */\nexport let SEGMENT_BYTES_LIMIT = 60_000\n\n// Segments are the main data structure for session replays. They contain context information used\n// for indexing or UI needs, and a list of records (RRWeb 'events', renamed to avoid confusing\n// namings). They are stored without any processing from the intake, and fetched one after the\n// other while a session is being replayed. Their encoding (deflate) are carefully crafted to allow\n// concatenating multiple segments together. Segments have a size overhead (metadata), so our goal is to\n// build segments containing as many records as possible while complying with the various flush\n// strategies to guarantee a good replay quality.\n//\n// When the recording starts, a segment is initially created.  The segment is flushed (finalized and\n// sent) based on various events (non-exhaustive list):\n//\n// * the page visibility change or becomes to unload\n// * the segment duration reaches a limit\n// * the encoded segment bytes count reaches a limit\n// * ...\n//\n// A segment cannot be created without its context.  If the RUM session ends and no session id is\n// available when creating a new segment, records will be ignored, until the session is renewed and\n// a new session id is available.\n//\n// Empty segments (segments with no record) aren't useful and should be ignored.\n//\n// To help investigate session replays issues, each segment is created with a \"creation reason\",\n// indicating why the session has been created.\n\nexport function startSegmentCollection(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  sessionManager: RumSessionManager,\n  viewHistory: ViewHistory,\n  httpRequest: HttpRequest,\n  encoder: DeflateEncoder\n) {\n  return doStartSegmentCollection(\n    lifeCycle,\n    () => computeSegmentContext(configuration.applicationId, sessionManager, viewHistory),\n    httpRequest,\n    encoder\n  )\n}\n\nconst enum SegmentCollectionStatus {\n  WaitingForInitialRecord,\n  SegmentPending,\n  Stopped,\n}\ntype SegmentCollectionState =\n  | {\n      status: SegmentCollectionStatus.WaitingForInitialRecord\n      nextSegmentCreationReason: CreationReason\n    }\n  | {\n      status: SegmentCollectionStatus.SegmentPending\n      segment: Segment\n      expirationTimeoutId: TimeoutId\n    }\n  | {\n      status: SegmentCollectionStatus.Stopped\n    }\n\nexport function doStartSegmentCollection(\n  lifeCycle: LifeCycle,\n  getSegmentContext: () => SegmentContext | undefined,\n  httpRequest: HttpRequest,\n  encoder: DeflateEncoder\n) {\n  let state: SegmentCollectionState = {\n    status: SegmentCollectionStatus.WaitingForInitialRecord,\n    nextSegmentCreationReason: 'init',\n  }\n\n  const { unsubscribe: unsubscribeViewCreated } = lifeCycle.subscribe(LifeCycleEventType.VIEW_CREATED, () => {\n    flushSegment('view_change')\n  })\n\n  const { unsubscribe: unsubscribePageMayExit } = lifeCycle.subscribe(\n    LifeCycleEventType.PAGE_MAY_EXIT,\n    (pageMayExitEvent) => {\n      flushSegment(pageMayExitEvent.reason as FlushReason)\n    }\n  )\n\n  function flushSegment(flushReason: FlushReason) {\n    if (state.status === SegmentCollectionStatus.SegmentPending) {\n      state.segment.flush((metadata, encoderResult) => {\n        const payload = buildReplayPayload(encoderResult.output, metadata, encoderResult.rawBytesCount)\n\n        if (isPageExitReason(flushReason)) {\n          httpRequest.sendOnExit(payload)\n        } else {\n          httpRequest.send(payload)\n        }\n      })\n      clearTimeout(state.expirationTimeoutId)\n    }\n\n    if (flushReason !== 'stop') {\n      state = {\n        status: SegmentCollectionStatus.WaitingForInitialRecord,\n        nextSegmentCreationReason: flushReason,\n      }\n    } else {\n      state = {\n        status: SegmentCollectionStatus.Stopped,\n      }\n    }\n  }\n\n  return {\n    addRecord: (record: BrowserRecord) => {\n      if (state.status === SegmentCollectionStatus.Stopped) {\n        return\n      }\n\n      if (state.status === SegmentCollectionStatus.WaitingForInitialRecord) {\n        const context = getSegmentContext()\n        if (!context) {\n          return\n        }\n\n        state = {\n          status: SegmentCollectionStatus.SegmentPending,\n          segment: createSegment({ encoder, context, creationReason: state.nextSegmentCreationReason }),\n          expirationTimeoutId: setTimeout(() => {\n            flushSegment('segment_duration_limit')\n          }, SEGMENT_DURATION_LIMIT),\n        }\n      }\n\n      state.segment.addRecord(record, (encodedBytesCount) => {\n        if (encodedBytesCount > SEGMENT_BYTES_LIMIT) {\n          flushSegment('segment_bytes_limit')\n        }\n      })\n    },\n\n    stop: () => {\n      flushSegment('stop')\n      unsubscribeViewCreated()\n      unsubscribePageMayExit()\n    },\n  }\n}\n\nexport function computeSegmentContext(\n  applicationId: string,\n  sessionManager: RumSessionManager,\n  viewHistory: ViewHistory\n) {\n  const session = sessionManager.findTrackedSession()\n  const viewContext = viewHistory.findView()\n  if (!session || !viewContext) {\n    return undefined\n  }\n  return {\n    application: {\n      id: applicationId,\n    },\n    session: {\n      id: session.id,\n    },\n    view: {\n      id: viewContext.id,\n    },\n  }\n}\n\nexport function setSegmentBytesLimit(newSegmentBytesLimit = 60_000) {\n  SEGMENT_BYTES_LIMIT = newSegmentBytesLimit\n}\n", "import { getEventBridge } from '@datadog/browser-core'\nimport type { ViewHistory } from '@datadog/browser-rum-core'\nimport type { BrowserRecord } from '../types'\n\nexport function startRecordBridge(viewHistory: ViewHistory) {\n  const bridge = getEventBridge<'record', BrowserRecord>()!\n\n  return {\n    addRecord: (record: BrowserRecord) => {\n      // Get the current active view, not at the time of the record, aligning with the segment logic.\n      // This approach could potentially associate the record to an incorrect view, in case the record date is in the past (e.g. frustration records).\n      // However the risk is minimal. We could address the issue when potential negative impact are identified.\n      const view = viewHistory.findView()!\n      bridge.send('record', record, view.id)\n    },\n  }\n}\n", "import type { RawError, HttpRequest, DeflateEncoder } from '@datadog/browser-core'\nimport { createHttpRequest, addTelemetryDebug, canUseEventBridge } from '@datadog/browser-core'\nimport type { LifeCycle, ViewHistory, RumConfiguration, RumSessionManager } from '@datadog/browser-rum-core'\nimport { LifeCycleEventType } from '@datadog/browser-rum-core'\n\nimport { record } from '../domain/record'\nimport { startSegmentCollection, SEGMENT_BYTES_LIMIT } from '../domain/segmentCollection'\nimport type { BrowserRecord } from '../types'\nimport { startRecordBridge } from '../domain/startRecordBridge'\n\nexport function startRecording(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  sessionManager: RumSessionManager,\n  viewHistory: ViewHistory,\n  encoder: DeflateEncoder,\n  httpRequest?: HttpRequest\n) {\n  const cleanupTasks: Array<() => void> = []\n\n  const reportError = (error: RawError) => {\n    lifeCycle.notify(LifeCycleEventType.RAW_ERROR_COLLECTED, { error })\n    addTelemetryDebug('Error reported to customer', { 'error.message': error.message })\n  }\n\n  const replayRequest =\n    httpRequest || createHttpRequest(configuration.sessionReplayEndpointBuilder, SEGMENT_BYTES_LIMIT, reportError)\n\n  let addRecord: (record: BrowserRecord) => void\n\n  if (!canUseEventBridge()) {\n    const segmentCollection = startSegmentCollection(\n      lifeCycle,\n      configuration,\n      sessionManager,\n      viewHistory,\n      replayRequest,\n      encoder\n    )\n    addRecord = segmentCollection.addRecord\n    cleanupTasks.push(segmentCollection.stop)\n  } else {\n    ;({ addRecord } = startRecordBridge(viewHistory))\n  }\n\n  const { stop: stopRecording } = record({\n    emit: addRecord,\n    configuration,\n    lifeCycle,\n    viewHistory,\n  })\n  cleanupTasks.push(stopRecording)\n\n  return {\n    stop: () => {\n      cleanupTasks.forEach((task) => task())\n    },\n  }\n}\n"],
  "mappings": "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",
  "names": ["document", "document", "record", "target", "rules", "index", "target", "serializedNodeIds", "record", "addRecord", "record", "record", "record", "addRecord"]
}
