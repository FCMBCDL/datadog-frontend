import {
  addRecord,
  addSegment,
  addWroteData,
  getSegmentsCount
} from "./chunk-4JSLHPQL.js";
import {
  CENSORED_IMG_MARK,
  CENSORED_STRING_MARK,
  NodePrivacyLevel,
  PRIVACY_ATTR_NAME,
  PRIVACY_ATTR_VALUE_HIDDEN,
  STABLE_ATTRIBUTES,
  forEachChildNodes,
  getMutationObserverConstructor,
  getNodePrivacyLevel,
  getNodeSelfPrivacyLevel,
  getParentNode,
  getScrollX,
  getScrollY,
  getTextContent,
  getViewportDimension,
  hasChildNodes,
  initViewportObservable,
  isNodeShadowHost,
  isNodeShadowRoot,
  reducePrivacyLevel,
  sanitizeIfLongDataUrl,
  shouldMaskNode
} from "./chunk-ATFHSDKA.js";
import {
  ONE_SECOND,
  addEventListener,
  addEventListeners,
  addTelemetryDebug,
  buildUrl,
  canUseEventBridge,
  clearTimeout,
  createHttpRequest,
  getEventBridge,
  instrumentMethod,
  instrumentSetter,
  isPageExitReason,
  isSafari,
  monitor,
  noop,
  requestIdleCallback,
  sendToExtension,
  setTimeout,
  throttle,
  timeStampNow
} from "./chunk-Z3Q3XVIP.js";
import "./chunk-5WRI5ZAA.js";

// node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializationUtils.js
var serializedNodeIds = /* @__PURE__ */ new WeakMap();
function hasSerializedNode(node) {
  return serializedNodeIds.has(node);
}
function nodeAndAncestorsHaveSerializedNode(node) {
  let current = node;
  while (current) {
    if (!hasSerializedNode(current) && !isNodeShadowRoot(current)) {
      return false;
    }
    current = getParentNode(current);
  }
  return true;
}
function getSerializedNodeId(node) {
  return serializedNodeIds.get(node);
}
function setSerializedNodeId(node, serializeNodeId) {
  serializedNodeIds.set(node, serializeNodeId);
}
function getElementInputValue(element, nodePrivacyLevel) {
  const tagName = element.tagName;
  const value = element.value;
  if (shouldMaskNode(element, nodePrivacyLevel)) {
    const type = element.type;
    if (tagName === "INPUT" && (type === "button" || type === "submit" || type === "reset")) {
      return value;
    } else if (!value || tagName === "OPTION") {
      return;
    }
    return CENSORED_STRING_MARK;
  }
  if (tagName === "OPTION" || tagName === "SELECT") {
    return element.value;
  }
  if (tagName !== "INPUT" && tagName !== "TEXTAREA") {
    return;
  }
  return value;
}
var URL_IN_CSS_REF = /url\((?:(')([^']*)'|(")([^"]*)"|([^)]*))\)/gm;
var ABSOLUTE_URL = /^[A-Za-z]+:|^\/\//;
var DATA_URI = /^["']?data:.*,/i;
function switchToAbsoluteUrl(cssText, cssHref) {
  return cssText.replace(URL_IN_CSS_REF, (matchingSubstring, singleQuote, urlWrappedInSingleQuotes, doubleQuote, urlWrappedInDoubleQuotes, urlNotWrappedInQuotes) => {
    const url = urlWrappedInSingleQuotes || urlWrappedInDoubleQuotes || urlNotWrappedInQuotes;
    if (!cssHref || !url || ABSOLUTE_URL.test(url) || DATA_URI.test(url)) {
      return matchingSubstring;
    }
    const quote = singleQuote || doubleQuote || "";
    return `url(${quote}${makeUrlAbsolute(url, cssHref)}${quote})`;
  });
}
function makeUrlAbsolute(url, baseUrl) {
  try {
    return buildUrl(url, baseUrl).href;
  } catch (_a) {
    return url;
  }
}
var TAG_NAME_REGEX = /[^a-z1-6-_]/;
function getValidTagName(tagName) {
  const processedTagName = tagName.toLowerCase().trim();
  if (TAG_NAME_REGEX.test(processedTagName)) {
    return "div";
  }
  return processedTagName;
}
function censoredImageForSize(width, height) {
  return `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='${width}' height='${height}' style='background-color:silver'%3E%3C/svg%3E`;
}

// node_modules/@datadog/browser-rum/esm/types/sessionReplayConstants.js
var RecordType = {
  FullSnapshot: 2,
  IncrementalSnapshot: 3,
  Meta: 4,
  Focus: 6,
  ViewEnd: 7,
  VisualViewport: 8,
  FrustrationRecord: 9
};
var NodeType = {
  Document: 0,
  DocumentType: 1,
  Element: 2,
  Text: 3,
  CDATA: 4,
  DocumentFragment: 11
};
var IncrementalSource = {
  Mutation: 0,
  MouseMove: 1,
  MouseInteraction: 2,
  Scroll: 3,
  ViewportResize: 4,
  Input: 5,
  TouchMove: 6,
  MediaInteraction: 7,
  StyleSheetRule: 8
  // CanvasMutation : 9,
  // Font : 10,
};
var MouseInteractionType = {
  MouseUp: 0,
  MouseDown: 1,
  Click: 2,
  ContextMenu: 3,
  DblClick: 4,
  Focus: 5,
  Blur: 6,
  TouchStart: 7,
  TouchEnd: 9
};
var MediaInteractionType = {
  Play: 0,
  Pause: 1
};

// node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializeStyleSheets.js
function serializeStyleSheets(cssStyleSheets) {
  if (cssStyleSheets === void 0 || cssStyleSheets.length === 0) {
    return void 0;
  }
  return cssStyleSheets.map((cssStyleSheet) => {
    const rules = cssStyleSheet.cssRules || cssStyleSheet.rules;
    const cssRules = Array.from(rules, (cssRule) => cssRule.cssText);
    const styleSheet = {
      cssRules,
      disabled: cssStyleSheet.disabled || void 0,
      media: cssStyleSheet.media.length > 0 ? Array.from(cssStyleSheet.media) : void 0
    };
    return styleSheet;
  });
}

// node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializeAttribute.js
var MAX_ATTRIBUTE_VALUE_CHAR_LENGTH = 1e6;
function serializeAttribute(element, nodePrivacyLevel, attributeName, configuration) {
  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {
    return null;
  }
  const attributeValue = element.getAttribute(attributeName);
  if (nodePrivacyLevel === NodePrivacyLevel.MASK && attributeName !== PRIVACY_ATTR_NAME && !STABLE_ATTRIBUTES.includes(attributeName) && attributeName !== configuration.actionNameAttribute) {
    const tagName = element.tagName;
    switch (attributeName) {
      // Mask Attribute text content
      case "title":
      case "alt":
      case "placeholder":
        return CENSORED_STRING_MARK;
    }
    if (tagName === "IMG" && (attributeName === "src" || attributeName === "srcset")) {
      const image = element;
      if (image.naturalWidth > 0) {
        return censoredImageForSize(image.naturalWidth, image.naturalHeight);
      }
      const { width, height } = element.getBoundingClientRect();
      if (width > 0 || height > 0) {
        return censoredImageForSize(width, height);
      }
      return CENSORED_IMG_MARK;
    }
    if (tagName === "SOURCE" && (attributeName === "src" || attributeName === "srcset")) {
      return CENSORED_IMG_MARK;
    }
    if (tagName === "A" && attributeName === "href") {
      return CENSORED_STRING_MARK;
    }
    if (attributeValue && attributeName.startsWith("data-")) {
      return CENSORED_STRING_MARK;
    }
    if (tagName === "IFRAME" && attributeName === "srcdoc") {
      return CENSORED_STRING_MARK;
    }
  }
  if (!attributeValue || typeof attributeValue !== "string") {
    return attributeValue;
  }
  return sanitizeIfLongDataUrl(attributeValue, MAX_ATTRIBUTE_VALUE_CHAR_LENGTH);
}

// node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializeAttributes.js
function serializeAttributes(element, nodePrivacyLevel, options) {
  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {
    return {};
  }
  const safeAttrs = {};
  const tagName = getValidTagName(element.tagName);
  const doc = element.ownerDocument;
  for (let i = 0; i < element.attributes.length; i += 1) {
    const attribute = element.attributes.item(i);
    const attributeName = attribute.name;
    const attributeValue = serializeAttribute(element, nodePrivacyLevel, attributeName, options.configuration);
    if (attributeValue !== null) {
      safeAttrs[attributeName] = attributeValue;
    }
  }
  if (element.value && (tagName === "textarea" || tagName === "select" || tagName === "option" || tagName === "input")) {
    const formValue = getElementInputValue(element, nodePrivacyLevel);
    if (formValue !== void 0) {
      safeAttrs.value = formValue;
    }
  }
  if (tagName === "option" && nodePrivacyLevel === NodePrivacyLevel.ALLOW) {
    const optionElement = element;
    if (optionElement.selected) {
      safeAttrs.selected = optionElement.selected;
    }
  }
  if (tagName === "link") {
    const stylesheet = Array.from(doc.styleSheets).find((s) => s.href === element.href);
    const cssText = getCssRulesString(stylesheet);
    if (cssText && stylesheet) {
      safeAttrs._cssText = cssText;
    }
  }
  if (tagName === "style" && element.sheet) {
    const cssText = getCssRulesString(element.sheet);
    if (cssText) {
      safeAttrs._cssText = cssText;
    }
  }
  const inputElement = element;
  if (tagName === "input" && (inputElement.type === "radio" || inputElement.type === "checkbox")) {
    if (nodePrivacyLevel === NodePrivacyLevel.ALLOW) {
      safeAttrs.checked = !!inputElement.checked;
    } else if (shouldMaskNode(inputElement, nodePrivacyLevel)) {
      delete safeAttrs.checked;
    }
  }
  if (tagName === "audio" || tagName === "video") {
    const mediaElement = element;
    safeAttrs.rr_mediaState = mediaElement.paused ? "paused" : "played";
  }
  let scrollTop;
  let scrollLeft;
  const serializationContext = options.serializationContext;
  switch (serializationContext.status) {
    case 0:
      scrollTop = Math.round(element.scrollTop);
      scrollLeft = Math.round(element.scrollLeft);
      if (scrollTop || scrollLeft) {
        serializationContext.elementsScrollPositions.set(element, { scrollTop, scrollLeft });
      }
      break;
    case 1:
      if (serializationContext.elementsScrollPositions.has(element)) {
        ;
        ({ scrollTop, scrollLeft } = serializationContext.elementsScrollPositions.get(element));
      }
      break;
  }
  if (scrollLeft) {
    safeAttrs.rr_scrollLeft = scrollLeft;
  }
  if (scrollTop) {
    safeAttrs.rr_scrollTop = scrollTop;
  }
  return safeAttrs;
}
function getCssRulesString(cssStyleSheet) {
  if (!cssStyleSheet) {
    return null;
  }
  let rules;
  try {
    rules = cssStyleSheet.rules || cssStyleSheet.cssRules;
  } catch (_a) {
  }
  if (!rules) {
    return null;
  }
  const styleSheetCssText = Array.from(rules, isSafari() ? getCssRuleStringForSafari : getCssRuleString).join("");
  return switchToAbsoluteUrl(styleSheetCssText, cssStyleSheet.href);
}
function getCssRuleStringForSafari(rule) {
  if (isCSSStyleRule(rule) && rule.selectorText.includes(":")) {
    const escapeColon = /(\[[\w-]+[^\\])(:[^\]]+\])/g;
    return rule.cssText.replace(escapeColon, "$1\\$2");
  }
  return getCssRuleString(rule);
}
function getCssRuleString(rule) {
  return isCSSImportRule(rule) && getCssRulesString(rule.styleSheet) || rule.cssText;
}
function isCSSImportRule(rule) {
  return "styleSheet" in rule;
}
function isCSSStyleRule(rule) {
  return "selectorText" in rule;
}

// node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializeNode.js
function serializeNodeWithId(node, options) {
  const serializedNode = serializeNode(node, options);
  if (!serializedNode) {
    return null;
  }
  const id = getSerializedNodeId(node) || generateNextId();
  const serializedNodeWithId = serializedNode;
  serializedNodeWithId.id = id;
  setSerializedNodeId(node, id);
  if (options.serializedNodeIds) {
    options.serializedNodeIds.add(id);
  }
  return serializedNodeWithId;
}
var _nextId = 1;
function generateNextId() {
  return _nextId++;
}
function serializeChildNodes(node, options) {
  const result = [];
  forEachChildNodes(node, (childNode) => {
    const serializedChildNode = serializeNodeWithId(childNode, options);
    if (serializedChildNode) {
      result.push(serializedChildNode);
    }
  });
  return result;
}
function serializeNode(node, options) {
  switch (node.nodeType) {
    case node.DOCUMENT_NODE:
      return serializeDocumentNode(node, options);
    case node.DOCUMENT_FRAGMENT_NODE:
      return serializeDocumentFragmentNode(node, options);
    case node.DOCUMENT_TYPE_NODE:
      return serializeDocumentTypeNode(node);
    case node.ELEMENT_NODE:
      return serializeElementNode(node, options);
    case node.TEXT_NODE:
      return serializeTextNode(node, options);
    case node.CDATA_SECTION_NODE:
      return serializeCDataNode();
  }
}
function serializeDocumentNode(document2, options) {
  return {
    type: NodeType.Document,
    childNodes: serializeChildNodes(document2, options),
    adoptedStyleSheets: serializeStyleSheets(document2.adoptedStyleSheets)
  };
}
function serializeDocumentFragmentNode(element, options) {
  const isShadowRoot = isNodeShadowRoot(element);
  if (isShadowRoot) {
    options.serializationContext.shadowRootsController.addShadowRoot(element);
  }
  return {
    type: NodeType.DocumentFragment,
    childNodes: serializeChildNodes(element, options),
    isShadowRoot,
    adoptedStyleSheets: isShadowRoot ? serializeStyleSheets(element.adoptedStyleSheets) : void 0
  };
}
function serializeDocumentTypeNode(documentType) {
  return {
    type: NodeType.DocumentType,
    name: documentType.name,
    publicId: documentType.publicId,
    systemId: documentType.systemId
  };
}
function serializeElementNode(element, options) {
  const tagName = getValidTagName(element.tagName);
  const isSVG = isSVGElement(element) || void 0;
  const nodePrivacyLevel = reducePrivacyLevel(getNodeSelfPrivacyLevel(element), options.parentNodePrivacyLevel);
  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {
    const { width, height } = element.getBoundingClientRect();
    return {
      type: NodeType.Element,
      tagName,
      attributes: {
        rr_width: `${width}px`,
        rr_height: `${height}px`,
        [PRIVACY_ATTR_NAME]: PRIVACY_ATTR_VALUE_HIDDEN
      },
      childNodes: [],
      isSVG
    };
  }
  if (nodePrivacyLevel === NodePrivacyLevel.IGNORE) {
    return;
  }
  const attributes = serializeAttributes(element, nodePrivacyLevel, options);
  let childNodes = [];
  if (hasChildNodes(element) && // Do not serialize style children as the css rules are already in the _cssText attribute
  tagName !== "style") {
    let childNodesSerializationOptions;
    if (options.parentNodePrivacyLevel === nodePrivacyLevel && options.ignoreWhiteSpace === (tagName === "head")) {
      childNodesSerializationOptions = options;
    } else {
      childNodesSerializationOptions = {
        ...options,
        parentNodePrivacyLevel: nodePrivacyLevel,
        ignoreWhiteSpace: tagName === "head"
      };
    }
    childNodes = serializeChildNodes(element, childNodesSerializationOptions);
  }
  return {
    type: NodeType.Element,
    tagName,
    attributes,
    childNodes,
    isSVG
  };
}
function isSVGElement(el) {
  return el.tagName === "svg" || el instanceof SVGElement;
}
function serializeTextNode(textNode, options) {
  const textContent = getTextContent(textNode, options.ignoreWhiteSpace || false, options.parentNodePrivacyLevel);
  if (textContent === void 0) {
    return;
  }
  return {
    type: NodeType.Text,
    textContent
  };
}
function serializeCDataNode() {
  return {
    type: NodeType.CDATA,
    textContent: ""
  };
}

// node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializeDocument.js
function serializeDocument(document2, configuration, serializationContext) {
  return serializeNodeWithId(document2, {
    serializationContext,
    parentNodePrivacyLevel: configuration.defaultPrivacyLevel,
    configuration
  });
}

// node_modules/@datadog/browser-rum/esm/domain/record/eventsUtils.js
function isTouchEvent(event) {
  return Boolean(event.changedTouches);
}
function getEventTarget(event) {
  if (event.composed === true && isNodeShadowHost(event.target)) {
    return event.composedPath()[0];
  }
  return event.target;
}

// node_modules/@datadog/browser-rum/esm/domain/record/viewports.js
var TOLERANCE = 25;
function isVisualViewportFactoredIn(visualViewport) {
  return Math.abs(visualViewport.pageTop - visualViewport.offsetTop - window.scrollY) > TOLERANCE || Math.abs(visualViewport.pageLeft - visualViewport.offsetLeft - window.scrollX) > TOLERANCE;
}
var convertMouseEventToLayoutCoordinates = (clientX, clientY) => {
  const visualViewport = window.visualViewport;
  const normalized = {
    layoutViewportX: clientX,
    layoutViewportY: clientY,
    visualViewportX: clientX,
    visualViewportY: clientY
  };
  if (!visualViewport) {
    return normalized;
  } else if (isVisualViewportFactoredIn(visualViewport)) {
    normalized.layoutViewportX = Math.round(clientX + visualViewport.offsetLeft);
    normalized.layoutViewportY = Math.round(clientY + visualViewport.offsetTop);
  } else {
    normalized.visualViewportX = Math.round(clientX - visualViewport.offsetLeft);
    normalized.visualViewportY = Math.round(clientY - visualViewport.offsetTop);
  }
  return normalized;
};
var getVisualViewport = (visualViewport) => ({
  scale: visualViewport.scale,
  offsetLeft: visualViewport.offsetLeft,
  offsetTop: visualViewport.offsetTop,
  pageLeft: visualViewport.pageLeft,
  pageTop: visualViewport.pageTop,
  height: visualViewport.height,
  width: visualViewport.width
});

// node_modules/@datadog/browser-rum/esm/domain/record/assembly.js
function assembleIncrementalSnapshot(source, data) {
  return {
    data: {
      source,
      ...data
    },
    type: RecordType.IncrementalSnapshot,
    timestamp: timeStampNow()
  };
}

// node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackMove.js
var MOUSE_MOVE_OBSERVER_THRESHOLD = 50;
function trackMove(configuration, moveCb) {
  const { throttled: updatePosition, cancel: cancelThrottle } = throttle((event) => {
    const target = getEventTarget(event);
    if (hasSerializedNode(target)) {
      const coordinates = tryToComputeCoordinates(event);
      if (!coordinates) {
        return;
      }
      const position = {
        id: getSerializedNodeId(target),
        timeOffset: 0,
        x: coordinates.x,
        y: coordinates.y
      };
      moveCb(assembleIncrementalSnapshot(isTouchEvent(event) ? IncrementalSource.TouchMove : IncrementalSource.MouseMove, { positions: [position] }));
    }
  }, MOUSE_MOVE_OBSERVER_THRESHOLD, {
    trailing: false
  });
  const { stop: removeListener } = addEventListeners(configuration, document, [
    "mousemove",
    "touchmove"
    /* DOM_EVENT.TOUCH_MOVE */
  ], updatePosition, {
    capture: true,
    passive: true
  });
  return {
    stop: () => {
      removeListener();
      cancelThrottle();
    }
  };
}
function tryToComputeCoordinates(event) {
  let { clientX: x, clientY: y } = isTouchEvent(event) ? event.changedTouches[0] : event;
  if (window.visualViewport) {
    const { visualViewportX, visualViewportY } = convertMouseEventToLayoutCoordinates(x, y);
    x = visualViewportX;
    y = visualViewportY;
  }
  if (!Number.isFinite(x) || !Number.isFinite(y)) {
    if (event.isTrusted) {
      addTelemetryDebug("mouse/touch event without x/y");
    }
    return void 0;
  }
  return { x, y };
}

// node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackMouseInteraction.js
var eventTypeToMouseInteraction = {
  // Listen for pointerup DOM events instead of mouseup for MouseInteraction/MouseUp records. This
  // allows to reference such records from Frustration records.
  //
  // In the context of supporting Mobile Session Replay, we introduced `PointerInteraction` records
  // used by the Mobile SDKs in place of `MouseInteraction`. In the future, we should replace
  // `MouseInteraction` by `PointerInteraction` in the Browser SDK so we have an uniform way to
  // convey such interaction. This would cleanly solve the issue since we would have
  // `PointerInteraction/Up` records that we could reference from `Frustration` records.
  [
    "pointerup"
    /* DOM_EVENT.POINTER_UP */
  ]: MouseInteractionType.MouseUp,
  [
    "mousedown"
    /* DOM_EVENT.MOUSE_DOWN */
  ]: MouseInteractionType.MouseDown,
  [
    "click"
    /* DOM_EVENT.CLICK */
  ]: MouseInteractionType.Click,
  [
    "contextmenu"
    /* DOM_EVENT.CONTEXT_MENU */
  ]: MouseInteractionType.ContextMenu,
  [
    "dblclick"
    /* DOM_EVENT.DBL_CLICK */
  ]: MouseInteractionType.DblClick,
  [
    "focus"
    /* DOM_EVENT.FOCUS */
  ]: MouseInteractionType.Focus,
  [
    "blur"
    /* DOM_EVENT.BLUR */
  ]: MouseInteractionType.Blur,
  [
    "touchstart"
    /* DOM_EVENT.TOUCH_START */
  ]: MouseInteractionType.TouchStart,
  [
    "touchend"
    /* DOM_EVENT.TOUCH_END */
  ]: MouseInteractionType.TouchEnd
};
function trackMouseInteraction(configuration, mouseInteractionCb, recordIds) {
  const handler = (event) => {
    const target = getEventTarget(event);
    if (getNodePrivacyLevel(target, configuration.defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN || !hasSerializedNode(target)) {
      return;
    }
    const id = getSerializedNodeId(target);
    const type = eventTypeToMouseInteraction[event.type];
    let interaction;
    if (type !== MouseInteractionType.Blur && type !== MouseInteractionType.Focus) {
      const coordinates = tryToComputeCoordinates(event);
      if (!coordinates) {
        return;
      }
      interaction = { id, type, x: coordinates.x, y: coordinates.y };
    } else {
      interaction = { id, type };
    }
    const record2 = {
      id: recordIds.getIdForEvent(event),
      ...assembleIncrementalSnapshot(IncrementalSource.MouseInteraction, interaction)
    };
    mouseInteractionCb(record2);
  };
  return addEventListeners(configuration, document, Object.keys(eventTypeToMouseInteraction), handler, {
    capture: true,
    passive: true
  });
}

// node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackScroll.js
var SCROLL_OBSERVER_THRESHOLD = 100;
function trackScroll(configuration, scrollCb, elementsScrollPositions, target = document) {
  const { throttled: updatePosition, cancel: cancelThrottle } = throttle((event) => {
    const target2 = getEventTarget(event);
    if (!target2 || getNodePrivacyLevel(target2, configuration.defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN || !hasSerializedNode(target2)) {
      return;
    }
    const id = getSerializedNodeId(target2);
    const scrollPositions = target2 === document ? {
      scrollTop: getScrollY(),
      scrollLeft: getScrollX()
    } : {
      scrollTop: Math.round(target2.scrollTop),
      scrollLeft: Math.round(target2.scrollLeft)
    };
    elementsScrollPositions.set(target2, scrollPositions);
    scrollCb(assembleIncrementalSnapshot(IncrementalSource.Scroll, {
      id,
      x: scrollPositions.scrollLeft,
      y: scrollPositions.scrollTop
    }));
  }, SCROLL_OBSERVER_THRESHOLD);
  const { stop: removeListener } = addEventListener(configuration, target, "scroll", updatePosition, {
    capture: true,
    passive: true
  });
  return {
    stop: () => {
      removeListener();
      cancelThrottle();
    }
  };
}

// node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackViewportResize.js
var VISUAL_VIEWPORT_OBSERVER_THRESHOLD = 200;
function trackViewportResize(configuration, viewportResizeCb) {
  const viewportResizeSubscription = initViewportObservable(configuration).subscribe((data) => {
    viewportResizeCb(assembleIncrementalSnapshot(IncrementalSource.ViewportResize, data));
  });
  return {
    stop: () => {
      viewportResizeSubscription.unsubscribe();
    }
  };
}
function trackVisualViewportResize(configuration, visualViewportResizeCb) {
  const visualViewport = window.visualViewport;
  if (!visualViewport) {
    return { stop: noop };
  }
  const { throttled: updateDimension, cancel: cancelThrottle } = throttle(() => {
    visualViewportResizeCb({
      data: getVisualViewport(visualViewport),
      type: RecordType.VisualViewport,
      timestamp: timeStampNow()
    });
  }, VISUAL_VIEWPORT_OBSERVER_THRESHOLD, {
    trailing: false
  });
  const { stop: removeListener } = addEventListeners(configuration, visualViewport, [
    "resize",
    "scroll"
    /* DOM_EVENT.SCROLL */
  ], updateDimension, {
    capture: true,
    passive: true
  });
  return {
    stop: () => {
      removeListener();
      cancelThrottle();
    }
  };
}

// node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackMediaInteraction.js
function trackMediaInteraction(configuration, mediaInteractionCb) {
  return addEventListeners(configuration, document, [
    "play",
    "pause"
    /* DOM_EVENT.PAUSE */
  ], (event) => {
    const target = getEventTarget(event);
    if (!target || getNodePrivacyLevel(target, configuration.defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN || !hasSerializedNode(target)) {
      return;
    }
    mediaInteractionCb(assembleIncrementalSnapshot(IncrementalSource.MediaInteraction, {
      id: getSerializedNodeId(target),
      type: event.type === "play" ? MediaInteractionType.Play : MediaInteractionType.Pause
    }));
  }, {
    capture: true,
    passive: true
  });
}

// node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackStyleSheet.js
function trackStyleSheet(styleSheetCb) {
  function checkStyleSheetAndCallback(styleSheet, callback) {
    if (styleSheet && hasSerializedNode(styleSheet.ownerNode)) {
      callback(getSerializedNodeId(styleSheet.ownerNode));
    }
  }
  const instrumentationStoppers = [
    instrumentMethod(CSSStyleSheet.prototype, "insertRule", ({ target: styleSheet, parameters: [rule, index] }) => {
      checkStyleSheetAndCallback(styleSheet, (id) => styleSheetCb(assembleIncrementalSnapshot(IncrementalSource.StyleSheetRule, {
        id,
        adds: [{ rule, index }]
      })));
    }),
    instrumentMethod(CSSStyleSheet.prototype, "deleteRule", ({ target: styleSheet, parameters: [index] }) => {
      checkStyleSheetAndCallback(styleSheet, (id) => styleSheetCb(assembleIncrementalSnapshot(IncrementalSource.StyleSheetRule, {
        id,
        removes: [{ index }]
      })));
    })
  ];
  if (typeof CSSGroupingRule !== "undefined") {
    instrumentGroupingCSSRuleClass(CSSGroupingRule);
  } else {
    instrumentGroupingCSSRuleClass(CSSMediaRule);
    instrumentGroupingCSSRuleClass(CSSSupportsRule);
  }
  function instrumentGroupingCSSRuleClass(cls) {
    instrumentationStoppers.push(instrumentMethod(cls.prototype, "insertRule", ({ target: styleSheet, parameters: [rule, index] }) => {
      checkStyleSheetAndCallback(styleSheet.parentStyleSheet, (id) => {
        const path = getPathToNestedCSSRule(styleSheet);
        if (path) {
          path.push(index || 0);
          styleSheetCb(assembleIncrementalSnapshot(IncrementalSource.StyleSheetRule, {
            id,
            adds: [{ rule, index: path }]
          }));
        }
      });
    }), instrumentMethod(cls.prototype, "deleteRule", ({ target: styleSheet, parameters: [index] }) => {
      checkStyleSheetAndCallback(styleSheet.parentStyleSheet, (id) => {
        const path = getPathToNestedCSSRule(styleSheet);
        if (path) {
          path.push(index);
          styleSheetCb(assembleIncrementalSnapshot(IncrementalSource.StyleSheetRule, {
            id,
            removes: [{ index: path }]
          }));
        }
      });
    }));
  }
  return {
    stop: () => {
      instrumentationStoppers.forEach((stopper) => stopper.stop());
    }
  };
}
function getPathToNestedCSSRule(rule) {
  const path = [];
  let currentRule = rule;
  while (currentRule.parentRule) {
    const rules2 = Array.from(currentRule.parentRule.cssRules);
    const index2 = rules2.indexOf(currentRule);
    path.unshift(index2);
    currentRule = currentRule.parentRule;
  }
  if (!currentRule.parentStyleSheet) {
    return;
  }
  const rules = Array.from(currentRule.parentStyleSheet.cssRules);
  const index = rules.indexOf(currentRule);
  path.unshift(index);
  return path;
}

// node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackFocus.js
function trackFocus(configuration, focusCb) {
  return addEventListeners(configuration, window, [
    "focus",
    "blur"
    /* DOM_EVENT.BLUR */
  ], () => {
    focusCb({
      data: { has_focus: document.hasFocus() },
      type: RecordType.Focus,
      timestamp: timeStampNow()
    });
  });
}

// node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackFrustration.js
function trackFrustration(lifeCycle, frustrationCb, recordIds) {
  const frustrationSubscription = lifeCycle.subscribe(12, (data) => {
    var _a, _b;
    if (data.rawRumEvent.type === "action" && data.rawRumEvent.action.type === "click" && ((_b = (_a = data.rawRumEvent.action.frustration) === null || _a === void 0 ? void 0 : _a.type) === null || _b === void 0 ? void 0 : _b.length) && "events" in data.domainContext && data.domainContext.events && data.domainContext.events.length) {
      frustrationCb({
        timestamp: data.rawRumEvent.date,
        type: RecordType.FrustrationRecord,
        data: {
          frustrationTypes: data.rawRumEvent.action.frustration.type,
          recordIds: data.domainContext.events.map((e) => recordIds.getIdForEvent(e))
        }
      });
    }
  });
  return {
    stop: () => {
      frustrationSubscription.unsubscribe();
    }
  };
}

// node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackViewEnd.js
function trackViewEnd(lifeCycle, viewEndCb) {
  const viewEndSubscription = lifeCycle.subscribe(5, () => {
    viewEndCb({
      timestamp: timeStampNow(),
      type: RecordType.ViewEnd
    });
  });
  return {
    stop: () => {
      viewEndSubscription.unsubscribe();
    }
  };
}

// node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackInput.js
function trackInput(configuration, inputCb, target = document) {
  const defaultPrivacyLevel = configuration.defaultPrivacyLevel;
  const lastInputStateMap = /* @__PURE__ */ new WeakMap();
  const isShadowRoot = target !== document;
  const { stop: stopEventListeners } = addEventListeners(
    configuration,
    target,
    // The 'input' event bubbles across shadow roots, so we don't have to listen for it on shadow
    // roots since it will be handled by the event listener that we did add to the document. Only
    // the 'change' event is blocked and needs to be handled on shadow roots.
    isShadowRoot ? [
      "change"
      /* DOM_EVENT.CHANGE */
    ] : [
      "input",
      "change"
      /* DOM_EVENT.CHANGE */
    ],
    (event) => {
      const target2 = getEventTarget(event);
      if (target2 instanceof HTMLInputElement || target2 instanceof HTMLTextAreaElement || target2 instanceof HTMLSelectElement) {
        onElementChange(target2);
      }
    },
    {
      capture: true,
      passive: true
    }
  );
  let stopPropertySetterInstrumentation;
  if (!isShadowRoot) {
    const instrumentationStoppers = [
      instrumentSetter(HTMLInputElement.prototype, "value", onElementChange),
      instrumentSetter(HTMLInputElement.prototype, "checked", onElementChange),
      instrumentSetter(HTMLSelectElement.prototype, "value", onElementChange),
      instrumentSetter(HTMLTextAreaElement.prototype, "value", onElementChange),
      instrumentSetter(HTMLSelectElement.prototype, "selectedIndex", onElementChange)
    ];
    stopPropertySetterInstrumentation = () => {
      instrumentationStoppers.forEach((stopper) => stopper.stop());
    };
  } else {
    stopPropertySetterInstrumentation = noop;
  }
  return {
    stop: () => {
      stopPropertySetterInstrumentation();
      stopEventListeners();
    }
  };
  function onElementChange(target2) {
    const nodePrivacyLevel = getNodePrivacyLevel(target2, defaultPrivacyLevel);
    if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {
      return;
    }
    const type = target2.type;
    let inputState;
    if (type === "radio" || type === "checkbox") {
      if (shouldMaskNode(target2, nodePrivacyLevel)) {
        return;
      }
      inputState = { isChecked: target2.checked };
    } else {
      const value = getElementInputValue(target2, nodePrivacyLevel);
      if (value === void 0) {
        return;
      }
      inputState = { text: value };
    }
    cbWithDedup(target2, inputState);
    const name = target2.name;
    if (type === "radio" && name && target2.checked) {
      document.querySelectorAll(`input[type="radio"][name="${CSS.escape(name)}"]`).forEach((el) => {
        if (el !== target2) {
          cbWithDedup(el, { isChecked: false });
        }
      });
    }
  }
  function cbWithDedup(target2, inputState) {
    if (!hasSerializedNode(target2)) {
      return;
    }
    const lastInputState = lastInputStateMap.get(target2);
    if (!lastInputState || lastInputState.text !== inputState.text || lastInputState.isChecked !== inputState.isChecked) {
      lastInputStateMap.set(target2, inputState);
      inputCb(assembleIncrementalSnapshot(IncrementalSource.Input, {
        id: getSerializedNodeId(target2),
        ...inputState
      }));
    }
  }
}

// node_modules/@datadog/browser-rum/esm/domain/record/mutationBatch.js
var MUTATION_PROCESS_MAX_DELAY = 100;
var MUTATION_PROCESS_MIN_DELAY = 16;
function createMutationBatch(processMutationBatch) {
  let cancelScheduledFlush = noop;
  let pendingMutations = [];
  function flush() {
    cancelScheduledFlush();
    processMutationBatch(pendingMutations);
    pendingMutations = [];
  }
  const { throttled: throttledFlush, cancel: cancelThrottle } = throttle(flush, MUTATION_PROCESS_MIN_DELAY, {
    leading: false
  });
  return {
    addMutations: (mutations) => {
      if (pendingMutations.length === 0) {
        cancelScheduledFlush = requestIdleCallback(throttledFlush, { timeout: MUTATION_PROCESS_MAX_DELAY });
      }
      pendingMutations.push(...mutations);
    },
    flush,
    stop: () => {
      cancelScheduledFlush();
      cancelThrottle();
    }
  };
}

// node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackMutation.js
function trackMutation(mutationCallback, configuration, shadowRootsController, target) {
  const MutationObserver = getMutationObserverConstructor();
  if (!MutationObserver) {
    return { stop: noop, flush: noop };
  }
  const mutationBatch = createMutationBatch((mutations) => {
    processMutations(mutations.concat(observer.takeRecords()), mutationCallback, configuration, shadowRootsController);
  });
  const observer = new MutationObserver(monitor(mutationBatch.addMutations));
  observer.observe(target, {
    attributeOldValue: true,
    attributes: true,
    characterData: true,
    characterDataOldValue: true,
    childList: true,
    subtree: true
  });
  return {
    stop: () => {
      observer.disconnect();
      mutationBatch.stop();
    },
    flush: () => {
      mutationBatch.flush();
    }
  };
}
function processMutations(mutations, mutationCallback, configuration, shadowRootsController) {
  const nodePrivacyLevelCache = /* @__PURE__ */ new Map();
  mutations.filter((mutation) => mutation.type === "childList").forEach((mutation) => {
    mutation.removedNodes.forEach((removedNode) => {
      traverseRemovedShadowDom(removedNode, shadowRootsController.removeShadowRoot);
    });
  });
  const filteredMutations = mutations.filter((mutation) => mutation.target.isConnected && nodeAndAncestorsHaveSerializedNode(mutation.target) && getNodePrivacyLevel(mutation.target, configuration.defaultPrivacyLevel, nodePrivacyLevelCache) !== NodePrivacyLevel.HIDDEN);
  const { adds, removes, hasBeenSerialized } = processChildListMutations(filteredMutations.filter((mutation) => mutation.type === "childList"), configuration, shadowRootsController, nodePrivacyLevelCache);
  const texts = processCharacterDataMutations(filteredMutations.filter((mutation) => mutation.type === "characterData" && !hasBeenSerialized(mutation.target)), configuration, nodePrivacyLevelCache);
  const attributes = processAttributesMutations(filteredMutations.filter((mutation) => mutation.type === "attributes" && !hasBeenSerialized(mutation.target)), configuration, nodePrivacyLevelCache);
  if (!texts.length && !attributes.length && !removes.length && !adds.length) {
    return;
  }
  mutationCallback(assembleIncrementalSnapshot(IncrementalSource.Mutation, { adds, removes, texts, attributes }));
}
function processChildListMutations(mutations, configuration, shadowRootsController, nodePrivacyLevelCache) {
  const addedAndMovedNodes = /* @__PURE__ */ new Set();
  const removedNodes = /* @__PURE__ */ new Map();
  for (const mutation of mutations) {
    mutation.addedNodes.forEach((node) => {
      addedAndMovedNodes.add(node);
    });
    mutation.removedNodes.forEach((node) => {
      if (!addedAndMovedNodes.has(node)) {
        removedNodes.set(node, mutation.target);
      }
      addedAndMovedNodes.delete(node);
    });
  }
  const sortedAddedAndMovedNodes = Array.from(addedAndMovedNodes);
  sortAddedAndMovedNodes(sortedAddedAndMovedNodes);
  const serializedNodeIds2 = /* @__PURE__ */ new Set();
  const addedNodeMutations = [];
  for (const node of sortedAddedAndMovedNodes) {
    if (hasBeenSerialized(node)) {
      continue;
    }
    const parentNodePrivacyLevel = getNodePrivacyLevel(node.parentNode, configuration.defaultPrivacyLevel, nodePrivacyLevelCache);
    if (parentNodePrivacyLevel === NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === NodePrivacyLevel.IGNORE) {
      continue;
    }
    const serializedNode = serializeNodeWithId(node, {
      serializedNodeIds: serializedNodeIds2,
      parentNodePrivacyLevel,
      serializationContext: { status: 2, shadowRootsController },
      configuration
    });
    if (!serializedNode) {
      continue;
    }
    const parentNode = getParentNode(node);
    addedNodeMutations.push({
      nextId: getNextSibling(node),
      parentId: getSerializedNodeId(parentNode),
      node: serializedNode
    });
  }
  const removedNodeMutations = [];
  removedNodes.forEach((parent, node) => {
    if (hasSerializedNode(node)) {
      removedNodeMutations.push({
        parentId: getSerializedNodeId(parent),
        id: getSerializedNodeId(node)
      });
    }
  });
  return { adds: addedNodeMutations, removes: removedNodeMutations, hasBeenSerialized };
  function hasBeenSerialized(node) {
    return hasSerializedNode(node) && serializedNodeIds2.has(getSerializedNodeId(node));
  }
  function getNextSibling(node) {
    let nextSibling = node.nextSibling;
    while (nextSibling) {
      if (hasSerializedNode(nextSibling)) {
        return getSerializedNodeId(nextSibling);
      }
      nextSibling = nextSibling.nextSibling;
    }
    return null;
  }
}
function processCharacterDataMutations(mutations, configuration, nodePrivacyLevelCache) {
  var _a;
  const textMutations = [];
  const handledNodes = /* @__PURE__ */ new Set();
  const filteredMutations = mutations.filter((mutation) => {
    if (handledNodes.has(mutation.target)) {
      return false;
    }
    handledNodes.add(mutation.target);
    return true;
  });
  for (const mutation of filteredMutations) {
    const value = mutation.target.textContent;
    if (value === mutation.oldValue) {
      continue;
    }
    const parentNodePrivacyLevel = getNodePrivacyLevel(getParentNode(mutation.target), configuration.defaultPrivacyLevel, nodePrivacyLevelCache);
    if (parentNodePrivacyLevel === NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === NodePrivacyLevel.IGNORE) {
      continue;
    }
    textMutations.push({
      id: getSerializedNodeId(mutation.target),
      // TODO: pass a valid "ignoreWhiteSpace" argument
      value: (_a = getTextContent(mutation.target, false, parentNodePrivacyLevel)) !== null && _a !== void 0 ? _a : null
    });
  }
  return textMutations;
}
function processAttributesMutations(mutations, configuration, nodePrivacyLevelCache) {
  const attributeMutations = [];
  const handledElements = /* @__PURE__ */ new Map();
  const filteredMutations = mutations.filter((mutation) => {
    const handledAttributes = handledElements.get(mutation.target);
    if (handledAttributes && handledAttributes.has(mutation.attributeName)) {
      return false;
    }
    if (!handledAttributes) {
      handledElements.set(mutation.target, /* @__PURE__ */ new Set([mutation.attributeName]));
    } else {
      handledAttributes.add(mutation.attributeName);
    }
    return true;
  });
  const emittedMutations = /* @__PURE__ */ new Map();
  for (const mutation of filteredMutations) {
    const uncensoredValue = mutation.target.getAttribute(mutation.attributeName);
    if (uncensoredValue === mutation.oldValue) {
      continue;
    }
    const privacyLevel = getNodePrivacyLevel(mutation.target, configuration.defaultPrivacyLevel, nodePrivacyLevelCache);
    const attributeValue = serializeAttribute(mutation.target, privacyLevel, mutation.attributeName, configuration);
    let transformedValue;
    if (mutation.attributeName === "value") {
      const inputValue = getElementInputValue(mutation.target, privacyLevel);
      if (inputValue === void 0) {
        continue;
      }
      transformedValue = inputValue;
    } else if (typeof attributeValue === "string") {
      transformedValue = attributeValue;
    } else {
      transformedValue = null;
    }
    let emittedMutation = emittedMutations.get(mutation.target);
    if (!emittedMutation) {
      emittedMutation = {
        id: getSerializedNodeId(mutation.target),
        attributes: {}
      };
      attributeMutations.push(emittedMutation);
      emittedMutations.set(mutation.target, emittedMutation);
    }
    emittedMutation.attributes[mutation.attributeName] = transformedValue;
  }
  return attributeMutations;
}
function sortAddedAndMovedNodes(nodes) {
  nodes.sort((a, b) => {
    const position = a.compareDocumentPosition(b);
    if (position & Node.DOCUMENT_POSITION_CONTAINED_BY) {
      return -1;
    } else if (position & Node.DOCUMENT_POSITION_CONTAINS) {
      return 1;
    } else if (position & Node.DOCUMENT_POSITION_FOLLOWING) {
      return 1;
    } else if (position & Node.DOCUMENT_POSITION_PRECEDING) {
      return -1;
    }
    return 0;
  });
}
function traverseRemovedShadowDom(removedNode, shadowDomRemovedCallback) {
  if (isNodeShadowHost(removedNode)) {
    shadowDomRemovedCallback(removedNode.shadowRoot);
  }
  forEachChildNodes(removedNode, (childNode) => traverseRemovedShadowDom(childNode, shadowDomRemovedCallback));
}

// node_modules/@datadog/browser-rum/esm/domain/record/elementsScrollPositions.js
function createElementsScrollPositions() {
  const scrollPositionsByElement = /* @__PURE__ */ new WeakMap();
  return {
    set(element, scrollPositions) {
      if (element === document && !document.scrollingElement) {
        return;
      }
      scrollPositionsByElement.set(element === document ? document.scrollingElement : element, scrollPositions);
    },
    get(element) {
      return scrollPositionsByElement.get(element);
    },
    has(element) {
      return scrollPositionsByElement.has(element);
    }
  };
}

// node_modules/@datadog/browser-rum/esm/domain/record/shadowRootsController.js
var initShadowRootsController = (configuration, callback, elementsScrollPositions) => {
  const controllerByShadowRoot = /* @__PURE__ */ new Map();
  const shadowRootsController = {
    addShadowRoot: (shadowRoot) => {
      if (controllerByShadowRoot.has(shadowRoot)) {
        return;
      }
      const mutationTracker = trackMutation(callback, configuration, shadowRootsController, shadowRoot);
      const inputTracker = trackInput(configuration, callback, shadowRoot);
      const scrollTracker = trackScroll(configuration, callback, elementsScrollPositions, shadowRoot);
      controllerByShadowRoot.set(shadowRoot, {
        flush: () => mutationTracker.flush(),
        stop: () => {
          mutationTracker.stop();
          inputTracker.stop();
          scrollTracker.stop();
        }
      });
    },
    removeShadowRoot: (shadowRoot) => {
      const entry = controllerByShadowRoot.get(shadowRoot);
      if (!entry) {
        return;
      }
      entry.stop();
      controllerByShadowRoot.delete(shadowRoot);
    },
    stop: () => {
      controllerByShadowRoot.forEach(({ stop }) => stop());
    },
    flush: () => {
      controllerByShadowRoot.forEach(({ flush }) => flush());
    }
  };
  return shadowRootsController;
};

// node_modules/@datadog/browser-rum/esm/domain/record/startFullSnapshots.js
function startFullSnapshots(elementsScrollPositions, shadowRootsController, lifeCycle, configuration, flushMutations, fullSnapshotCallback) {
  const takeFullSnapshot = (timestamp = timeStampNow(), serializationContext = {
    status: 0,
    elementsScrollPositions,
    shadowRootsController
  }) => {
    const { width, height } = getViewportDimension();
    const records = [
      {
        data: {
          height,
          href: window.location.href,
          width
        },
        type: RecordType.Meta,
        timestamp
      },
      {
        data: {
          has_focus: document.hasFocus()
        },
        type: RecordType.Focus,
        timestamp
      },
      {
        data: {
          node: serializeDocument(document, configuration, serializationContext),
          initialOffset: {
            left: getScrollX(),
            top: getScrollY()
          }
        },
        type: RecordType.FullSnapshot,
        timestamp
      }
    ];
    if (window.visualViewport) {
      records.push({
        data: getVisualViewport(window.visualViewport),
        type: RecordType.VisualViewport,
        timestamp
      });
    }
    return records;
  };
  fullSnapshotCallback(takeFullSnapshot());
  const { unsubscribe } = lifeCycle.subscribe(2, (view) => {
    flushMutations();
    fullSnapshotCallback(takeFullSnapshot(view.startClocks.timeStamp, {
      shadowRootsController,
      status: 1,
      elementsScrollPositions
    }));
  });
  return {
    stop: unsubscribe
  };
}

// node_modules/@datadog/browser-rum/esm/domain/record/recordIds.js
function initRecordIds() {
  const recordIds = /* @__PURE__ */ new WeakMap();
  let nextId = 1;
  return {
    getIdForEvent(event) {
      if (!recordIds.has(event)) {
        recordIds.set(event, nextId++);
      }
      return recordIds.get(event);
    }
  };
}

// node_modules/@datadog/browser-rum/esm/domain/record/record.js
function record(options) {
  const { emit, configuration, lifeCycle } = options;
  if (!emit) {
    throw new Error("emit function is required");
  }
  const emitAndComputeStats = (record2) => {
    emit(record2);
    sendToExtension("record", { record: record2 });
    const view = options.viewHistory.findView();
    addRecord(view.id);
  };
  const elementsScrollPositions = createElementsScrollPositions();
  const shadowRootsController = initShadowRootsController(configuration, emitAndComputeStats, elementsScrollPositions);
  const { stop: stopFullSnapshots } = startFullSnapshots(elementsScrollPositions, shadowRootsController, lifeCycle, configuration, flushMutations, (records) => records.forEach((record2) => emitAndComputeStats(record2)));
  function flushMutations() {
    shadowRootsController.flush();
    mutationTracker.flush();
  }
  const recordIds = initRecordIds();
  const mutationTracker = trackMutation(emitAndComputeStats, configuration, shadowRootsController, document);
  const trackers = [
    mutationTracker,
    trackMove(configuration, emitAndComputeStats),
    trackMouseInteraction(configuration, emitAndComputeStats, recordIds),
    trackScroll(configuration, emitAndComputeStats, elementsScrollPositions, document),
    trackViewportResize(configuration, emitAndComputeStats),
    trackInput(configuration, emitAndComputeStats),
    trackMediaInteraction(configuration, emitAndComputeStats),
    trackStyleSheet(emitAndComputeStats),
    trackFocus(configuration, emitAndComputeStats),
    trackVisualViewportResize(configuration, emitAndComputeStats),
    trackFrustration(lifeCycle, emitAndComputeStats, recordIds),
    trackViewEnd(lifeCycle, (viewEndRecord) => {
      flushMutations();
      emitAndComputeStats(viewEndRecord);
    })
  ];
  return {
    stop: () => {
      shadowRootsController.stop();
      trackers.forEach((tracker) => tracker.stop());
      stopFullSnapshots();
    },
    flushMutations,
    shadowRootsController
  };
}

// node_modules/@datadog/browser-rum/esm/domain/segmentCollection/buildReplayPayload.js
function buildReplayPayload(data, metadata, rawSegmentBytesCount) {
  const formData = new FormData();
  formData.append("segment", new Blob([data], {
    type: "application/octet-stream"
  }), `${metadata.session.id}-${metadata.start}`);
  const metadataAndSegmentSizes = {
    raw_segment_size: rawSegmentBytesCount,
    compressed_segment_size: data.byteLength,
    ...metadata
  };
  const serializedMetadataAndSegmentSizes = JSON.stringify(metadataAndSegmentSizes);
  formData.append("event", new Blob([serializedMetadataAndSegmentSizes], { type: "application/json" }));
  return { data: formData, bytesCount: data.byteLength };
}

// node_modules/@datadog/browser-rum/esm/domain/segmentCollection/segment.js
function createSegment({ context, creationReason, encoder }) {
  let encodedBytesCount = 0;
  const viewId = context.view.id;
  const metadata = {
    start: Infinity,
    end: -Infinity,
    creation_reason: creationReason,
    records_count: 0,
    has_full_snapshot: false,
    index_in_view: getSegmentsCount(viewId),
    source: "browser",
    ...context
  };
  addSegment(viewId);
  function addRecord2(record2, callback) {
    metadata.start = Math.min(metadata.start, record2.timestamp);
    metadata.end = Math.max(metadata.end, record2.timestamp);
    metadata.records_count += 1;
    metadata.has_full_snapshot || (metadata.has_full_snapshot = record2.type === RecordType.FullSnapshot);
    const prefix = encoder.isEmpty ? '{"records":[' : ",";
    encoder.write(prefix + JSON.stringify(record2), (additionalEncodedBytesCount) => {
      encodedBytesCount += additionalEncodedBytesCount;
      callback(encodedBytesCount);
    });
  }
  function flush(callback) {
    if (encoder.isEmpty) {
      throw new Error("Empty segment flushed");
    }
    encoder.write(`],${JSON.stringify(metadata).slice(1)}
`);
    encoder.finish((encoderResult) => {
      addWroteData(metadata.view.id, encoderResult.rawBytesCount);
      callback(metadata, encoderResult);
    });
  }
  return { addRecord: addRecord2, flush };
}

// node_modules/@datadog/browser-rum/esm/domain/segmentCollection/segmentCollection.js
var SEGMENT_DURATION_LIMIT = 5 * ONE_SECOND;
var SEGMENT_BYTES_LIMIT = 6e4;
function startSegmentCollection(lifeCycle, configuration, sessionManager, viewHistory, httpRequest, encoder) {
  return doStartSegmentCollection(lifeCycle, () => computeSegmentContext(configuration.applicationId, sessionManager, viewHistory), httpRequest, encoder);
}
function doStartSegmentCollection(lifeCycle, getSegmentContext, httpRequest, encoder) {
  let state = {
    status: 0,
    nextSegmentCreationReason: "init"
  };
  const { unsubscribe: unsubscribeViewCreated } = lifeCycle.subscribe(2, () => {
    flushSegment("view_change");
  });
  const { unsubscribe: unsubscribePageMayExit } = lifeCycle.subscribe(11, (pageMayExitEvent) => {
    flushSegment(pageMayExitEvent.reason);
  });
  function flushSegment(flushReason) {
    if (state.status === 1) {
      state.segment.flush((metadata, encoderResult) => {
        const payload = buildReplayPayload(encoderResult.output, metadata, encoderResult.rawBytesCount);
        if (isPageExitReason(flushReason)) {
          httpRequest.sendOnExit(payload);
        } else {
          httpRequest.send(payload);
        }
      });
      clearTimeout(state.expirationTimeoutId);
    }
    if (flushReason !== "stop") {
      state = {
        status: 0,
        nextSegmentCreationReason: flushReason
      };
    } else {
      state = {
        status: 2
      };
    }
  }
  return {
    addRecord: (record2) => {
      if (state.status === 2) {
        return;
      }
      if (state.status === 0) {
        const context = getSegmentContext();
        if (!context) {
          return;
        }
        state = {
          status: 1,
          segment: createSegment({ encoder, context, creationReason: state.nextSegmentCreationReason }),
          expirationTimeoutId: setTimeout(() => {
            flushSegment("segment_duration_limit");
          }, SEGMENT_DURATION_LIMIT)
        };
      }
      state.segment.addRecord(record2, (encodedBytesCount) => {
        if (encodedBytesCount > SEGMENT_BYTES_LIMIT) {
          flushSegment("segment_bytes_limit");
        }
      });
    },
    stop: () => {
      flushSegment("stop");
      unsubscribeViewCreated();
      unsubscribePageMayExit();
    }
  };
}
function computeSegmentContext(applicationId, sessionManager, viewHistory) {
  const session = sessionManager.findTrackedSession();
  const viewContext = viewHistory.findView();
  if (!session || !viewContext) {
    return void 0;
  }
  return {
    application: {
      id: applicationId
    },
    session: {
      id: session.id
    },
    view: {
      id: viewContext.id
    }
  };
}

// node_modules/@datadog/browser-rum/esm/domain/startRecordBridge.js
function startRecordBridge(viewHistory) {
  const bridge = getEventBridge();
  return {
    addRecord: (record2) => {
      const view = viewHistory.findView();
      bridge.send("record", record2, view.id);
    }
  };
}

// node_modules/@datadog/browser-rum/esm/boot/startRecording.js
function startRecording(lifeCycle, configuration, sessionManager, viewHistory, encoder, httpRequest) {
  const cleanupTasks = [];
  const reportError = (error) => {
    lifeCycle.notify(14, { error });
    addTelemetryDebug("Error reported to customer", { "error.message": error.message });
  };
  const replayRequest = httpRequest || createHttpRequest(configuration.sessionReplayEndpointBuilder, SEGMENT_BYTES_LIMIT, reportError);
  let addRecord2;
  if (!canUseEventBridge()) {
    const segmentCollection = startSegmentCollection(lifeCycle, configuration, sessionManager, viewHistory, replayRequest, encoder);
    addRecord2 = segmentCollection.addRecord;
    cleanupTasks.push(segmentCollection.stop);
  } else {
    ;
    ({ addRecord: addRecord2 } = startRecordBridge(viewHistory));
  }
  const { stop: stopRecording } = record({
    emit: addRecord2,
    configuration,
    lifeCycle,
    viewHistory
  });
  cleanupTasks.push(stopRecording);
  return {
    stop: () => {
      cleanupTasks.forEach((task) => task());
    }
  };
}
export {
  startRecording
};
//# sourceMappingURL=startRecording-FSBUUMPH.js.map
