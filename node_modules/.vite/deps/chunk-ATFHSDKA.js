import {
  AbstractLifeCycle,
  ConsoleApiName,
  ContextManagerMethod,
  CustomerContextKey,
  DISCARDED,
  DefaultPrivacyLevel,
  ErrorSource,
  ExperimentalFeature,
  INTAKE_SITE_EU1,
  INTAKE_SITE_STAGING,
  INTAKE_SITE_US1,
  ONE_MINUTE,
  ONE_SECOND,
  Observable,
  PageExitReason,
  RawReportType,
  SESSION_TIME_OUT_DELAY,
  SKIPPED,
  TraceContextInjection,
  abstractHooks,
  addDuration,
  addEventListener,
  addEventListeners,
  addTelemetryConfiguration,
  addTelemetryDebug,
  addTelemetryUsage,
  bridgeSupports,
  buildAccountContextManager,
  buildEndpointHost,
  buildGlobalContextManager,
  buildUserContextManager,
  callMonitored,
  canUseEventBridge,
  clearInterval,
  clearTimeout,
  clocksNow,
  clocksOrigin,
  combine,
  computeRawError,
  createBoundedBuffer,
  createContextManager,
  createEventRateLimiter,
  createHandlingStack,
  createIdentityEncoder,
  createPageMayExitObservable,
  createTaskQueue,
  createTrackingConsentState,
  createValueHistory,
  currentDrift,
  dateNow,
  deepClone,
  defineContextMethod,
  display,
  displayAlreadyInitializedError,
  elapsed,
  findCommaSeparatedValue,
  findLast,
  generateUUID,
  getConnectivity,
  getEventBridge,
  getInitCookie,
  getPathName,
  getRelativeTime,
  getSyntheticsResultId,
  getSyntheticsTestId,
  getType,
  getZoneJsOriginalValue,
  initConsoleObservable,
  initFeatureFlags,
  initFetchObservable,
  initReportObservable,
  initXhrObservable,
  instrumentMethod,
  isEmptyObject,
  isExperimentalFeatureEnabled,
  isIntakeUrl,
  isMatchOption,
  isNumber,
  isSampleRate,
  isSyntheticsTest,
  isValidUrl,
  looksLikeRelativeTime,
  makePublicApi,
  mapValues,
  matchList,
  monitor,
  noop,
  objectEntries,
  objectHasValue,
  performDraw,
  readBytesFromStream,
  relativeNow,
  relativeToClocks,
  round,
  runOnReadyState,
  safeTruncate,
  sanitize,
  sendToExtension,
  serializeConfiguration,
  setInterval,
  setTimeout,
  shallowClone,
  startAccountContext,
  startBatchWithReplica,
  startGlobalContext,
  startSessionManager,
  startTelemetry,
  startUserContext,
  throttle,
  timeStampNow,
  timeStampToClocks,
  toServerDuration,
  trackRuntimeError,
  tryToClone,
  validateAndBuildConfiguration,
  willSyntheticsInjectRum
} from "./chunk-Z3Q3XVIP.js";

// node_modules/@datadog/browser-rum-core/esm/domain/vital/vitalCollection.js
function createCustomVitalsState() {
  const vitalsByName = /* @__PURE__ */ new Map();
  const vitalsByReference = /* @__PURE__ */ new WeakMap();
  return { vitalsByName, vitalsByReference };
}
function startVitalCollection(lifeCycle, pageStateHistory, customVitalsState) {
  function isValid(vital) {
    return !pageStateHistory.wasInPageStateDuringPeriod("frozen", vital.startClocks.relative, vital.duration);
  }
  function addDurationVital(vital) {
    if (isValid(vital)) {
      lifeCycle.notify(12, processVital(vital, true));
    }
  }
  return {
    addDurationVital,
    startDurationVital: (name, options = {}) => startDurationVital(customVitalsState, name, options),
    stopDurationVital: (nameOrRef, options = {}) => {
      stopDurationVital(addDurationVital, customVitalsState, nameOrRef, options);
    }
  };
}
function startDurationVital({ vitalsByName, vitalsByReference }, name, options = {}) {
  const vital = {
    name,
    startClocks: clocksNow(),
    context: options.context,
    description: options.description
  };
  const reference = { __dd_vital_reference: true };
  vitalsByName.set(name, vital);
  vitalsByReference.set(reference, vital);
  return reference;
}
function stopDurationVital(stopCallback, { vitalsByName, vitalsByReference }, nameOrRef, options = {}) {
  const vitalStart = typeof nameOrRef === "string" ? vitalsByName.get(nameOrRef) : vitalsByReference.get(nameOrRef);
  if (!vitalStart) {
    return;
  }
  stopCallback(buildDurationVital(vitalStart, vitalStart.startClocks, options, clocksNow()));
  if (typeof nameOrRef === "string") {
    vitalsByName.delete(nameOrRef);
  } else {
    vitalsByReference.delete(nameOrRef);
  }
}
function buildDurationVital(vitalStart, startClocks, stopOptions, stopClocks) {
  var _a;
  return {
    name: vitalStart.name,
    type: "duration",
    startClocks,
    duration: elapsed(startClocks.timeStamp, stopClocks.timeStamp),
    context: combine(vitalStart.context, stopOptions.context),
    description: (_a = stopOptions.description) !== null && _a !== void 0 ? _a : vitalStart.description
  };
}
function processVital(vital, valueComputedBySdk) {
  const rawRumEvent = {
    date: vital.startClocks.timeStamp,
    vital: {
      id: generateUUID(),
      type: vital.type,
      name: vital.name,
      duration: toServerDuration(vital.duration),
      description: vital.description
    },
    type: "vital"
  };
  if (valueComputedBySdk) {
    rawRumEvent._dd = {
      vital: {
        computed_value: true
      }
    };
  }
  return {
    rawRumEvent,
    startTime: vital.startClocks.relative,
    duration: vital.duration,
    customerContext: vital.context,
    domainContext: {}
  };
}

// node_modules/@datadog/browser-rum-core/esm/domain/plugins.js
function callPluginsMethod(plugins, methodName, parameter) {
  if (!plugins) {
    return;
  }
  for (const plugin of plugins) {
    const method = plugin[methodName];
    if (method) {
      method(parameter);
    }
  }
}

// node_modules/@datadog/browser-rum-core/esm/domain/tracing/identifier.js
function createTraceIdentifier() {
  return createIdentifier(64);
}
function createSpanIdentifier() {
  return createIdentifier(63);
}
function createIdentifier(bits) {
  const buffer = crypto.getRandomValues(new Uint32Array(2));
  if (bits === 63) {
    buffer[buffer.length - 1] >>>= 1;
  }
  return {
    toString(radix = 10) {
      let high = buffer[1];
      let low = buffer[0];
      let str = "";
      do {
        const mod = high % radix * 4294967296 + low;
        high = Math.floor(high / radix);
        low = Math.floor(mod / radix);
        str = (mod % radix).toString(radix) + str;
      } while (high || low);
      return str;
    }
  };
}
function toPaddedHexadecimalString(id) {
  return id.toString(16).padStart(16, "0");
}

// node_modules/@datadog/browser-rum-core/esm/domain/tracing/sampler.js
var sampleDecisionCache;
function isTraceSampled(sessionId, sampleRate) {
  if (sampleRate === 100) {
    return true;
  }
  if (sampleRate === 0) {
    return false;
  }
  if (sampleDecisionCache && sessionId === sampleDecisionCache.sessionId) {
    return sampleDecisionCache.decision;
  }
  let decision;
  if (window.BigInt) {
    decision = sampleUsingKnuthFactor(BigInt(`0x${sessionId.split("-")[4]}`), sampleRate);
  } else {
    decision = performDraw(sampleRate);
  }
  sampleDecisionCache = { sessionId, decision };
  return decision;
}
function sampleUsingKnuthFactor(identifier, sampleRate) {
  const knuthFactor = BigInt("1111111111111111111");
  const twoPow64 = BigInt("0x10000000000000000");
  const hash = identifier * knuthFactor % twoPow64;
  return Number(hash) <= sampleRate / 100 * Number(twoPow64);
}

// node_modules/@datadog/browser-rum-core/esm/domain/tracing/tracer.js
function isTracingOption(item) {
  const expectedItem = item;
  return getType(expectedItem) === "object" && isMatchOption(expectedItem.match) && Array.isArray(expectedItem.propagatorTypes);
}
function clearTracingIfNeeded(context) {
  if (context.status === 0 && !context.isAborted) {
    context.traceId = void 0;
    context.spanId = void 0;
    context.traceSampled = void 0;
  }
}
function startTracer(configuration, sessionManager, userContext, accountContext) {
  return {
    clearTracingIfNeeded,
    traceFetch: (context) => injectHeadersIfTracingAllowed(configuration, context, sessionManager, userContext, accountContext, (tracingHeaders) => {
      var _a;
      if (context.input instanceof Request && !((_a = context.init) === null || _a === void 0 ? void 0 : _a.headers)) {
        context.input = new Request(context.input);
        Object.keys(tracingHeaders).forEach((key) => {
          ;
          context.input.headers.append(key, tracingHeaders[key]);
        });
      } else {
        context.init = shallowClone(context.init);
        const headers = [];
        if (context.init.headers instanceof Headers) {
          context.init.headers.forEach((value, key) => {
            headers.push([key, value]);
          });
        } else if (Array.isArray(context.init.headers)) {
          context.init.headers.forEach((header) => {
            headers.push(header);
          });
        } else if (context.init.headers) {
          Object.keys(context.init.headers).forEach((key) => {
            headers.push([key, context.init.headers[key]]);
          });
        }
        context.init.headers = headers.concat(objectEntries(tracingHeaders));
      }
    }),
    traceXhr: (context, xhr) => injectHeadersIfTracingAllowed(configuration, context, sessionManager, userContext, accountContext, (tracingHeaders) => {
      Object.keys(tracingHeaders).forEach((name) => {
        xhr.setRequestHeader(name, tracingHeaders[name]);
      });
    })
  };
}
function injectHeadersIfTracingAllowed(configuration, context, sessionManager, userContext, accountContext, inject) {
  const session = sessionManager.findTrackedSession();
  if (!session) {
    return;
  }
  const tracingOption = configuration.allowedTracingUrls.find((tracingOption2) => matchList([tracingOption2.match], context.url, true));
  if (!tracingOption) {
    return;
  }
  const traceSampled = isTraceSampled(session.id, configuration.traceSampleRate);
  const shouldInjectHeaders = traceSampled || configuration.traceContextInjection === TraceContextInjection.ALL;
  if (!shouldInjectHeaders) {
    return;
  }
  context.traceSampled = traceSampled;
  context.traceId = createTraceIdentifier();
  context.spanId = createSpanIdentifier();
  inject(makeTracingHeaders(context.traceId, context.spanId, context.traceSampled, session.id, tracingOption.propagatorTypes, userContext, accountContext, configuration));
}
function makeTracingHeaders(traceId, spanId, traceSampled, sessionId, propagatorTypes, userContext, accountContext, configuration) {
  const tracingHeaders = {};
  propagatorTypes.forEach((propagatorType) => {
    switch (propagatorType) {
      case "datadog": {
        Object.assign(tracingHeaders, {
          "x-datadog-origin": "rum",
          "x-datadog-parent-id": spanId.toString(),
          "x-datadog-sampling-priority": traceSampled ? "1" : "0",
          "x-datadog-trace-id": traceId.toString()
        });
        break;
      }
      // https://www.w3.org/TR/trace-context/
      case "tracecontext": {
        Object.assign(tracingHeaders, {
          traceparent: `00-0000000000000000${toPaddedHexadecimalString(traceId)}-${toPaddedHexadecimalString(spanId)}-0${traceSampled ? "1" : "0"}`,
          tracestate: `dd=s:${traceSampled ? "1" : "0"};o:rum`
        });
        break;
      }
      // https://github.com/openzipkin/b3-propagation
      case "b3": {
        Object.assign(tracingHeaders, {
          b3: `${toPaddedHexadecimalString(traceId)}-${toPaddedHexadecimalString(spanId)}-${traceSampled ? "1" : "0"}`
        });
        break;
      }
      case "b3multi": {
        Object.assign(tracingHeaders, {
          "X-B3-TraceId": toPaddedHexadecimalString(traceId),
          "X-B3-SpanId": toPaddedHexadecimalString(spanId),
          "X-B3-Sampled": traceSampled ? "1" : "0"
        });
        break;
      }
    }
  });
  if (configuration.propagateTraceBaggage) {
    const baggageItems = {
      "session.id": sessionId
    };
    const userId = userContext.getContext().id;
    if (typeof userId === "string") {
      baggageItems["user.id"] = userId;
    }
    const accountId = accountContext.getContext().id;
    if (typeof accountId === "string") {
      baggageItems["account.id"] = accountId;
    }
    const baggageHeader = Object.entries(baggageItems).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join(",");
    if (baggageHeader) {
      tracingHeaders["baggage"] = baggageHeader;
    }
  }
  return tracingHeaders;
}

// node_modules/@datadog/browser-rum-core/esm/domain/configuration/configuration.js
var DEFAULT_PROPAGATOR_TYPES = ["tracecontext", "datadog"];
function validateAndBuildRumConfiguration(initConfiguration) {
  var _a, _b, _c, _d, _e, _f, _g;
  if (initConfiguration.trackFeatureFlagsForEvents !== void 0 && !Array.isArray(initConfiguration.trackFeatureFlagsForEvents)) {
    display.warn("trackFeatureFlagsForEvents should be an array");
  }
  if (!initConfiguration.applicationId) {
    display.error("Application ID is not configured, no RUM data will be collected.");
    return;
  }
  if (!isSampleRate(initConfiguration.sessionReplaySampleRate, "Session Replay") || !isSampleRate(initConfiguration.traceSampleRate, "Trace")) {
    return;
  }
  if (initConfiguration.excludedActivityUrls !== void 0 && !Array.isArray(initConfiguration.excludedActivityUrls)) {
    display.error("Excluded Activity Urls should be an array");
    return;
  }
  const allowedTracingUrls = validateAndBuildTracingOptions(initConfiguration);
  if (!allowedTracingUrls) {
    return;
  }
  const baseConfiguration = validateAndBuildConfiguration(initConfiguration);
  if (!baseConfiguration) {
    return;
  }
  const sessionReplaySampleRate = (_a = initConfiguration.sessionReplaySampleRate) !== null && _a !== void 0 ? _a : 0;
  return {
    applicationId: initConfiguration.applicationId,
    version: initConfiguration.version || void 0,
    actionNameAttribute: initConfiguration.actionNameAttribute,
    sessionReplaySampleRate,
    startSessionReplayRecordingManually: initConfiguration.startSessionReplayRecordingManually !== void 0 ? !!initConfiguration.startSessionReplayRecordingManually : sessionReplaySampleRate === 0,
    traceSampleRate: (_b = initConfiguration.traceSampleRate) !== null && _b !== void 0 ? _b : 100,
    rulePsr: isNumber(initConfiguration.traceSampleRate) ? initConfiguration.traceSampleRate / 100 : void 0,
    allowedTracingUrls,
    excludedActivityUrls: (_c = initConfiguration.excludedActivityUrls) !== null && _c !== void 0 ? _c : [],
    workerUrl: initConfiguration.workerUrl,
    compressIntakeRequests: !!initConfiguration.compressIntakeRequests,
    trackUserInteractions: !!((_d = initConfiguration.trackUserInteractions) !== null && _d !== void 0 ? _d : true),
    trackViewsManually: !!initConfiguration.trackViewsManually,
    trackResources: !!((_e = initConfiguration.trackResources) !== null && _e !== void 0 ? _e : true),
    trackLongTasks: !!((_f = initConfiguration.trackLongTasks) !== null && _f !== void 0 ? _f : true),
    trackBfcacheViews: !!initConfiguration.trackBfcacheViews,
    subdomain: initConfiguration.subdomain,
    defaultPrivacyLevel: objectHasValue(DefaultPrivacyLevel, initConfiguration.defaultPrivacyLevel) ? initConfiguration.defaultPrivacyLevel : DefaultPrivacyLevel.MASK,
    enablePrivacyForActionName: !!initConfiguration.enablePrivacyForActionName,
    customerDataTelemetrySampleRate: 1,
    traceContextInjection: objectHasValue(TraceContextInjection, initConfiguration.traceContextInjection) ? initConfiguration.traceContextInjection : TraceContextInjection.SAMPLED,
    plugins: initConfiguration.plugins || [],
    trackFeatureFlagsForEvents: initConfiguration.trackFeatureFlagsForEvents || [],
    profilingSampleRate: (_g = initConfiguration.profilingSampleRate) !== null && _g !== void 0 ? _g : 0,
    propagateTraceBaggage: !!initConfiguration.propagateTraceBaggage,
    ...baseConfiguration
  };
}
function validateAndBuildTracingOptions(initConfiguration) {
  if (initConfiguration.allowedTracingUrls === void 0) {
    return [];
  }
  if (!Array.isArray(initConfiguration.allowedTracingUrls)) {
    display.error("Allowed Tracing URLs should be an array");
    return;
  }
  if (initConfiguration.allowedTracingUrls.length !== 0 && initConfiguration.service === void 0) {
    display.error("Service needs to be configured when tracing is enabled");
    return;
  }
  const tracingOptions = [];
  initConfiguration.allowedTracingUrls.forEach((option) => {
    if (isMatchOption(option)) {
      tracingOptions.push({ match: option, propagatorTypes: DEFAULT_PROPAGATOR_TYPES });
    } else if (isTracingOption(option)) {
      tracingOptions.push(option);
    } else {
      display.warn("Allowed Tracing Urls parameters should be a string, RegExp, function, or an object. Ignoring parameter", option);
    }
  });
  return tracingOptions;
}
function getSelectedTracingPropagators(configuration) {
  const usedTracingPropagators = /* @__PURE__ */ new Set();
  if (Array.isArray(configuration.allowedTracingUrls) && configuration.allowedTracingUrls.length > 0) {
    configuration.allowedTracingUrls.forEach((option) => {
      if (isMatchOption(option)) {
        DEFAULT_PROPAGATOR_TYPES.forEach((propagatorType) => usedTracingPropagators.add(propagatorType));
      } else if (getType(option) === "object" && Array.isArray(option.propagatorTypes)) {
        option.propagatorTypes.forEach((propagatorType) => usedTracingPropagators.add(propagatorType));
      }
    });
  }
  return Array.from(usedTracingPropagators);
}
function serializeRumConfiguration(configuration) {
  var _a;
  const baseSerializedConfiguration = serializeConfiguration(configuration);
  return {
    session_replay_sample_rate: configuration.sessionReplaySampleRate,
    start_session_replay_recording_manually: configuration.startSessionReplayRecordingManually,
    trace_sample_rate: configuration.traceSampleRate,
    trace_context_injection: configuration.traceContextInjection,
    action_name_attribute: configuration.actionNameAttribute,
    use_allowed_tracing_urls: Array.isArray(configuration.allowedTracingUrls) && configuration.allowedTracingUrls.length > 0,
    selected_tracing_propagators: getSelectedTracingPropagators(configuration),
    default_privacy_level: configuration.defaultPrivacyLevel,
    enable_privacy_for_action_name: configuration.enablePrivacyForActionName,
    use_excluded_activity_urls: Array.isArray(configuration.excludedActivityUrls) && configuration.excludedActivityUrls.length > 0,
    use_worker_url: !!configuration.workerUrl,
    compress_intake_requests: configuration.compressIntakeRequests,
    track_views_manually: configuration.trackViewsManually,
    track_user_interactions: configuration.trackUserInteractions,
    track_resources: configuration.trackResources,
    track_long_task: configuration.trackLongTasks,
    track_bfcache_views: configuration.trackBfcacheViews,
    plugins: (_a = configuration.plugins) === null || _a === void 0 ? void 0 : _a.map((plugin) => {
      var _a2;
      return {
        name: plugin.name,
        ...(_a2 = plugin.getConfigurationTelemetry) === null || _a2 === void 0 ? void 0 : _a2.call(plugin)
      };
    }),
    track_feature_flags_for_events: configuration.trackFeatureFlagsForEvents,
    ...baseSerializedConfiguration
  };
}

// node_modules/@datadog/browser-rum-core/esm/domain/configuration/remoteConfiguration.js
var REMOTE_CONFIGURATION_VERSION = "v1";
function fetchAndApplyRemoteConfiguration(initConfiguration, callback) {
  fetchRemoteConfiguration(initConfiguration, (remoteInitConfiguration) => {
    callback(applyRemoteConfiguration(initConfiguration, remoteInitConfiguration));
  });
}
function applyRemoteConfiguration(initConfiguration, remoteInitConfiguration) {
  return { ...initConfiguration, ...remoteInitConfiguration };
}
function fetchRemoteConfiguration(configuration, callback) {
  const xhr = new XMLHttpRequest();
  addEventListener(configuration, xhr, "load", function() {
    if (xhr.status === 200) {
      const remoteConfiguration = JSON.parse(xhr.responseText);
      callback(remoteConfiguration.rum);
    } else {
      displayRemoteConfigurationFetchingError();
    }
  });
  addEventListener(configuration, xhr, "error", function() {
    displayRemoteConfigurationFetchingError();
  });
  xhr.open("GET", buildEndpoint(configuration));
  xhr.send();
}
function buildEndpoint(configuration) {
  return `https://sdk-configuration.${buildEndpointHost("rum", configuration)}/${REMOTE_CONFIGURATION_VERSION}/${encodeURIComponent(configuration.remoteConfigurationId)}.json`;
}
function displayRemoteConfigurationFetchingError() {
  display.error("Error fetching the remote configuration.");
}

// node_modules/@datadog/browser-rum-core/esm/boot/preStartRum.js
function createPreStartStrategy({ ignoreInitIfSyntheticsWillInjectRum = true, startDeflateWorker }, trackingConsentState, customVitalsState, doStartRum) {
  const bufferApiCalls = createBoundedBuffer();
  const globalContext = buildGlobalContextManager();
  bufferContextCalls(globalContext, CustomerContextKey.globalContext, bufferApiCalls);
  const userContext = buildUserContextManager();
  bufferContextCalls(userContext, CustomerContextKey.userContext, bufferApiCalls);
  const accountContext = buildAccountContextManager();
  bufferContextCalls(accountContext, CustomerContextKey.accountContext, bufferApiCalls);
  let firstStartViewCall;
  let deflateWorker;
  let cachedInitConfiguration;
  let cachedConfiguration;
  const trackingConsentStateSubscription = trackingConsentState.observable.subscribe(tryStartRum);
  const emptyContext = {};
  function tryStartRum() {
    if (!cachedInitConfiguration || !cachedConfiguration || !trackingConsentState.isGranted()) {
      return;
    }
    trackingConsentStateSubscription.unsubscribe();
    let initialViewOptions;
    if (cachedConfiguration.trackViewsManually) {
      if (!firstStartViewCall) {
        return;
      }
      bufferApiCalls.remove(firstStartViewCall.callback);
      initialViewOptions = firstStartViewCall.options;
    }
    const startRumResult = doStartRum(cachedConfiguration, deflateWorker, initialViewOptions);
    bufferApiCalls.drain(startRumResult);
  }
  function doInit(initConfiguration) {
    const eventBridgeAvailable = canUseEventBridge();
    if (eventBridgeAvailable) {
      initConfiguration = overrideInitConfigurationForBridge(initConfiguration);
    }
    cachedInitConfiguration = initConfiguration;
    setTimeout(() => {
      addTelemetryConfiguration(serializeRumConfiguration(initConfiguration));
    });
    if (cachedConfiguration) {
      displayAlreadyInitializedError("DD_RUM", initConfiguration);
      return;
    }
    const configuration = validateAndBuildRumConfiguration(initConfiguration);
    if (!configuration) {
      return;
    }
    if (!eventBridgeAvailable && !configuration.sessionStoreStrategyType) {
      display.warn("No storage available for session. We will not send any data.");
      return;
    }
    if (configuration.compressIntakeRequests && !eventBridgeAvailable && startDeflateWorker) {
      deflateWorker = startDeflateWorker(
        configuration,
        "Datadog RUM",
        // Worker initialization can fail asynchronously, especially in Firefox where even CSP
        // issues are reported asynchronously. For now, the SDK will continue its execution even if
        // data won't be sent to Datadog. We could improve this behavior in the future.
        noop
      );
      if (!deflateWorker) {
        return;
      }
    }
    cachedConfiguration = configuration;
    initFetchObservable().subscribe(noop);
    trackingConsentState.tryToInit(configuration.trackingConsent);
    tryStartRum();
  }
  const addDurationVital = (vital) => {
    bufferApiCalls.add((startRumResult) => startRumResult.addDurationVital(vital));
  };
  const strategy = {
    init(initConfiguration, publicApi) {
      if (!initConfiguration) {
        display.error("Missing configuration");
        return;
      }
      initFeatureFlags(initConfiguration.enableExperimentalFeatures);
      cachedInitConfiguration = initConfiguration;
      if (ignoreInitIfSyntheticsWillInjectRum && willSyntheticsInjectRum()) {
        return;
      }
      callPluginsMethod(initConfiguration.plugins, "onInit", { initConfiguration, publicApi });
      if (initConfiguration.remoteConfigurationId) {
        fetchAndApplyRemoteConfiguration(initConfiguration, doInit);
      } else {
        doInit(initConfiguration);
      }
    },
    get initConfiguration() {
      return cachedInitConfiguration;
    },
    getInternalContext: noop,
    stopSession: noop,
    addTiming(name, time = timeStampNow()) {
      bufferApiCalls.add((startRumResult) => startRumResult.addTiming(name, time));
    },
    startView(options, startClocks = clocksNow()) {
      const callback = (startRumResult) => {
        startRumResult.startView(options, startClocks);
      };
      bufferApiCalls.add(callback);
      if (!firstStartViewCall) {
        firstStartViewCall = { options, callback };
        tryStartRum();
      }
    },
    setViewName(name) {
      bufferApiCalls.add((startRumResult) => startRumResult.setViewName(name));
    },
    // View context APIs
    setViewContext(context) {
      bufferApiCalls.add((startRumResult) => startRumResult.setViewContext(context));
    },
    setViewContextProperty(key, value) {
      bufferApiCalls.add((startRumResult) => startRumResult.setViewContextProperty(key, value));
    },
    getViewContext: () => emptyContext,
    globalContext,
    userContext,
    accountContext,
    addAction(action) {
      bufferApiCalls.add((startRumResult) => startRumResult.addAction(action));
    },
    addError(providedError) {
      bufferApiCalls.add((startRumResult) => startRumResult.addError(providedError));
    },
    addFeatureFlagEvaluation(key, value) {
      bufferApiCalls.add((startRumResult) => startRumResult.addFeatureFlagEvaluation(key, value));
    },
    startDurationVital(name, options) {
      return startDurationVital(customVitalsState, name, options);
    },
    stopDurationVital(name, options) {
      stopDurationVital(addDurationVital, customVitalsState, name, options);
    },
    addDurationVital
  };
  return strategy;
}
function overrideInitConfigurationForBridge(initConfiguration) {
  var _a, _b;
  return {
    ...initConfiguration,
    applicationId: "00000000-aaaa-0000-aaaa-000000000000",
    clientToken: "empty",
    sessionSampleRate: 100,
    defaultPrivacyLevel: (_a = initConfiguration.defaultPrivacyLevel) !== null && _a !== void 0 ? _a : (_b = getEventBridge()) === null || _b === void 0 ? void 0 : _b.getPrivacyLevel()
  };
}
function bufferContextCalls(preStartContextManager, name, bufferApiCalls) {
  preStartContextManager.changeObservable.subscribe(() => {
    const context = preStartContextManager.getContext();
    bufferApiCalls.add((startRumResult) => startRumResult[name].setContext(context));
  });
}

// node_modules/@datadog/browser-rum-core/esm/boot/rumPublicApi.js
function makeRumPublicApi(startRumImpl, recorderApi, profilerApi, options = {}) {
  const trackingConsentState = createTrackingConsentState();
  const customVitalsState = createCustomVitalsState();
  let strategy = createPreStartStrategy(options, trackingConsentState, customVitalsState, (configuration, deflateWorker, initialViewOptions) => {
    const startRumResult = startRumImpl(configuration, recorderApi, profilerApi, initialViewOptions, deflateWorker && options.createDeflateEncoder ? (streamId) => options.createDeflateEncoder(configuration, deflateWorker, streamId) : createIdentityEncoder, trackingConsentState, customVitalsState, options.sdkName);
    recorderApi.onRumStart(startRumResult.lifeCycle, configuration, startRumResult.session, startRumResult.viewHistory, deflateWorker);
    profilerApi.onRumStart(startRumResult.lifeCycle, configuration, startRumResult.session, startRumResult.viewHistory);
    strategy = createPostStartStrategy(strategy, startRumResult);
    callPluginsMethod(configuration.plugins, "onRumStart", { strategy });
    return startRumResult;
  });
  const getStrategy = () => strategy;
  const startView = monitor((options2) => {
    const sanitizedOptions = typeof options2 === "object" ? options2 : { name: options2 };
    strategy.startView(sanitizedOptions);
    addTelemetryUsage({ feature: "start-view" });
  });
  const rumPublicApi = makePublicApi({
    init: monitor((initConfiguration) => {
      strategy.init(initConfiguration, rumPublicApi);
    }),
    setTrackingConsent: monitor((trackingConsent) => {
      trackingConsentState.update(trackingConsent);
      addTelemetryUsage({ feature: "set-tracking-consent", tracking_consent: trackingConsent });
    }),
    setViewName: monitor((name) => {
      strategy.setViewName(name);
      addTelemetryUsage({ feature: "set-view-name" });
    }),
    setViewContext: monitor((context) => {
      strategy.setViewContext(context);
      addTelemetryUsage({ feature: "set-view-context" });
    }),
    setViewContextProperty: monitor((key, value) => {
      strategy.setViewContextProperty(key, value);
      addTelemetryUsage({ feature: "set-view-context-property" });
    }),
    getViewContext: monitor(() => {
      addTelemetryUsage({ feature: "set-view-context-property" });
      return strategy.getViewContext();
    }),
    getInternalContext: monitor((startTime) => strategy.getInternalContext(startTime)),
    getInitConfiguration: monitor(() => deepClone(strategy.initConfiguration)),
    addAction: (name, context) => {
      const handlingStack = createHandlingStack("action");
      callMonitored(() => {
        strategy.addAction({
          name: sanitize(name),
          context: sanitize(context),
          startClocks: clocksNow(),
          type: "custom",
          handlingStack
        });
        addTelemetryUsage({ feature: "add-action" });
      });
    },
    addError: (error, context) => {
      const handlingStack = createHandlingStack("error");
      callMonitored(() => {
        strategy.addError({
          error,
          // Do not sanitize error here, it is needed unserialized by computeRawError()
          handlingStack,
          context: sanitize(context),
          startClocks: clocksNow()
        });
        addTelemetryUsage({ feature: "add-error" });
      });
    },
    addTiming: monitor((name, time) => {
      strategy.addTiming(sanitize(name), time);
    }),
    setGlobalContext: defineContextMethod(getStrategy, CustomerContextKey.globalContext, ContextManagerMethod.setContext, "set-global-context"),
    getGlobalContext: defineContextMethod(getStrategy, CustomerContextKey.globalContext, ContextManagerMethod.getContext, "get-global-context"),
    setGlobalContextProperty: defineContextMethod(getStrategy, CustomerContextKey.globalContext, ContextManagerMethod.setContextProperty, "set-global-context-property"),
    removeGlobalContextProperty: defineContextMethod(getStrategy, CustomerContextKey.globalContext, ContextManagerMethod.removeContextProperty, "remove-global-context-property"),
    clearGlobalContext: defineContextMethod(getStrategy, CustomerContextKey.globalContext, ContextManagerMethod.clearContext, "clear-global-context"),
    setUser: defineContextMethod(getStrategy, CustomerContextKey.userContext, ContextManagerMethod.setContext, "set-user"),
    getUser: defineContextMethod(getStrategy, CustomerContextKey.userContext, ContextManagerMethod.getContext, "get-user"),
    setUserProperty: defineContextMethod(getStrategy, CustomerContextKey.userContext, ContextManagerMethod.setContextProperty, "set-user-property"),
    removeUserProperty: defineContextMethod(getStrategy, CustomerContextKey.userContext, ContextManagerMethod.removeContextProperty, "remove-user-property"),
    clearUser: defineContextMethod(getStrategy, CustomerContextKey.userContext, ContextManagerMethod.clearContext, "clear-user"),
    setAccount: defineContextMethod(getStrategy, CustomerContextKey.accountContext, ContextManagerMethod.setContext, "set-account"),
    getAccount: defineContextMethod(getStrategy, CustomerContextKey.accountContext, ContextManagerMethod.getContext, "get-account"),
    setAccountProperty: defineContextMethod(getStrategy, CustomerContextKey.accountContext, ContextManagerMethod.setContextProperty, "set-account-property"),
    removeAccountProperty: defineContextMethod(getStrategy, CustomerContextKey.accountContext, ContextManagerMethod.removeContextProperty, "remove-account-property"),
    clearAccount: defineContextMethod(getStrategy, CustomerContextKey.accountContext, ContextManagerMethod.clearContext, "clear-account"),
    startView,
    stopSession: monitor(() => {
      strategy.stopSession();
      addTelemetryUsage({ feature: "stop-session" });
    }),
    addFeatureFlagEvaluation: monitor((key, value) => {
      strategy.addFeatureFlagEvaluation(sanitize(key), sanitize(value));
      addTelemetryUsage({ feature: "add-feature-flag-evaluation" });
    }),
    getSessionReplayLink: monitor(() => recorderApi.getSessionReplayLink()),
    startSessionReplayRecording: monitor((options2) => {
      recorderApi.start(options2);
      addTelemetryUsage({ feature: "start-session-replay-recording", force: options2 && options2.force });
    }),
    stopSessionReplayRecording: monitor(() => recorderApi.stop()),
    addDurationVital: monitor((name, options2) => {
      addTelemetryUsage({ feature: "add-duration-vital" });
      strategy.addDurationVital({
        name: sanitize(name),
        type: "duration",
        startClocks: timeStampToClocks(options2.startTime),
        duration: options2.duration,
        context: sanitize(options2 && options2.context),
        description: sanitize(options2 && options2.description)
      });
    }),
    startDurationVital: monitor((name, options2) => {
      addTelemetryUsage({ feature: "start-duration-vital" });
      return strategy.startDurationVital(sanitize(name), {
        context: sanitize(options2 && options2.context),
        description: sanitize(options2 && options2.description)
      });
    }),
    stopDurationVital: monitor((nameOrRef, options2) => {
      addTelemetryUsage({ feature: "stop-duration-vital" });
      strategy.stopDurationVital(typeof nameOrRef === "string" ? sanitize(nameOrRef) : nameOrRef, {
        context: sanitize(options2 && options2.context),
        description: sanitize(options2 && options2.description)
      });
    })
  });
  return rumPublicApi;
}
function createPostStartStrategy(preStartStrategy, startRumResult) {
  return {
    init: (initConfiguration) => {
      displayAlreadyInitializedError("DD_RUM", initConfiguration);
    },
    initConfiguration: preStartStrategy.initConfiguration,
    ...startRumResult
  };
}

// node_modules/@datadog/browser-rum-core/esm/domain/resource/resourceUtils.js
var FAKE_INITIAL_DOCUMENT = "initial_document";
var RESOURCE_TYPES = [
  ["document", (initiatorType) => FAKE_INITIAL_DOCUMENT === initiatorType],
  ["xhr", (initiatorType) => "xmlhttprequest" === initiatorType],
  ["fetch", (initiatorType) => "fetch" === initiatorType],
  ["beacon", (initiatorType) => "beacon" === initiatorType],
  ["css", (_, path) => /\.css$/i.test(path)],
  ["js", (_, path) => /\.js$/i.test(path)],
  [
    "image",
    (initiatorType, path) => ["image", "img", "icon"].includes(initiatorType) || /\.(gif|jpg|jpeg|tiff|png|svg|ico)$/i.exec(path) !== null
  ],
  ["font", (_, path) => /\.(woff|eot|woff2|ttf)$/i.exec(path) !== null],
  [
    "media",
    (initiatorType, path) => ["audio", "video"].includes(initiatorType) || /\.(mp3|mp4)$/i.exec(path) !== null
  ]
];
function computeResourceEntryType(entry) {
  const url = entry.name;
  if (!isValidUrl(url)) {
    addTelemetryDebug(`Failed to construct URL for "${entry.name}"`);
    return "other";
  }
  const path = getPathName(url);
  for (const [type, isType] of RESOURCE_TYPES) {
    if (isType(entry.initiatorType, path)) {
      return type;
    }
  }
  return "other";
}
function areInOrder(...numbers) {
  for (let i = 1; i < numbers.length; i += 1) {
    if (numbers[i - 1] > numbers[i]) {
      return false;
    }
  }
  return true;
}
function isResourceEntryRequestType(entry) {
  return entry.initiatorType === "xmlhttprequest" || entry.initiatorType === "fetch";
}
function computeResourceEntryDuration(entry) {
  const { duration, startTime, responseEnd } = entry;
  if (duration === 0 && startTime < responseEnd) {
    return elapsed(startTime, responseEnd);
  }
  return duration;
}
function computeResourceEntryDetails(entry) {
  if (!hasValidResourceEntryTimings(entry)) {
    return void 0;
  }
  const { startTime, fetchStart, workerStart, redirectStart, redirectEnd, domainLookupStart, domainLookupEnd, connectStart, secureConnectionStart, connectEnd, requestStart, responseStart, responseEnd } = entry;
  const details = {
    download: formatTiming(startTime, responseStart, responseEnd),
    first_byte: formatTiming(startTime, requestStart, responseStart)
  };
  if (0 < workerStart && workerStart < fetchStart) {
    details.worker = formatTiming(startTime, workerStart, fetchStart);
  }
  if (fetchStart < connectEnd) {
    details.connect = formatTiming(startTime, connectStart, connectEnd);
    if (connectStart <= secureConnectionStart && secureConnectionStart <= connectEnd) {
      details.ssl = formatTiming(startTime, secureConnectionStart, connectEnd);
    }
  }
  if (fetchStart < domainLookupEnd) {
    details.dns = formatTiming(startTime, domainLookupStart, domainLookupEnd);
  }
  if (startTime < redirectEnd) {
    details.redirect = formatTiming(startTime, redirectStart, redirectEnd);
  }
  return details;
}
function hasValidResourceEntryDuration(entry) {
  return entry.duration >= 0;
}
function hasValidResourceEntryTimings(entry) {
  const areCommonTimingsInOrder = areInOrder(entry.startTime, entry.fetchStart, entry.domainLookupStart, entry.domainLookupEnd, entry.connectStart, entry.connectEnd, entry.requestStart, entry.responseStart, entry.responseEnd);
  const areRedirectionTimingsInOrder = hasRedirection(entry) ? areInOrder(entry.startTime, entry.redirectStart, entry.redirectEnd, entry.fetchStart) : true;
  return areCommonTimingsInOrder && areRedirectionTimingsInOrder;
}
function hasRedirection(entry) {
  return entry.redirectEnd > entry.startTime;
}
function formatTiming(origin, start, end) {
  if (origin <= start && start <= end) {
    return {
      duration: toServerDuration(elapsed(start, end)),
      start: toServerDuration(elapsed(origin, start))
    };
  }
}
function computeResourceEntryProtocol(entry) {
  return entry.nextHopProtocol === "" ? void 0 : entry.nextHopProtocol;
}
function computeResourceEntryDeliveryType(entry) {
  return entry.deliveryType === "" ? "other" : entry.deliveryType;
}
function computeResourceEntrySize(entry) {
  if (entry.startTime < entry.responseStart) {
    const { encodedBodySize, decodedBodySize, transferSize } = entry;
    return {
      size: decodedBodySize,
      encoded_body_size: encodedBodySize,
      decoded_body_size: decodedBodySize,
      transfer_size: transferSize
    };
  }
  return {
    size: void 0,
    encoded_body_size: void 0,
    decoded_body_size: void 0,
    transfer_size: void 0
  };
}
function isAllowedRequestUrl(url) {
  return url && (!isIntakeUrl(url) || isExperimentalFeatureEnabled(ExperimentalFeature.TRACK_INTAKE_REQUESTS));
}
var DATA_URL_REGEX = /data:(.+)?(;base64)?,/g;
var MAX_RESOURCE_VALUE_CHAR_LENGTH = 24e3;
function sanitizeIfLongDataUrl(url, lengthLimit = MAX_RESOURCE_VALUE_CHAR_LENGTH) {
  if (url.length <= lengthLimit || !url.startsWith("data:")) {
    return url;
  }
  const dataUrlMatchArray = url.substring(0, 100).match(DATA_URL_REGEX);
  if (!dataUrlMatchArray) {
    return url;
  }
  return `${dataUrlMatchArray[0]}[...]`;
}

// node_modules/@datadog/browser-rum-core/esm/browser/firstInputPolyfill.js
function retrieveFirstInputTiming(configuration, callback) {
  const startTimeStamp = dateNow();
  let timingSent = false;
  const { stop: removeEventListeners } = addEventListeners(configuration, window, [
    "click",
    "mousedown",
    "keydown",
    "touchstart",
    "pointerdown"
    /* DOM_EVENT.POINTER_DOWN */
  ], (evt) => {
    if (!evt.cancelable) {
      return;
    }
    const timing = {
      entryType: "first-input",
      processingStart: relativeNow(),
      processingEnd: relativeNow(),
      startTime: evt.timeStamp,
      duration: 0,
      // arbitrary value to avoid nullable duration and simplify INP logic
      name: "",
      cancelable: false,
      target: null,
      toJSON: () => ({})
    };
    if (evt.type === "pointerdown") {
      sendTimingIfPointerIsNotCancelled(configuration, timing);
    } else {
      sendTiming(timing);
    }
  }, { passive: true, capture: true });
  return { stop: removeEventListeners };
  function sendTimingIfPointerIsNotCancelled(configuration2, timing) {
    addEventListeners(configuration2, window, [
      "pointerup",
      "pointercancel"
      /* DOM_EVENT.POINTER_CANCEL */
    ], (event) => {
      if (event.type === "pointerup") {
        sendTiming(timing);
      }
    }, { once: true });
  }
  function sendTiming(timing) {
    if (!timingSent) {
      timingSent = true;
      removeEventListeners();
      const delay = timing.processingStart - timing.startTime;
      if (delay >= 0 && delay < dateNow() - startTimeStamp) {
        callback(timing);
      }
    }
  }
}

// node_modules/@datadog/browser-rum-core/esm/browser/performanceObservable.js
var RumPerformanceEntryType;
(function(RumPerformanceEntryType2) {
  RumPerformanceEntryType2["EVENT"] = "event";
  RumPerformanceEntryType2["FIRST_INPUT"] = "first-input";
  RumPerformanceEntryType2["LARGEST_CONTENTFUL_PAINT"] = "largest-contentful-paint";
  RumPerformanceEntryType2["LAYOUT_SHIFT"] = "layout-shift";
  RumPerformanceEntryType2["LONG_TASK"] = "longtask";
  RumPerformanceEntryType2["LONG_ANIMATION_FRAME"] = "long-animation-frame";
  RumPerformanceEntryType2["NAVIGATION"] = "navigation";
  RumPerformanceEntryType2["PAINT"] = "paint";
  RumPerformanceEntryType2["RESOURCE"] = "resource";
  RumPerformanceEntryType2["VISIBILITY_STATE"] = "visibility-state";
})(RumPerformanceEntryType || (RumPerformanceEntryType = {}));
function createPerformanceObservable(configuration, options) {
  return new Observable((observable) => {
    if (!window.PerformanceObserver) {
      return;
    }
    const handlePerformanceEntries = (entries) => {
      const rumPerformanceEntries = filterRumPerformanceEntries(entries);
      if (rumPerformanceEntries.length > 0) {
        observable.notify(rumPerformanceEntries);
      }
    };
    let timeoutId;
    let isObserverInitializing = true;
    const observer2 = new PerformanceObserver(monitor((entries) => {
      if (isObserverInitializing) {
        timeoutId = setTimeout(() => handlePerformanceEntries(entries.getEntries()));
      } else {
        handlePerformanceEntries(entries.getEntries());
      }
    }));
    try {
      observer2.observe(options);
    } catch (_a) {
      const fallbackSupportedEntryTypes = [
        RumPerformanceEntryType.RESOURCE,
        RumPerformanceEntryType.NAVIGATION,
        RumPerformanceEntryType.LONG_TASK,
        RumPerformanceEntryType.PAINT
      ];
      if (fallbackSupportedEntryTypes.includes(options.type)) {
        if (options.buffered) {
          timeoutId = setTimeout(() => handlePerformanceEntries(performance.getEntriesByType(options.type)));
        }
        try {
          observer2.observe({ entryTypes: [options.type] });
        } catch (_b) {
          return;
        }
      }
    }
    isObserverInitializing = false;
    manageResourceTimingBufferFull(configuration);
    let stopFirstInputTiming;
    if (!supportPerformanceTimingEvent(RumPerformanceEntryType.FIRST_INPUT) && options.type === RumPerformanceEntryType.FIRST_INPUT) {
      ;
      ({ stop: stopFirstInputTiming } = retrieveFirstInputTiming(configuration, (timing) => {
        handlePerformanceEntries([timing]);
      }));
    }
    return () => {
      observer2.disconnect();
      if (stopFirstInputTiming) {
        stopFirstInputTiming();
      }
      clearTimeout(timeoutId);
    };
  });
}
var resourceTimingBufferFullListener;
function manageResourceTimingBufferFull(configuration) {
  if (!resourceTimingBufferFullListener && supportPerformanceObject() && "addEventListener" in performance) {
    resourceTimingBufferFullListener = addEventListener(configuration, performance, "resourcetimingbufferfull", () => {
      performance.clearResourceTimings();
    });
  }
  return () => {
    resourceTimingBufferFullListener === null || resourceTimingBufferFullListener === void 0 ? void 0 : resourceTimingBufferFullListener.stop();
  };
}
function supportPerformanceObject() {
  return window.performance !== void 0 && "getEntries" in performance;
}
function supportPerformanceTimingEvent(entryType) {
  return window.PerformanceObserver && PerformanceObserver.supportedEntryTypes !== void 0 && PerformanceObserver.supportedEntryTypes.includes(entryType);
}
function filterRumPerformanceEntries(entries) {
  return entries.filter((entry) => !isForbiddenResource(entry));
}
function isForbiddenResource(entry) {
  return entry.entryType === RumPerformanceEntryType.RESOURCE && (!isAllowedRequestUrl(entry.name) || !hasValidResourceEntryDuration(entry));
}

// node_modules/@datadog/browser-rum-core/esm/browser/domMutationObservable.js
function createDOMMutationObservable() {
  const MutationObserver = getMutationObserverConstructor();
  return new Observable((observable) => {
    if (!MutationObserver) {
      return;
    }
    const observer2 = new MutationObserver(monitor((records) => observable.notify(records)));
    observer2.observe(document, {
      attributes: true,
      characterData: true,
      childList: true,
      subtree: true
    });
    return () => observer2.disconnect();
  });
}
function getMutationObserverConstructor() {
  let constructor;
  const browserWindow = window;
  if (browserWindow.Zone) {
    constructor = getZoneJsOriginalValue(browserWindow, "MutationObserver");
    if (browserWindow.MutationObserver && constructor === browserWindow.MutationObserver) {
      const patchedInstance = new browserWindow.MutationObserver(noop);
      const originalInstance = getZoneJsOriginalValue(patchedInstance, "originalInstance");
      constructor = originalInstance && originalInstance.constructor;
    }
  }
  if (!constructor) {
    constructor = browserWindow.MutationObserver;
  }
  return constructor;
}

// node_modules/@datadog/browser-rum-core/esm/browser/windowOpenObservable.js
function createWindowOpenObservable() {
  const observable = new Observable();
  const { stop } = instrumentMethod(window, "open", () => observable.notify());
  return { observable, stop };
}

// node_modules/@datadog/browser-rum-core/esm/domain/contexts/internalContext.js
function startInternalContext(applicationId, sessionManager, viewHistory, actionContexts, urlContexts) {
  return {
    get: (startTime) => {
      const viewContext = viewHistory.findView(startTime);
      const urlContext = urlContexts.findUrl(startTime);
      const session = sessionManager.findTrackedSession(startTime);
      if (session && viewContext && urlContext) {
        const actionId = actionContexts.findActionId(startTime);
        return {
          application_id: applicationId,
          session_id: session.id,
          user_action: actionId ? { id: actionId } : void 0,
          view: { id: viewContext.id, name: viewContext.name, referrer: urlContext.referrer, url: urlContext.url }
        };
      }
    }
  };
}

// node_modules/@datadog/browser-rum-core/esm/domain/lifeCycle.js
var LifeCycle = AbstractLifeCycle;

// node_modules/@datadog/browser-rum-core/esm/domain/contexts/viewHistory.js
var VIEW_CONTEXT_TIME_OUT_DELAY = SESSION_TIME_OUT_DELAY;
function startViewHistory(lifeCycle) {
  const viewValueHistory = createValueHistory({ expireDelay: VIEW_CONTEXT_TIME_OUT_DELAY });
  lifeCycle.subscribe(1, (view) => {
    viewValueHistory.add(buildViewHistoryEntry(view), view.startClocks.relative);
  });
  lifeCycle.subscribe(6, ({ endClocks }) => {
    viewValueHistory.closeActive(endClocks.relative);
  });
  lifeCycle.subscribe(3, (viewUpdate) => {
    const currentView = viewValueHistory.find(viewUpdate.startClocks.relative);
    if (!currentView) {
      return;
    }
    if (viewUpdate.name) {
      currentView.name = viewUpdate.name;
    }
    if (viewUpdate.context) {
      currentView.context = viewUpdate.context;
    }
    currentView.sessionIsActive = viewUpdate.sessionIsActive;
  });
  lifeCycle.subscribe(10, () => {
    viewValueHistory.reset();
  });
  function buildViewHistoryEntry(view) {
    return {
      service: view.service,
      version: view.version,
      context: view.context,
      id: view.id,
      name: view.name,
      startClocks: view.startClocks
    };
  }
  return {
    findView: (startTime) => viewValueHistory.find(startTime),
    stop: () => {
      viewValueHistory.stop();
    }
  };
}

// node_modules/@datadog/browser-rum-core/esm/domain/requestCollection.js
var nextRequestIndex = 1;
function startRequestCollection(lifeCycle, configuration, sessionManager, userContext, accountContext) {
  const tracer = startTracer(configuration, sessionManager, userContext, accountContext);
  trackXhr(lifeCycle, configuration, tracer);
  trackFetch(lifeCycle, tracer);
}
function trackXhr(lifeCycle, configuration, tracer) {
  const subscription = initXhrObservable(configuration).subscribe((rawContext) => {
    const context = rawContext;
    if (!isAllowedRequestUrl(context.url)) {
      return;
    }
    switch (context.state) {
      case "start":
        tracer.traceXhr(context, context.xhr);
        context.requestIndex = getNextRequestIndex();
        lifeCycle.notify(7, {
          requestIndex: context.requestIndex,
          url: context.url
        });
        break;
      case "complete":
        tracer.clearTracingIfNeeded(context);
        lifeCycle.notify(8, {
          duration: context.duration,
          method: context.method,
          requestIndex: context.requestIndex,
          spanId: context.spanId,
          startClocks: context.startClocks,
          status: context.status,
          traceId: context.traceId,
          traceSampled: context.traceSampled,
          type: "xhr",
          url: context.url,
          xhr: context.xhr,
          isAborted: context.isAborted,
          handlingStack: context.handlingStack
        });
        break;
    }
  });
  return { stop: () => subscription.unsubscribe() };
}
function trackFetch(lifeCycle, tracer) {
  const subscription = initFetchObservable().subscribe((rawContext) => {
    const context = rawContext;
    if (!isAllowedRequestUrl(context.url)) {
      return;
    }
    switch (context.state) {
      case "start":
        tracer.traceFetch(context);
        context.requestIndex = getNextRequestIndex();
        lifeCycle.notify(7, {
          requestIndex: context.requestIndex,
          url: context.url
        });
        break;
      case "resolve":
        waitForResponseToComplete(context, (duration) => {
          tracer.clearTracingIfNeeded(context);
          lifeCycle.notify(8, {
            duration,
            method: context.method,
            requestIndex: context.requestIndex,
            responseType: context.responseType,
            spanId: context.spanId,
            startClocks: context.startClocks,
            status: context.status,
            traceId: context.traceId,
            traceSampled: context.traceSampled,
            type: "fetch",
            url: context.url,
            response: context.response,
            init: context.init,
            input: context.input,
            isAborted: context.isAborted,
            handlingStack: context.handlingStack
          });
        });
        break;
    }
  });
  return { stop: () => subscription.unsubscribe() };
}
function getNextRequestIndex() {
  const result = nextRequestIndex;
  nextRequestIndex += 1;
  return result;
}
function waitForResponseToComplete(context, callback) {
  const clonedResponse = context.response && tryToClone(context.response);
  if (!clonedResponse || !clonedResponse.body) {
    callback(elapsed(context.startClocks.timeStamp, timeStampNow()));
  } else {
    readBytesFromStream(clonedResponse.body, () => {
      callback(elapsed(context.startClocks.timeStamp, timeStampNow()));
    }, {
      bytesLimit: Number.POSITIVE_INFINITY,
      collectStreamBody: false
    });
  }
}

// node_modules/@datadog/browser-rum-core/esm/domain/discardNegativeDuration.js
function discardNegativeDuration(duration) {
  return isNumber(duration) && duration < 0 ? void 0 : duration;
}

// node_modules/@datadog/browser-rum-core/esm/domain/trackEventCounts.js
function trackEventCounts({ lifeCycle, isChildEvent, onChange: callback = noop }) {
  const eventCounts = {
    errorCount: 0,
    longTaskCount: 0,
    resourceCount: 0,
    actionCount: 0,
    frustrationCount: 0
  };
  const subscription = lifeCycle.subscribe(13, (event) => {
    var _a;
    if (event.type === "view" || event.type === "vital" || !isChildEvent(event)) {
      return;
    }
    switch (event.type) {
      case "error":
        eventCounts.errorCount += 1;
        callback();
        break;
      case "action":
        eventCounts.actionCount += 1;
        if (event.action.frustration) {
          eventCounts.frustrationCount += event.action.frustration.type.length;
        }
        callback();
        break;
      case "long_task":
        eventCounts.longTaskCount += 1;
        callback();
        break;
      case "resource":
        if (!((_a = event._dd) === null || _a === void 0 ? void 0 : _a.discarded)) {
          eventCounts.resourceCount += 1;
          callback();
        }
        break;
    }
  });
  return {
    stop: () => {
      subscription.unsubscribe();
    },
    eventCounts
  };
}

// node_modules/@datadog/browser-rum-core/esm/browser/htmlDomUtils.js
function isTextNode(node) {
  return node.nodeType === Node.TEXT_NODE;
}
function isCommentNode(node) {
  return node.nodeType === Node.COMMENT_NODE;
}
function isElementNode(node) {
  return node.nodeType === Node.ELEMENT_NODE;
}
function isNodeShadowHost(node) {
  return isElementNode(node) && Boolean(node.shadowRoot);
}
function isNodeShadowRoot(node) {
  const shadowRoot = node;
  return !!shadowRoot.host && shadowRoot.nodeType === Node.DOCUMENT_FRAGMENT_NODE && isElementNode(shadowRoot.host);
}
function hasChildNodes(node) {
  return node.childNodes.length > 0 || isNodeShadowHost(node);
}
function forEachChildNodes(node, callback) {
  let child = node.firstChild;
  while (child) {
    callback(child);
    child = child.nextSibling;
  }
  if (isNodeShadowHost(node)) {
    callback(node.shadowRoot);
  }
}
function getParentNode(node) {
  return isNodeShadowRoot(node) ? node.host : node.parentNode;
}

// node_modules/@datadog/browser-rum-core/esm/domain/waitPageActivityEnd.js
var PAGE_ACTIVITY_VALIDATION_DELAY = 100;
var PAGE_ACTIVITY_END_DELAY = 100;
var EXCLUDED_MUTATIONS_ATTRIBUTE = "data-dd-excluded-activity-mutations";
function waitPageActivityEnd(lifeCycle, domMutationObservable, windowOpenObservable, configuration, pageActivityEndCallback, maxDuration) {
  const pageActivityObservable = createPageActivityObservable(lifeCycle, domMutationObservable, windowOpenObservable, configuration);
  return doWaitPageActivityEnd(pageActivityObservable, pageActivityEndCallback, maxDuration);
}
function doWaitPageActivityEnd(pageActivityObservable, pageActivityEndCallback, maxDuration) {
  let pageActivityEndTimeoutId;
  let hasCompleted = false;
  const validationTimeoutId = setTimeout(monitor(() => complete({ hadActivity: false })), PAGE_ACTIVITY_VALIDATION_DELAY);
  const maxDurationTimeoutId = maxDuration !== void 0 ? setTimeout(monitor(() => complete({ hadActivity: true, end: timeStampNow() })), maxDuration) : void 0;
  const pageActivitySubscription = pageActivityObservable.subscribe(({ isBusy }) => {
    clearTimeout(validationTimeoutId);
    clearTimeout(pageActivityEndTimeoutId);
    const lastChangeTime = timeStampNow();
    if (!isBusy) {
      pageActivityEndTimeoutId = setTimeout(monitor(() => complete({ hadActivity: true, end: lastChangeTime })), PAGE_ACTIVITY_END_DELAY);
    }
  });
  const stop = () => {
    hasCompleted = true;
    clearTimeout(validationTimeoutId);
    clearTimeout(pageActivityEndTimeoutId);
    clearTimeout(maxDurationTimeoutId);
    pageActivitySubscription.unsubscribe();
  };
  function complete(event) {
    if (hasCompleted) {
      return;
    }
    stop();
    pageActivityEndCallback(event);
  }
  return { stop };
}
function createPageActivityObservable(lifeCycle, domMutationObservable, windowOpenObservable, configuration) {
  return new Observable((observable) => {
    const subscriptions = [];
    let firstRequestIndex;
    let pendingRequestsCount = 0;
    subscriptions.push(domMutationObservable.subscribe((mutations) => {
      if (!mutations.every(isExcludedMutation)) {
        notifyPageActivity();
      }
    }), windowOpenObservable.subscribe(notifyPageActivity), createPerformanceObservable(configuration, { type: RumPerformanceEntryType.RESOURCE }).subscribe((entries) => {
      if (entries.some((entry) => !isExcludedUrl(configuration, entry.name))) {
        notifyPageActivity();
      }
    }), lifeCycle.subscribe(7, (startEvent) => {
      if (isExcludedUrl(configuration, startEvent.url)) {
        return;
      }
      if (firstRequestIndex === void 0) {
        firstRequestIndex = startEvent.requestIndex;
      }
      pendingRequestsCount += 1;
      notifyPageActivity();
    }), lifeCycle.subscribe(8, (request) => {
      if (isExcludedUrl(configuration, request.url) || firstRequestIndex === void 0 || // If the request started before the tracking start, ignore it
      request.requestIndex < firstRequestIndex) {
        return;
      }
      pendingRequestsCount -= 1;
      notifyPageActivity();
    }));
    return () => {
      subscriptions.forEach((s) => s.unsubscribe());
    };
    function notifyPageActivity() {
      observable.notify({ isBusy: pendingRequestsCount > 0 });
    }
  });
}
function isExcludedUrl(configuration, requestUrl) {
  return matchList(configuration.excludedActivityUrls, requestUrl);
}
function isExcludedMutation(mutation) {
  const targetElement = mutation.type === "characterData" ? mutation.target.parentElement : mutation.target;
  return Boolean(targetElement && isElementNode(targetElement) && targetElement.matches(`[${EXCLUDED_MUTATIONS_ATTRIBUTE}], [${EXCLUDED_MUTATIONS_ATTRIBUTE}] *`));
}

// node_modules/@datadog/browser-rum-core/esm/domain/privacy.js
var NodePrivacyLevel = {
  IGNORE: "ignore",
  HIDDEN: "hidden",
  ALLOW: DefaultPrivacyLevel.ALLOW,
  MASK: DefaultPrivacyLevel.MASK,
  MASK_USER_INPUT: DefaultPrivacyLevel.MASK_USER_INPUT
};
var PRIVACY_ATTR_NAME = "data-dd-privacy";
var PRIVACY_ATTR_VALUE_HIDDEN = "hidden";
var PRIVACY_CLASS_PREFIX = "dd-privacy-";
var CENSORED_STRING_MARK = "***";
var CENSORED_IMG_MARK = "data:image/gif;base64,R0lGODlhAQABAIAAAMLCwgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==";
var FORM_PRIVATE_TAG_NAMES = {
  INPUT: true,
  OUTPUT: true,
  TEXTAREA: true,
  SELECT: true,
  OPTION: true,
  DATALIST: true,
  OPTGROUP: true
};
var TEXT_MASKING_CHAR = "x";
function getNodePrivacyLevel(node, defaultPrivacyLevel, cache) {
  if (cache && cache.has(node)) {
    return cache.get(node);
  }
  const parentNode = getParentNode(node);
  const parentNodePrivacyLevel = parentNode ? getNodePrivacyLevel(parentNode, defaultPrivacyLevel, cache) : defaultPrivacyLevel;
  const selfNodePrivacyLevel = getNodeSelfPrivacyLevel(node);
  const nodePrivacyLevel = reducePrivacyLevel(selfNodePrivacyLevel, parentNodePrivacyLevel);
  if (cache) {
    cache.set(node, nodePrivacyLevel);
  }
  return nodePrivacyLevel;
}
function reducePrivacyLevel(childPrivacyLevel, parentNodePrivacyLevel) {
  switch (parentNodePrivacyLevel) {
    // These values cannot be overridden
    case NodePrivacyLevel.HIDDEN:
    case NodePrivacyLevel.IGNORE:
      return parentNodePrivacyLevel;
  }
  switch (childPrivacyLevel) {
    case NodePrivacyLevel.ALLOW:
    case NodePrivacyLevel.MASK:
    case NodePrivacyLevel.MASK_USER_INPUT:
    case NodePrivacyLevel.HIDDEN:
    case NodePrivacyLevel.IGNORE:
      return childPrivacyLevel;
    default:
      return parentNodePrivacyLevel;
  }
}
function getNodeSelfPrivacyLevel(node) {
  if (!isElementNode(node)) {
    return;
  }
  if (node.tagName === "BASE") {
    return NodePrivacyLevel.ALLOW;
  }
  if (node.tagName === "INPUT") {
    const inputElement = node;
    if (inputElement.type === "password" || inputElement.type === "email" || inputElement.type === "tel") {
      return NodePrivacyLevel.MASK;
    }
    if (inputElement.type === "hidden") {
      return NodePrivacyLevel.MASK;
    }
    const autocomplete = inputElement.getAttribute("autocomplete");
    if (autocomplete && (autocomplete.startsWith("cc-") || autocomplete.endsWith("-password"))) {
      return NodePrivacyLevel.MASK;
    }
  }
  if (node.matches(getPrivacySelector(NodePrivacyLevel.HIDDEN))) {
    return NodePrivacyLevel.HIDDEN;
  }
  if (node.matches(getPrivacySelector(NodePrivacyLevel.MASK))) {
    return NodePrivacyLevel.MASK;
  }
  if (node.matches(getPrivacySelector(NodePrivacyLevel.MASK_USER_INPUT))) {
    return NodePrivacyLevel.MASK_USER_INPUT;
  }
  if (node.matches(getPrivacySelector(NodePrivacyLevel.ALLOW))) {
    return NodePrivacyLevel.ALLOW;
  }
  if (shouldIgnoreElement(node)) {
    return NodePrivacyLevel.IGNORE;
  }
}
function shouldMaskNode(node, privacyLevel) {
  switch (privacyLevel) {
    case NodePrivacyLevel.MASK:
    case NodePrivacyLevel.HIDDEN:
    case NodePrivacyLevel.IGNORE:
      return true;
    case NodePrivacyLevel.MASK_USER_INPUT:
      return isTextNode(node) ? isFormElement(node.parentNode) : isFormElement(node);
    default:
      return false;
  }
}
function isFormElement(node) {
  if (!node || node.nodeType !== node.ELEMENT_NODE) {
    return false;
  }
  const element = node;
  if (element.tagName === "INPUT") {
    switch (element.type) {
      case "button":
      case "color":
      case "reset":
      case "submit":
        return false;
    }
  }
  return !!FORM_PRIVATE_TAG_NAMES[element.tagName];
}
var censorText = (text) => text.replace(/\S/g, TEXT_MASKING_CHAR);
function getTextContent(textNode, ignoreWhiteSpace, parentNodePrivacyLevel) {
  var _a;
  const parentTagName = (_a = textNode.parentElement) === null || _a === void 0 ? void 0 : _a.tagName;
  let textContent = textNode.textContent || "";
  if (ignoreWhiteSpace && !textContent.trim()) {
    return;
  }
  const nodePrivacyLevel = parentNodePrivacyLevel;
  const isScript = parentTagName === "SCRIPT";
  if (isScript) {
    textContent = CENSORED_STRING_MARK;
  } else if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {
    textContent = CENSORED_STRING_MARK;
  } else if (shouldMaskNode(textNode, nodePrivacyLevel)) {
    if (
      // Scrambling the child list breaks text nodes for DATALIST/SELECT/OPTGROUP
      parentTagName === "DATALIST" || parentTagName === "SELECT" || parentTagName === "OPTGROUP"
    ) {
      if (!textContent.trim()) {
        return;
      }
    } else if (parentTagName === "OPTION") {
      textContent = CENSORED_STRING_MARK;
    } else {
      textContent = censorText(textContent);
    }
  }
  return textContent;
}
function shouldIgnoreElement(element) {
  if (element.nodeName === "SCRIPT") {
    return true;
  }
  if (element.nodeName === "LINK") {
    const relAttribute = getLowerCaseAttribute("rel");
    return (
      // Link as script - Ignore only when rel=preload, modulepreload or prefetch
      /preload|prefetch/i.test(relAttribute) && getLowerCaseAttribute("as") === "script" || // Favicons
      relAttribute === "shortcut icon" || relAttribute === "icon"
    );
  }
  if (element.nodeName === "META") {
    const nameAttribute = getLowerCaseAttribute("name");
    const relAttribute = getLowerCaseAttribute("rel");
    const propertyAttribute = getLowerCaseAttribute("property");
    return (
      // Favicons
      /^msapplication-tile(image|color)$/.test(nameAttribute) || nameAttribute === "application-name" || relAttribute === "icon" || relAttribute === "apple-touch-icon" || relAttribute === "shortcut icon" || // Description
      nameAttribute === "keywords" || nameAttribute === "description" || // Social
      /^(og|twitter|fb):/.test(propertyAttribute) || /^(og|twitter):/.test(nameAttribute) || nameAttribute === "pinterest" || // Robots
      nameAttribute === "robots" || nameAttribute === "googlebot" || nameAttribute === "bingbot" || // Http headers. Ex: X-UA-Compatible, Content-Type, Content-Language, cache-control,
      // X-Translated-By
      element.hasAttribute("http-equiv") || // Authorship
      nameAttribute === "author" || nameAttribute === "generator" || nameAttribute === "framework" || nameAttribute === "publisher" || nameAttribute === "progid" || /^article:/.test(propertyAttribute) || /^product:/.test(propertyAttribute) || // Verification
      nameAttribute === "google-site-verification" || nameAttribute === "yandex-verification" || nameAttribute === "csrf-token" || nameAttribute === "p:domain_verify" || nameAttribute === "verify-v1" || nameAttribute === "verification" || nameAttribute === "shopify-checkout-api-token"
    );
  }
  function getLowerCaseAttribute(name) {
    return (element.getAttribute(name) || "").toLowerCase();
  }
  return false;
}
function getPrivacySelector(privacyLevel) {
  return `[${PRIVACY_ATTR_NAME}="${privacyLevel}"], .${PRIVACY_CLASS_PREFIX}${privacyLevel}`;
}

// node_modules/@datadog/browser-rum-core/esm/domain/action/getActionNameFromElement.js
var DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE = "data-dd-action-name";
var ACTION_NAME_PLACEHOLDER = "Masked Element";
function getActionNameFromElement(element, { enablePrivacyForActionName, actionNameAttribute: userProgrammaticAttribute }, nodePrivacyLevel) {
  const defaultActionName = getActionNameFromElementProgrammatically(element, DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE) || userProgrammaticAttribute && getActionNameFromElementProgrammatically(element, userProgrammaticAttribute);
  if (defaultActionName) {
    return {
      name: defaultActionName,
      nameSource: "custom_attribute"
      /* ActionNameSource.CUSTOM_ATTRIBUTE */
    };
  } else if (nodePrivacyLevel === NodePrivacyLevel.MASK) {
    return {
      name: ACTION_NAME_PLACEHOLDER,
      nameSource: "mask_placeholder"
      /* ActionNameSource.MASK_PLACEHOLDER */
    };
  }
  return getActionNameFromElementForStrategies(element, userProgrammaticAttribute, priorityStrategies, enablePrivacyForActionName) || getActionNameFromElementForStrategies(element, userProgrammaticAttribute, fallbackStrategies, enablePrivacyForActionName) || {
    name: "",
    nameSource: "blank"
    /* ActionNameSource.BLANK */
  };
}
function getActionNameFromElementProgrammatically(targetElement, programmaticAttribute) {
  const elementWithAttribute = targetElement.closest(`[${programmaticAttribute}]`);
  if (!elementWithAttribute) {
    return;
  }
  const name = elementWithAttribute.getAttribute(programmaticAttribute);
  return truncate(normalizeWhitespace(name.trim()));
}
var priorityStrategies = [
  // associated LABEL text
  (element, userProgrammaticAttribute) => {
    if ("labels" in element && element.labels && element.labels.length > 0) {
      return getActionNameFromTextualContent(element.labels[0], userProgrammaticAttribute);
    }
  },
  // INPUT button (and associated) value
  (element) => {
    if (element.nodeName === "INPUT") {
      const input = element;
      const type = input.getAttribute("type");
      if (type === "button" || type === "submit" || type === "reset") {
        return {
          name: input.value,
          nameSource: "text_content"
          /* ActionNameSource.TEXT_CONTENT */
        };
      }
    }
  },
  // BUTTON, LABEL or button-like element text
  (element, userProgrammaticAttribute, privacyEnabledActionName) => {
    if (element.nodeName === "BUTTON" || element.nodeName === "LABEL" || element.getAttribute("role") === "button") {
      return getActionNameFromTextualContent(element, userProgrammaticAttribute, privacyEnabledActionName);
    }
  },
  (element) => getActionNameFromStandardAttribute(element, "aria-label"),
  // associated element text designated by the aria-labelledby attribute
  (element, userProgrammaticAttribute, privacyEnabledActionName) => {
    const labelledByAttribute = element.getAttribute("aria-labelledby");
    if (labelledByAttribute) {
      return {
        name: labelledByAttribute.split(/\s+/).map((id) => getElementById(element, id)).filter((label) => Boolean(label)).map((element2) => getTextualContent(element2, userProgrammaticAttribute, privacyEnabledActionName)).join(" "),
        nameSource: "text_content"
      };
    }
  },
  (element) => getActionNameFromStandardAttribute(element, "alt"),
  (element) => getActionNameFromStandardAttribute(element, "name"),
  (element) => getActionNameFromStandardAttribute(element, "title"),
  (element) => getActionNameFromStandardAttribute(element, "placeholder"),
  // SELECT first OPTION text
  (element, userProgrammaticAttribute) => {
    if ("options" in element && element.options.length > 0) {
      return getActionNameFromTextualContent(element.options[0], userProgrammaticAttribute);
    }
  }
];
var fallbackStrategies = [
  (element, userProgrammaticAttribute, privacyEnabledActionName) => getActionNameFromTextualContent(element, userProgrammaticAttribute, privacyEnabledActionName)
];
var MAX_PARENTS_TO_CONSIDER = 10;
function getActionNameFromElementForStrategies(targetElement, userProgrammaticAttribute, strategies, privacyEnabledActionName) {
  let element = targetElement;
  let recursionCounter = 0;
  while (recursionCounter <= MAX_PARENTS_TO_CONSIDER && element && element.nodeName !== "BODY" && element.nodeName !== "HTML" && element.nodeName !== "HEAD") {
    for (const strategy of strategies) {
      const actionName = strategy(element, userProgrammaticAttribute, privacyEnabledActionName);
      if (actionName) {
        const { name, nameSource } = actionName;
        const trimmedName = name && name.trim();
        if (trimmedName) {
          return { name: truncate(normalizeWhitespace(trimmedName)), nameSource };
        }
      }
    }
    if (element.nodeName === "FORM") {
      break;
    }
    element = element.parentElement;
    recursionCounter += 1;
  }
}
function normalizeWhitespace(s) {
  return s.replace(/\s+/g, " ");
}
function truncate(s) {
  return s.length > 100 ? `${safeTruncate(s, 100)} [...]` : s;
}
function getElementById(refElement, id) {
  return refElement.ownerDocument ? refElement.ownerDocument.getElementById(id) : null;
}
function getActionNameFromStandardAttribute(element, attribute) {
  return {
    name: element.getAttribute(attribute) || "",
    nameSource: "standard_attribute"
  };
}
function getActionNameFromTextualContent(element, userProgrammaticAttribute, privacyEnabledActionName) {
  return {
    name: getTextualContent(element, userProgrammaticAttribute, privacyEnabledActionName) || "",
    nameSource: "text_content"
  };
}
function getTextualContent(element, userProgrammaticAttribute, privacyEnabledActionName) {
  if (element.isContentEditable) {
    return;
  }
  if ("innerText" in element) {
    let text = element.innerText;
    const removeTextFromElements = (query) => {
      const list = element.querySelectorAll(query);
      for (let index = 0; index < list.length; index += 1) {
        const element2 = list[index];
        if ("innerText" in element2) {
          const textToReplace = element2.innerText;
          if (textToReplace && textToReplace.trim().length > 0) {
            text = text.replace(textToReplace, "");
          }
        }
      }
    };
    removeTextFromElements(`[${DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE}]`);
    if (userProgrammaticAttribute) {
      removeTextFromElements(`[${userProgrammaticAttribute}]`);
    }
    if (privacyEnabledActionName) {
      removeTextFromElements(`${getPrivacySelector(NodePrivacyLevel.HIDDEN)}, ${getPrivacySelector(NodePrivacyLevel.MASK)}`);
    }
    return text;
  }
  return element.textContent;
}

// node_modules/@datadog/browser-rum-core/esm/domain/getSelectorFromElement.js
var STABLE_ATTRIBUTES = [
  DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE,
  // Common test attributes (list provided by google recorder)
  "data-testid",
  "data-test",
  "data-qa",
  "data-cy",
  "data-test-id",
  "data-qa-id",
  "data-testing",
  // FullStory decorator attributes:
  "data-component",
  "data-element",
  "data-source-file"
];
var GLOBALLY_UNIQUE_SELECTOR_GETTERS = [getStableAttributeSelector, getIDSelector];
var UNIQUE_AMONG_CHILDREN_SELECTOR_GETTERS = [
  getStableAttributeSelector,
  getClassSelector,
  getTagNameSelector
];
function getSelectorFromElement(targetElement, actionNameAttribute) {
  if (!targetElement.isConnected) {
    return;
  }
  let targetElementSelector;
  let currentElement = targetElement;
  while (currentElement && currentElement.nodeName !== "HTML") {
    const globallyUniqueSelector = findSelector(currentElement, GLOBALLY_UNIQUE_SELECTOR_GETTERS, isSelectorUniqueGlobally, actionNameAttribute, targetElementSelector);
    if (globallyUniqueSelector) {
      return globallyUniqueSelector;
    }
    const uniqueSelectorAmongChildren = findSelector(currentElement, UNIQUE_AMONG_CHILDREN_SELECTOR_GETTERS, isSelectorUniqueAmongSiblings, actionNameAttribute, targetElementSelector);
    targetElementSelector = uniqueSelectorAmongChildren || combineSelector(getPositionSelector(currentElement), targetElementSelector);
    currentElement = currentElement.parentElement;
  }
  return targetElementSelector;
}
function isGeneratedValue(value) {
  return /[0-9]/.test(value);
}
function getIDSelector(element) {
  if (element.id && !isGeneratedValue(element.id)) {
    return `#${CSS.escape(element.id)}`;
  }
}
function getClassSelector(element) {
  if (element.tagName === "BODY") {
    return;
  }
  const classList = element.classList;
  for (let i = 0; i < classList.length; i += 1) {
    const className = classList[i];
    if (isGeneratedValue(className)) {
      continue;
    }
    return `${CSS.escape(element.tagName)}.${CSS.escape(className)}`;
  }
}
function getTagNameSelector(element) {
  return CSS.escape(element.tagName);
}
function getStableAttributeSelector(element, actionNameAttribute) {
  if (actionNameAttribute) {
    const selector = getAttributeSelector(actionNameAttribute);
    if (selector) {
      return selector;
    }
  }
  for (const attributeName of STABLE_ATTRIBUTES) {
    const selector = getAttributeSelector(attributeName);
    if (selector) {
      return selector;
    }
  }
  function getAttributeSelector(attributeName) {
    if (element.hasAttribute(attributeName)) {
      return `${CSS.escape(element.tagName)}[${attributeName}="${CSS.escape(element.getAttribute(attributeName))}"]`;
    }
  }
}
function getPositionSelector(element) {
  let sibling = element.parentElement.firstElementChild;
  let elementIndex = 1;
  while (sibling && sibling !== element) {
    if (sibling.tagName === element.tagName) {
      elementIndex += 1;
    }
    sibling = sibling.nextElementSibling;
  }
  return `${CSS.escape(element.tagName)}:nth-of-type(${elementIndex})`;
}
function findSelector(element, selectorGetters, predicate, actionNameAttribute, childSelector) {
  for (const selectorGetter of selectorGetters) {
    const elementSelector = selectorGetter(element, actionNameAttribute);
    if (!elementSelector) {
      continue;
    }
    if (predicate(element, elementSelector, childSelector)) {
      return combineSelector(elementSelector, childSelector);
    }
  }
}
function isSelectorUniqueGlobally(element, elementSelector, childSelector) {
  return element.ownerDocument.querySelectorAll(combineSelector(elementSelector, childSelector)).length === 1;
}
function isSelectorUniqueAmongSiblings(currentElement, currentElementSelector, childSelector) {
  let isSiblingMatching;
  if (childSelector === void 0) {
    isSiblingMatching = (sibling2) => sibling2.matches(currentElementSelector);
  } else {
    const scopedSelector = combineSelector(`${currentElementSelector}:scope`, childSelector);
    isSiblingMatching = (sibling2) => sibling2.querySelector(scopedSelector) !== null;
  }
  const parent = currentElement.parentElement;
  let sibling = parent.firstElementChild;
  while (sibling) {
    if (sibling !== currentElement && isSiblingMatching(sibling)) {
      return false;
    }
    sibling = sibling.nextElementSibling;
  }
  return true;
}
function combineSelector(parent, child) {
  return child ? `${parent}>${child}` : parent;
}

// node_modules/@datadog/browser-rum-core/esm/domain/action/clickChain.js
var MAX_DURATION_BETWEEN_CLICKS = ONE_SECOND;
var MAX_DISTANCE_BETWEEN_CLICKS = 100;
function createClickChain(firstClick, onFinalize) {
  const bufferedClicks = [];
  let status = 0;
  let maxDurationBetweenClicksTimeoutId;
  appendClick(firstClick);
  function appendClick(click) {
    click.stopObservable.subscribe(tryFinalize);
    bufferedClicks.push(click);
    clearTimeout(maxDurationBetweenClicksTimeoutId);
    maxDurationBetweenClicksTimeoutId = setTimeout(dontAcceptMoreClick, MAX_DURATION_BETWEEN_CLICKS);
  }
  function tryFinalize() {
    if (status === 1 && bufferedClicks.every((click) => click.isStopped())) {
      status = 2;
      onFinalize(bufferedClicks);
    }
  }
  function dontAcceptMoreClick() {
    clearTimeout(maxDurationBetweenClicksTimeoutId);
    if (status === 0) {
      status = 1;
      tryFinalize();
    }
  }
  return {
    tryAppend: (click) => {
      if (status !== 0) {
        return false;
      }
      if (bufferedClicks.length > 0 && !areEventsSimilar(bufferedClicks[bufferedClicks.length - 1].event, click.event)) {
        dontAcceptMoreClick();
        return false;
      }
      appendClick(click);
      return true;
    },
    stop: () => {
      dontAcceptMoreClick();
    }
  };
}
function areEventsSimilar(first, second) {
  return first.target === second.target && mouseEventDistance(first, second) <= MAX_DISTANCE_BETWEEN_CLICKS && first.timeStamp - second.timeStamp <= MAX_DURATION_BETWEEN_CLICKS;
}
function mouseEventDistance(origin, other) {
  return Math.sqrt(Math.pow(origin.clientX - other.clientX, 2) + Math.pow(origin.clientY - other.clientY, 2));
}

// node_modules/@datadog/browser-rum-core/esm/domain/action/listenActionEvents.js
function listenActionEvents(configuration, { onPointerDown, onPointerUp }) {
  let selectionEmptyAtPointerDown;
  let userActivity = {
    selection: false,
    input: false,
    scroll: false
  };
  let clickContext;
  const listeners = [
    addEventListener(configuration, window, "pointerdown", (event) => {
      if (isValidPointerEvent(event)) {
        selectionEmptyAtPointerDown = isSelectionEmpty();
        userActivity = {
          selection: false,
          input: false,
          scroll: false
        };
        clickContext = onPointerDown(event);
      }
    }, { capture: true }),
    addEventListener(configuration, window, "selectionchange", () => {
      if (!selectionEmptyAtPointerDown || !isSelectionEmpty()) {
        userActivity.selection = true;
      }
    }, { capture: true }),
    addEventListener(configuration, window, "scroll", () => {
      userActivity.scroll = true;
    }, { capture: true, passive: true }),
    addEventListener(configuration, window, "pointerup", (event) => {
      if (isValidPointerEvent(event) && clickContext) {
        const localUserActivity = userActivity;
        onPointerUp(clickContext, event, () => localUserActivity);
        clickContext = void 0;
      }
    }, { capture: true }),
    addEventListener(configuration, window, "input", () => {
      userActivity.input = true;
    }, { capture: true })
  ];
  return {
    stop: () => {
      listeners.forEach((listener) => listener.stop());
    }
  };
}
function isSelectionEmpty() {
  const selection = window.getSelection();
  return !selection || selection.isCollapsed;
}
function isValidPointerEvent(event) {
  return event.target instanceof Element && // Only consider 'primary' pointer events for now. Multi-touch support could be implemented in
  // the future.
  event.isPrimary !== false;
}

// node_modules/@datadog/browser-rum-core/esm/domain/action/computeFrustration.js
var MIN_CLICKS_PER_SECOND_TO_CONSIDER_RAGE = 3;
function computeFrustration(clicks, rageClick) {
  if (isRage(clicks)) {
    rageClick.addFrustration(
      "rage_click"
      /* FrustrationType.RAGE_CLICK */
    );
    if (clicks.some(isDead)) {
      rageClick.addFrustration(
        "dead_click"
        /* FrustrationType.DEAD_CLICK */
      );
    }
    if (rageClick.hasError) {
      rageClick.addFrustration(
        "error_click"
        /* FrustrationType.ERROR_CLICK */
      );
    }
    return { isRage: true };
  }
  const hasSelectionChanged = clicks.some((click) => click.getUserActivity().selection);
  clicks.forEach((click) => {
    if (click.hasError) {
      click.addFrustration(
        "error_click"
        /* FrustrationType.ERROR_CLICK */
      );
    }
    if (isDead(click) && // Avoid considering clicks part of a double-click or triple-click selections as dead clicks
    !hasSelectionChanged) {
      click.addFrustration(
        "dead_click"
        /* FrustrationType.DEAD_CLICK */
      );
    }
  });
  return { isRage: false };
}
function isRage(clicks) {
  if (clicks.some((click) => click.getUserActivity().selection || click.getUserActivity().scroll)) {
    return false;
  }
  for (let i = 0; i < clicks.length - (MIN_CLICKS_PER_SECOND_TO_CONSIDER_RAGE - 1); i += 1) {
    if (clicks[i + MIN_CLICKS_PER_SECOND_TO_CONSIDER_RAGE - 1].event.timeStamp - clicks[i].event.timeStamp <= ONE_SECOND) {
      return true;
    }
  }
  return false;
}
var DEAD_CLICK_EXCLUDE_SELECTOR = (
  // inputs that don't trigger a meaningful event like "input" when clicked, including textual
  // inputs (using a negative selector is shorter here)
  'input:not([type="checkbox"]):not([type="radio"]):not([type="button"]):not([type="submit"]):not([type="reset"]):not([type="range"]),textarea,select,[contenteditable],[contenteditable] *,canvas,a[href],a[href] *'
);
function isDead(click) {
  if (click.hasPageActivity || click.getUserActivity().input || click.getUserActivity().scroll) {
    return false;
  }
  return !click.event.target.matches(DEAD_CLICK_EXCLUDE_SELECTOR);
}

// node_modules/@datadog/browser-rum-core/esm/domain/action/interactionSelectorCache.js
var CLICK_ACTION_MAX_DURATION = 10 * ONE_SECOND;
var interactionSelectorCache = /* @__PURE__ */ new Map();
function getInteractionSelector(relativeTimestamp) {
  const selector = interactionSelectorCache.get(relativeTimestamp);
  interactionSelectorCache.delete(relativeTimestamp);
  return selector;
}
function updateInteractionSelector(relativeTimestamp, selector) {
  interactionSelectorCache.set(relativeTimestamp, selector);
  interactionSelectorCache.forEach((_, relativeTimestamp2) => {
    if (elapsed(relativeTimestamp2, relativeNow()) > CLICK_ACTION_MAX_DURATION) {
      interactionSelectorCache.delete(relativeTimestamp2);
    }
  });
}

// node_modules/@datadog/browser-rum-core/esm/domain/action/trackClickActions.js
var ACTION_CONTEXT_TIME_OUT_DELAY = 5 * ONE_MINUTE;
function trackClickActions(lifeCycle, domMutationObservable, windowOpenObservable, configuration) {
  const history2 = createValueHistory({ expireDelay: ACTION_CONTEXT_TIME_OUT_DELAY });
  const stopObservable = new Observable();
  let currentClickChain;
  lifeCycle.subscribe(10, () => {
    history2.reset();
  });
  lifeCycle.subscribe(5, stopClickChain);
  lifeCycle.subscribe(11, (event) => {
    if (event.reason === PageExitReason.UNLOADING) {
      stopClickChain();
    }
  });
  const { stop: stopActionEventsListener } = listenActionEvents(configuration, {
    onPointerDown: (pointerDownEvent) => processPointerDown(configuration, lifeCycle, domMutationObservable, pointerDownEvent, windowOpenObservable),
    onPointerUp: ({ clickActionBase, hadActivityOnPointerDown }, startEvent, getUserActivity) => {
      startClickAction(configuration, lifeCycle, domMutationObservable, windowOpenObservable, history2, stopObservable, appendClickToClickChain, clickActionBase, startEvent, getUserActivity, hadActivityOnPointerDown);
    }
  });
  const actionContexts = {
    findActionId: (startTime) => history2.findAll(startTime)
  };
  return {
    stop: () => {
      stopClickChain();
      stopObservable.notify();
      stopActionEventsListener();
    },
    actionContexts
  };
  function appendClickToClickChain(click) {
    if (!currentClickChain || !currentClickChain.tryAppend(click)) {
      const rageClick = click.clone();
      currentClickChain = createClickChain(click, (clicks) => {
        finalizeClicks(clicks, rageClick);
      });
    }
  }
  function stopClickChain() {
    if (currentClickChain) {
      currentClickChain.stop();
    }
  }
}
function processPointerDown(configuration, lifeCycle, domMutationObservable, pointerDownEvent, windowOpenObservable) {
  const nodePrivacyLevel = configuration.enablePrivacyForActionName ? getNodePrivacyLevel(pointerDownEvent.target, configuration.defaultPrivacyLevel) : NodePrivacyLevel.ALLOW;
  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {
    return void 0;
  }
  const clickActionBase = computeClickActionBase(pointerDownEvent, nodePrivacyLevel, configuration);
  let hadActivityOnPointerDown = false;
  waitPageActivityEnd(
    lifeCycle,
    domMutationObservable,
    windowOpenObservable,
    configuration,
    (pageActivityEndEvent) => {
      hadActivityOnPointerDown = pageActivityEndEvent.hadActivity;
    },
    // We don't care about the activity duration, we just want to know whether an activity did happen
    // within the "validation delay" or not. Limit the duration so the callback is called sooner.
    PAGE_ACTIVITY_VALIDATION_DELAY
  );
  return { clickActionBase, hadActivityOnPointerDown: () => hadActivityOnPointerDown };
}
function startClickAction(configuration, lifeCycle, domMutationObservable, windowOpenObservable, history2, stopObservable, appendClickToClickChain, clickActionBase, startEvent, getUserActivity, hadActivityOnPointerDown) {
  var _a;
  const click = newClick(lifeCycle, history2, getUserActivity, clickActionBase, startEvent);
  appendClickToClickChain(click);
  const selector = (_a = clickActionBase === null || clickActionBase === void 0 ? void 0 : clickActionBase.target) === null || _a === void 0 ? void 0 : _a.selector;
  if (selector) {
    updateInteractionSelector(startEvent.timeStamp, selector);
  }
  const { stop: stopWaitPageActivityEnd } = waitPageActivityEnd(lifeCycle, domMutationObservable, windowOpenObservable, configuration, (pageActivityEndEvent) => {
    if (pageActivityEndEvent.hadActivity && pageActivityEndEvent.end < click.startClocks.timeStamp) {
      click.discard();
    } else {
      if (pageActivityEndEvent.hadActivity) {
        click.stop(pageActivityEndEvent.end);
      } else if (hadActivityOnPointerDown()) {
        click.stop(
          // using the click start as activity end, so the click will have some activity but its
          // duration will be 0 (as the activity started before the click start)
          click.startClocks.timeStamp
        );
      } else {
        click.stop();
      }
    }
  }, CLICK_ACTION_MAX_DURATION);
  const viewEndedSubscription = lifeCycle.subscribe(5, ({ endClocks }) => {
    click.stop(endClocks.timeStamp);
  });
  const stopSubscription = stopObservable.subscribe(() => {
    click.stop();
  });
  click.stopObservable.subscribe(() => {
    viewEndedSubscription.unsubscribe();
    stopWaitPageActivityEnd();
    stopSubscription.unsubscribe();
  });
}
function computeClickActionBase(event, nodePrivacyLevel, configuration) {
  const rect = event.target.getBoundingClientRect();
  const selector = getSelectorFromElement(event.target, configuration.actionNameAttribute);
  if (selector) {
    updateInteractionSelector(event.timeStamp, selector);
  }
  const actionName = getActionNameFromElement(event.target, configuration, nodePrivacyLevel);
  return {
    type: "click",
    target: {
      width: Math.round(rect.width),
      height: Math.round(rect.height),
      selector
    },
    position: {
      // Use clientX and Y because for SVG element offsetX and Y are relatives to the <svg> element
      x: Math.round(event.clientX - rect.left),
      y: Math.round(event.clientY - rect.top)
    },
    name: actionName.name,
    nameSource: actionName.nameSource
  };
}
function newClick(lifeCycle, history2, getUserActivity, clickActionBase, startEvent) {
  const id = generateUUID();
  const startClocks = clocksNow();
  const historyEntry = history2.add(id, startClocks.relative);
  const eventCountsSubscription = trackEventCounts({
    lifeCycle,
    isChildEvent: (event) => event.action !== void 0 && (Array.isArray(event.action.id) ? event.action.id.includes(id) : event.action.id === id)
  });
  let status = 0;
  let activityEndTime;
  const frustrationTypes = [];
  const stopObservable = new Observable();
  function stop(newActivityEndTime) {
    if (status !== 0) {
      return;
    }
    activityEndTime = newActivityEndTime;
    status = 1;
    if (activityEndTime) {
      historyEntry.close(getRelativeTime(activityEndTime));
    } else {
      historyEntry.remove();
    }
    eventCountsSubscription.stop();
    stopObservable.notify();
  }
  return {
    event: startEvent,
    stop,
    stopObservable,
    get hasError() {
      return eventCountsSubscription.eventCounts.errorCount > 0;
    },
    get hasPageActivity() {
      return activityEndTime !== void 0;
    },
    getUserActivity,
    addFrustration: (frustrationType) => {
      frustrationTypes.push(frustrationType);
    },
    startClocks,
    isStopped: () => status === 1 || status === 2,
    clone: () => newClick(lifeCycle, history2, getUserActivity, clickActionBase, startEvent),
    validate: (domEvents) => {
      stop();
      if (status !== 1) {
        return;
      }
      const { resourceCount, errorCount, longTaskCount } = eventCountsSubscription.eventCounts;
      const clickAction = {
        duration: activityEndTime && elapsed(startClocks.timeStamp, activityEndTime),
        startClocks,
        id,
        frustrationTypes,
        counts: {
          resourceCount,
          errorCount,
          longTaskCount
        },
        events: domEvents !== null && domEvents !== void 0 ? domEvents : [startEvent],
        event: startEvent,
        ...clickActionBase
      };
      lifeCycle.notify(0, clickAction);
      status = 2;
    },
    discard: () => {
      stop();
      status = 2;
    }
  };
}
function finalizeClicks(clicks, rageClick) {
  const { isRage: isRage2 } = computeFrustration(clicks, rageClick);
  if (isRage2) {
    clicks.forEach((click) => click.discard());
    rageClick.stop(timeStampNow());
    rageClick.validate(clicks.map((click) => click.event));
  } else {
    rageClick.discard();
    clicks.forEach((click) => click.validate());
  }
}

// node_modules/@datadog/browser-rum-core/esm/domain/action/actionCollection.js
function startActionCollection(lifeCycle, hooks, domMutationObservable, windowOpenObservable, configuration) {
  lifeCycle.subscribe(0, (action) => lifeCycle.notify(12, processAction(action)));
  hooks.register(0, ({ startTime, eventType }) => {
    if (eventType !== "error" && eventType !== "resource" && eventType !== "long_task") {
      return SKIPPED;
    }
    const actionId = actionContexts.findActionId(startTime);
    if (!actionId) {
      return SKIPPED;
    }
    return {
      type: eventType,
      action: { id: actionId }
    };
  });
  let actionContexts = { findActionId: noop };
  let stop = noop;
  if (configuration.trackUserInteractions) {
    ;
    ({ actionContexts, stop } = trackClickActions(lifeCycle, domMutationObservable, windowOpenObservable, configuration));
  }
  return {
    addAction: (action) => {
      lifeCycle.notify(12, processAction(action));
    },
    actionContexts,
    stop
  };
}
function processAction(action) {
  const autoActionProperties = isAutoAction(action) ? {
    action: {
      id: action.id,
      loading_time: discardNegativeDuration(toServerDuration(action.duration)),
      frustration: {
        type: action.frustrationTypes
      },
      error: {
        count: action.counts.errorCount
      },
      long_task: {
        count: action.counts.longTaskCount
      },
      resource: {
        count: action.counts.resourceCount
      }
    },
    _dd: {
      action: {
        target: action.target,
        position: action.position,
        name_source: action.nameSource
      }
    }
  } : void 0;
  const actionEvent = combine({
    action: { id: generateUUID(), target: { name: action.name }, type: action.type },
    date: action.startClocks.timeStamp,
    type: "action"
  }, autoActionProperties);
  const duration = isAutoAction(action) ? action.duration : void 0;
  const customerContext = !isAutoAction(action) ? action.context : void 0;
  const domainContext = isAutoAction(action) ? { events: action.events } : { handlingStack: action.handlingStack };
  return {
    customerContext,
    rawRumEvent: actionEvent,
    duration,
    startTime: action.startClocks.relative,
    domainContext
  };
}
function isAutoAction(action) {
  return action.type !== "custom";
}

// node_modules/@datadog/browser-rum-core/esm/domain/error/trackConsoleError.js
function trackConsoleError(errorObservable) {
  const subscription = initConsoleObservable([ConsoleApiName.error]).subscribe((consoleLog) => errorObservable.notify(consoleLog.error));
  return {
    stop: () => {
      subscription.unsubscribe();
    }
  };
}

// node_modules/@datadog/browser-rum-core/esm/domain/error/trackReportError.js
function trackReportError(configuration, errorObservable) {
  const subscription = initReportObservable(configuration, [
    RawReportType.cspViolation,
    RawReportType.intervention
  ]).subscribe((rawError) => errorObservable.notify(rawError));
  return {
    stop: () => {
      subscription.unsubscribe();
    }
  };
}

// node_modules/@datadog/browser-rum-core/esm/domain/error/errorCollection.js
function startErrorCollection(lifeCycle, configuration) {
  const errorObservable = new Observable();
  trackConsoleError(errorObservable);
  trackRuntimeError(errorObservable);
  trackReportError(configuration, errorObservable);
  errorObservable.subscribe((error) => lifeCycle.notify(14, { error }));
  return doStartErrorCollection(lifeCycle);
}
function doStartErrorCollection(lifeCycle) {
  lifeCycle.subscribe(14, ({ error, customerContext }) => {
    customerContext = combine(error.context, customerContext);
    lifeCycle.notify(12, {
      customerContext,
      ...processError(error)
    });
  });
  return {
    addError: ({ error, handlingStack, componentStack, startClocks, context: customerContext }) => {
      const rawError = computeRawError({
        originalError: error,
        handlingStack,
        componentStack,
        startClocks,
        nonErrorPrefix: "Provided",
        source: ErrorSource.CUSTOM,
        handling: "handled"
      });
      lifeCycle.notify(14, {
        customerContext,
        error: rawError
      });
    }
  };
}
function processError(error) {
  const rawRumEvent = {
    date: error.startClocks.timeStamp,
    error: {
      id: generateUUID(),
      message: error.message,
      source: error.source,
      stack: error.stack,
      handling_stack: error.handlingStack,
      component_stack: error.componentStack,
      type: error.type,
      handling: error.handling,
      causes: error.causes,
      source_type: "browser",
      fingerprint: error.fingerprint,
      csp: error.csp
    },
    type: "error"
  };
  const domainContext = {
    error: error.originalError,
    handlingStack: error.handlingStack
  };
  return {
    rawRumEvent,
    startTime: error.startClocks.relative,
    domainContext
  };
}

// node_modules/@datadog/browser-rum-core/esm/domain/resource/matchRequestResourceEntry.js
var alreadyMatchedEntries = /* @__PURE__ */ new WeakSet();
function matchRequestResourceEntry(request) {
  if (!performance || !("getEntriesByName" in performance)) {
    return;
  }
  const sameNameEntries = performance.getEntriesByName(request.url, "resource");
  if (!sameNameEntries.length || !("toJSON" in sameNameEntries[0])) {
    return;
  }
  const candidates = sameNameEntries.filter((entry) => !alreadyMatchedEntries.has(entry)).filter((entry) => hasValidResourceEntryDuration(entry) && hasValidResourceEntryTimings(entry)).filter((entry) => isBetween(entry, request.startClocks.relative, endTime({ startTime: request.startClocks.relative, duration: request.duration })));
  if (candidates.length === 1) {
    alreadyMatchedEntries.add(candidates[0]);
    return candidates[0].toJSON();
  }
  return;
}
function endTime(timing) {
  return addDuration(timing.startTime, timing.duration);
}
function isBetween(timing, start, end) {
  const errorMargin = 1;
  return timing.startTime >= start - errorMargin && endTime(timing) <= addDuration(end, errorMargin);
}

// node_modules/@datadog/browser-rum-core/esm/domain/tracing/getDocumentTraceId.js
var INITIAL_DOCUMENT_OUTDATED_TRACE_ID_THRESHOLD = 2 * ONE_MINUTE;
function getDocumentTraceId(document2) {
  const data = getDocumentTraceDataFromMeta(document2) || getDocumentTraceDataFromComment(document2);
  if (!data || data.traceTime <= dateNow() - INITIAL_DOCUMENT_OUTDATED_TRACE_ID_THRESHOLD) {
    return void 0;
  }
  return data.traceId;
}
function getDocumentTraceDataFromMeta(document2) {
  const traceIdMeta = document2.querySelector("meta[name=dd-trace-id]");
  const traceTimeMeta = document2.querySelector("meta[name=dd-trace-time]");
  return createDocumentTraceData(traceIdMeta && traceIdMeta.content, traceTimeMeta && traceTimeMeta.content);
}
function getDocumentTraceDataFromComment(document2) {
  const comment = findTraceComment(document2);
  if (!comment) {
    return void 0;
  }
  return createDocumentTraceData(findCommaSeparatedValue(comment, "trace-id"), findCommaSeparatedValue(comment, "trace-time"));
}
function createDocumentTraceData(traceId, rawTraceTime) {
  const traceTime = rawTraceTime && Number(rawTraceTime);
  if (!traceId || !traceTime) {
    return void 0;
  }
  return {
    traceId,
    traceTime
  };
}
function findTraceComment(document2) {
  for (let i = 0; i < document2.childNodes.length; i += 1) {
    const comment = getTraceCommentFromNode(document2.childNodes[i]);
    if (comment) {
      return comment;
    }
  }
  if (document2.body) {
    for (let i = document2.body.childNodes.length - 1; i >= 0; i -= 1) {
      const node = document2.body.childNodes[i];
      const comment = getTraceCommentFromNode(node);
      if (comment) {
        return comment;
      }
      if (!isTextNode(node)) {
        break;
      }
    }
  }
}
function getTraceCommentFromNode(node) {
  if (node && isCommentNode(node)) {
    const match = /^\s*DATADOG;(.*?)\s*$/.exec(node.data);
    if (match) {
      return match[1];
    }
  }
}

// node_modules/@datadog/browser-rum-core/esm/browser/performanceUtils.js
function getNavigationEntry() {
  if (supportPerformanceTimingEvent(RumPerformanceEntryType.NAVIGATION)) {
    const navigationEntry = performance.getEntriesByType(RumPerformanceEntryType.NAVIGATION)[0];
    if (navigationEntry) {
      return navigationEntry;
    }
  }
  const timings = computeTimingsFromDeprecatedPerformanceTiming();
  const entry = {
    entryType: RumPerformanceEntryType.NAVIGATION,
    initiatorType: "navigation",
    name: window.location.href,
    startTime: 0,
    duration: timings.loadEventEnd,
    decodedBodySize: 0,
    encodedBodySize: 0,
    transferSize: 0,
    workerStart: 0,
    toJSON: () => ({ ...entry, toJSON: void 0 }),
    ...timings
  };
  return entry;
}
function computeTimingsFromDeprecatedPerformanceTiming() {
  const result = {};
  const timing = performance.timing;
  for (const key in timing) {
    if (isNumber(timing[key])) {
      const numberKey = key;
      const timingElement = timing[numberKey];
      result[numberKey] = timingElement === 0 ? 0 : getRelativeTime(timingElement);
    }
  }
  return result;
}

// node_modules/@datadog/browser-rum-core/esm/domain/resource/retrieveInitialDocumentResourceTiming.js
function retrieveInitialDocumentResourceTiming(configuration, callback, getNavigationEntryImpl = getNavigationEntry) {
  runOnReadyState(configuration, "interactive", () => {
    const navigationEntry = getNavigationEntryImpl();
    const entry = Object.assign(navigationEntry.toJSON(), {
      entryType: RumPerformanceEntryType.RESOURCE,
      initiatorType: FAKE_INITIAL_DOCUMENT,
      // The ResourceTiming duration entry should be `responseEnd - startTime`. With
      // NavigationTiming entries, `startTime` is always 0, so set it to `responseEnd`.
      duration: navigationEntry.responseEnd,
      traceId: getDocumentTraceId(document),
      toJSON: () => ({ ...entry, toJSON: void 0 })
    });
    callback(entry);
  });
}

// node_modules/@datadog/browser-rum-core/esm/domain/resource/resourceCollection.js
function startResourceCollection(lifeCycle, configuration, pageStateHistory, taskQueue = createTaskQueue(), retrieveInitialDocumentResourceTimingImpl = retrieveInitialDocumentResourceTiming) {
  lifeCycle.subscribe(8, (request) => {
    handleResource(() => processRequest(request, configuration, pageStateHistory));
  });
  const performanceResourceSubscription = createPerformanceObservable(configuration, {
    type: RumPerformanceEntryType.RESOURCE,
    buffered: true
  }).subscribe((entries) => {
    for (const entry of entries) {
      if (!isResourceEntryRequestType(entry)) {
        handleResource(() => processResourceEntry(entry, configuration));
      }
    }
  });
  retrieveInitialDocumentResourceTimingImpl(configuration, (timing) => {
    handleResource(() => processResourceEntry(timing, configuration));
  });
  function handleResource(computeRawEvent) {
    taskQueue.push(() => {
      const rawEvent = computeRawEvent();
      if (rawEvent) {
        lifeCycle.notify(12, rawEvent);
      }
    });
  }
  return {
    stop: () => {
      performanceResourceSubscription.unsubscribe();
    }
  };
}
function processRequest(request, configuration, pageStateHistory) {
  const matchingTiming = matchRequestResourceEntry(request);
  const startClocks = matchingTiming ? relativeToClocks(matchingTiming.startTime) : request.startClocks;
  const tracingInfo = computeRequestTracingInfo(request, configuration);
  if (!configuration.trackResources && !tracingInfo) {
    return;
  }
  const type = request.type === "xhr" ? "xhr" : "fetch";
  const correspondingTimingOverrides = matchingTiming ? computeResourceEntryMetrics(matchingTiming) : void 0;
  const duration = matchingTiming ? computeResourceEntryDuration(matchingTiming) : computeRequestDuration(pageStateHistory, startClocks, request.duration);
  const resourceEvent = combine({
    date: startClocks.timeStamp,
    resource: {
      id: generateUUID(),
      type,
      duration: toServerDuration(duration),
      method: request.method,
      status_code: request.status,
      protocol: matchingTiming && computeResourceEntryProtocol(matchingTiming),
      url: sanitizeIfLongDataUrl(request.url),
      delivery_type: matchingTiming && computeResourceEntryDeliveryType(matchingTiming)
    },
    type: "resource",
    _dd: {
      discarded: !configuration.trackResources
    }
  }, tracingInfo, correspondingTimingOverrides);
  return {
    startTime: startClocks.relative,
    duration,
    rawRumEvent: resourceEvent,
    domainContext: {
      performanceEntry: matchingTiming,
      xhr: request.xhr,
      response: request.response,
      requestInput: request.input,
      requestInit: request.init,
      error: request.error,
      isAborted: request.isAborted,
      handlingStack: request.handlingStack
    }
  };
}
function processResourceEntry(entry, configuration) {
  const startClocks = relativeToClocks(entry.startTime);
  const tracingInfo = computeResourceEntryTracingInfo(entry, configuration);
  if (!configuration.trackResources && !tracingInfo) {
    return;
  }
  const type = computeResourceEntryType(entry);
  const entryMetrics = computeResourceEntryMetrics(entry);
  const duration = computeResourceEntryDuration(entry);
  const resourceEvent = combine({
    date: startClocks.timeStamp,
    resource: {
      id: generateUUID(),
      type,
      duration: toServerDuration(duration),
      url: entry.name,
      status_code: discardZeroStatus(entry.responseStatus),
      protocol: computeResourceEntryProtocol(entry),
      delivery_type: computeResourceEntryDeliveryType(entry)
    },
    type: "resource",
    _dd: {
      discarded: !configuration.trackResources
    }
  }, tracingInfo, entryMetrics);
  return {
    startTime: startClocks.relative,
    duration,
    rawRumEvent: resourceEvent,
    domainContext: {
      performanceEntry: entry
    }
  };
}
function computeResourceEntryMetrics(entry) {
  const { renderBlockingStatus } = entry;
  return {
    resource: {
      render_blocking_status: renderBlockingStatus,
      ...computeResourceEntrySize(entry),
      ...computeResourceEntryDetails(entry)
    }
  };
}
function computeRequestTracingInfo(request, configuration) {
  const hasBeenTraced = request.traceSampled && request.traceId && request.spanId;
  if (!hasBeenTraced) {
    return void 0;
  }
  return {
    _dd: {
      span_id: request.spanId.toString(),
      trace_id: request.traceId.toString(),
      rule_psr: configuration.rulePsr
    }
  };
}
function computeResourceEntryTracingInfo(entry, configuration) {
  const hasBeenTraced = entry.traceId;
  if (!hasBeenTraced) {
    return void 0;
  }
  return {
    _dd: {
      trace_id: entry.traceId,
      span_id: createSpanIdentifier().toString(),
      rule_psr: configuration.rulePsr
    }
  };
}
function computeRequestDuration(pageStateHistory, startClocks, duration) {
  return !pageStateHistory.wasInPageStateDuringPeriod("frozen", startClocks.relative, duration) ? duration : void 0;
}
function discardZeroStatus(statusCode) {
  return statusCode === 0 ? void 0 : statusCode;
}

// node_modules/@datadog/browser-rum-core/esm/domain/view/trackViewEventCounts.js
function trackViewEventCounts(lifeCycle, viewId, onChange) {
  const { stop, eventCounts } = trackEventCounts({
    lifeCycle,
    isChildEvent: (event) => event.view.id === viewId,
    onChange
  });
  return {
    stop,
    eventCounts
  };
}

// node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/trackFirstContentfulPaint.js
var FCP_MAXIMUM_DELAY = 10 * ONE_MINUTE;
function trackFirstContentfulPaint(configuration, firstHidden, callback) {
  const performanceSubscription = createPerformanceObservable(configuration, {
    type: RumPerformanceEntryType.PAINT,
    buffered: true
  }).subscribe((entries) => {
    const fcpEntry = entries.find((entry) => entry.name === "first-contentful-paint" && entry.startTime < firstHidden.timeStamp && entry.startTime < FCP_MAXIMUM_DELAY);
    if (fcpEntry) {
      callback(fcpEntry.startTime);
    }
  });
  return {
    stop: performanceSubscription.unsubscribe
  };
}
function trackRestoredFirstContentfulPaint(viewStartRelative, callback) {
  requestAnimationFrame(() => {
    requestAnimationFrame(() => {
      callback(elapsed(viewStartRelative, relativeNow()));
    });
  });
}

// node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/trackFirstInput.js
function trackFirstInput(configuration, firstHidden, callback) {
  const performanceFirstInputSubscription = createPerformanceObservable(configuration, {
    type: RumPerformanceEntryType.FIRST_INPUT,
    buffered: true
  }).subscribe((entries) => {
    const firstInputEntry = entries.find((entry) => entry.startTime < firstHidden.timeStamp);
    if (firstInputEntry) {
      const firstInputDelay = elapsed(firstInputEntry.startTime, firstInputEntry.processingStart);
      let firstInputTargetSelector;
      if (firstInputEntry.target && isElementNode(firstInputEntry.target)) {
        firstInputTargetSelector = getSelectorFromElement(firstInputEntry.target, configuration.actionNameAttribute);
      }
      callback({
        // Ensure firstInputDelay to be positive, see
        // https://bugs.chromium.org/p/chromium/issues/detail?id=1185815
        delay: firstInputDelay >= 0 ? firstInputDelay : 0,
        time: firstInputEntry.startTime,
        targetSelector: firstInputTargetSelector
      });
    }
  });
  return {
    stop: () => {
      performanceFirstInputSubscription.unsubscribe();
    }
  };
}

// node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/trackNavigationTimings.js
function trackNavigationTimings(configuration, callback, getNavigationEntryImpl = getNavigationEntry) {
  return waitAfterLoadEvent(configuration, () => {
    const entry = getNavigationEntryImpl();
    if (!isIncompleteNavigation(entry)) {
      callback(processNavigationEntry(entry));
    }
  });
}
function processNavigationEntry(entry) {
  return {
    domComplete: entry.domComplete,
    domContentLoaded: entry.domContentLoadedEventEnd,
    domInteractive: entry.domInteractive,
    loadEvent: entry.loadEventEnd,
    // In some cases the value reported is negative or is larger
    // than the current page time. Ignore these cases:
    // https://github.com/GoogleChrome/web-vitals/issues/137
    // https://github.com/GoogleChrome/web-vitals/issues/162
    firstByte: entry.responseStart >= 0 && entry.responseStart <= relativeNow() ? entry.responseStart : void 0
  };
}
function isIncompleteNavigation(entry) {
  return entry.loadEventEnd <= 0;
}
function waitAfterLoadEvent(configuration, callback) {
  let timeoutId;
  const { stop: stopOnReadyState } = runOnReadyState(configuration, "complete", () => {
    timeoutId = setTimeout(() => callback());
  });
  return {
    stop: () => {
      stopOnReadyState();
      clearTimeout(timeoutId);
    }
  };
}

// node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/trackLargestContentfulPaint.js
var LCP_MAXIMUM_DELAY = 10 * ONE_MINUTE;
function trackLargestContentfulPaint(configuration, firstHidden, eventTarget, callback) {
  let firstInteractionTimestamp = Infinity;
  const { stop: stopEventListener } = addEventListeners(configuration, eventTarget, [
    "pointerdown",
    "keydown"
    /* DOM_EVENT.KEY_DOWN */
  ], (event) => {
    firstInteractionTimestamp = event.timeStamp;
  }, { capture: true, once: true });
  let biggestLcpSize = 0;
  const performanceLcpSubscription = createPerformanceObservable(configuration, {
    type: RumPerformanceEntryType.LARGEST_CONTENTFUL_PAINT,
    buffered: true
  }).subscribe((entries) => {
    const lcpEntry = findLast(entries, (entry) => entry.entryType === RumPerformanceEntryType.LARGEST_CONTENTFUL_PAINT && entry.startTime < firstInteractionTimestamp && entry.startTime < firstHidden.timeStamp && entry.startTime < LCP_MAXIMUM_DELAY && // Ensure to get the LCP entry with the biggest size, see
    // https://bugs.chromium.org/p/chromium/issues/detail?id=1516655
    entry.size > biggestLcpSize);
    if (lcpEntry) {
      let lcpTargetSelector;
      if (lcpEntry.element) {
        lcpTargetSelector = getSelectorFromElement(lcpEntry.element, configuration.actionNameAttribute);
      }
      callback({
        value: lcpEntry.startTime,
        targetSelector: lcpTargetSelector,
        resourceUrl: computeLcpEntryUrl(lcpEntry)
      });
      biggestLcpSize = lcpEntry.size;
    }
  });
  return {
    stop: () => {
      stopEventListener();
      performanceLcpSubscription.unsubscribe();
    }
  };
}
function computeLcpEntryUrl(entry) {
  return entry.url === "" ? void 0 : entry.url;
}

// node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/trackFirstHidden.js
function trackFirstHidden(configuration, viewStart, eventTarget = window) {
  if (document.visibilityState === "hidden") {
    return { timeStamp: 0, stop: noop };
  }
  if (supportPerformanceTimingEvent(RumPerformanceEntryType.VISIBILITY_STATE)) {
    const firstHiddenEntry = performance.getEntriesByType(RumPerformanceEntryType.VISIBILITY_STATE).filter((entry) => entry.name === "hidden").find((entry) => entry.startTime >= viewStart.relative);
    if (firstHiddenEntry) {
      return { timeStamp: firstHiddenEntry.startTime, stop: noop };
    }
  }
  let timeStamp = Infinity;
  const { stop } = addEventListeners(configuration, eventTarget, [
    "pagehide",
    "visibilitychange"
    /* DOM_EVENT.VISIBILITY_CHANGE */
  ], (event) => {
    if (event.type === "pagehide" || document.visibilityState === "hidden") {
      timeStamp = event.timeStamp;
      stop();
    }
  }, { capture: true });
  return {
    get timeStamp() {
      return timeStamp;
    },
    stop
  };
}

// node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/trackInitialViewMetrics.js
function trackInitialViewMetrics(configuration, viewStart, setLoadEvent, scheduleViewUpdate) {
  const initialViewMetrics = {};
  const { stop: stopNavigationTracking } = trackNavigationTimings(configuration, (navigationTimings) => {
    setLoadEvent(navigationTimings.loadEvent);
    initialViewMetrics.navigationTimings = navigationTimings;
    scheduleViewUpdate();
  });
  const firstHidden = trackFirstHidden(configuration, viewStart);
  const { stop: stopFCPTracking } = trackFirstContentfulPaint(configuration, firstHidden, (firstContentfulPaint) => {
    initialViewMetrics.firstContentfulPaint = firstContentfulPaint;
    scheduleViewUpdate();
  });
  const { stop: stopLCPTracking } = trackLargestContentfulPaint(configuration, firstHidden, window, (largestContentfulPaint) => {
    initialViewMetrics.largestContentfulPaint = largestContentfulPaint;
    scheduleViewUpdate();
  });
  const { stop: stopFIDTracking } = trackFirstInput(configuration, firstHidden, (firstInput) => {
    initialViewMetrics.firstInput = firstInput;
    scheduleViewUpdate();
  });
  function stop() {
    stopNavigationTracking();
    stopFCPTracking();
    stopLCPTracking();
    stopFIDTracking();
    firstHidden.stop();
  }
  return {
    stop,
    initialViewMetrics
  };
}

// node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/getClsAttributionImpactedArea.js
var calculateArea = (width, height) => width * height;
var calculateIntersectionArea = (rect1, rect2) => {
  const left = Math.max(rect1.left, rect2.left);
  const top = Math.max(rect1.top, rect2.top);
  const right = Math.min(rect1.right, rect2.right);
  const bottom = Math.min(rect1.bottom, rect2.bottom);
  if (left >= right || top >= bottom) {
    return 0;
  }
  return calculateArea(right - left, bottom - top);
};
var getClsAttributionImpactedArea = (source) => {
  const previousArea = calculateArea(source.previousRect.width, source.previousRect.height);
  const currentArea = calculateArea(source.currentRect.width, source.currentRect.height);
  const intersectionArea = calculateIntersectionArea(source.previousRect, source.currentRect);
  return previousArea + currentArea - intersectionArea;
};

// node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/trackCumulativeLayoutShift.js
function trackCumulativeLayoutShift(configuration, viewStart, callback) {
  if (!isLayoutShiftSupported()) {
    return {
      stop: noop
    };
  }
  let maxClsValue = 0;
  let biggestShift;
  callback({
    value: 0
  });
  const slidingWindow = slidingSessionWindow();
  const performanceSubscription = createPerformanceObservable(configuration, {
    type: RumPerformanceEntryType.LAYOUT_SHIFT,
    buffered: true
  }).subscribe((entries) => {
    var _a;
    for (const entry of entries) {
      if (entry.hadRecentInput || entry.startTime < viewStart) {
        continue;
      }
      const { cumulatedValue, isMaxValue } = slidingWindow.update(entry);
      if (isMaxValue) {
        const attribution = getTopImpactedElement(entry.sources);
        biggestShift = {
          target: (attribution === null || attribution === void 0 ? void 0 : attribution.node) ? new WeakRef(attribution.node) : void 0,
          time: elapsed(viewStart, entry.startTime),
          previousRect: attribution === null || attribution === void 0 ? void 0 : attribution.previousRect,
          currentRect: attribution === null || attribution === void 0 ? void 0 : attribution.currentRect,
          devicePixelRatio: window.devicePixelRatio
        };
      }
      if (cumulatedValue > maxClsValue) {
        maxClsValue = cumulatedValue;
        const target = (_a = biggestShift === null || biggestShift === void 0 ? void 0 : biggestShift.target) === null || _a === void 0 ? void 0 : _a.deref();
        callback({
          value: round(maxClsValue, 4),
          targetSelector: target && getSelectorFromElement(target, configuration.actionNameAttribute),
          time: biggestShift === null || biggestShift === void 0 ? void 0 : biggestShift.time,
          previousRect: (biggestShift === null || biggestShift === void 0 ? void 0 : biggestShift.previousRect) ? asRumRect(biggestShift.previousRect) : void 0,
          currentRect: (biggestShift === null || biggestShift === void 0 ? void 0 : biggestShift.currentRect) ? asRumRect(biggestShift.currentRect) : void 0,
          devicePixelRatio: biggestShift === null || biggestShift === void 0 ? void 0 : biggestShift.devicePixelRatio
        });
      }
    }
  });
  return {
    stop: () => {
      performanceSubscription.unsubscribe();
    }
  };
}
function getTopImpactedElement(sources) {
  let topImpactedSource;
  for (const source of sources) {
    if (source.node && isElementNode(source.node)) {
      const currentImpactedArea = getClsAttributionImpactedArea(source);
      if (!topImpactedSource || getClsAttributionImpactedArea(topImpactedSource) < currentImpactedArea) {
        topImpactedSource = source;
      }
    }
  }
  return topImpactedSource;
}
function asRumRect({ x, y, width, height }) {
  return { x, y, width, height };
}
var MAX_WINDOW_DURATION = 5 * ONE_SECOND;
var MAX_UPDATE_GAP = ONE_SECOND;
function slidingSessionWindow() {
  let cumulatedValue = 0;
  let startTime;
  let endTime2;
  let maxValue = 0;
  return {
    update: (entry) => {
      const shouldCreateNewWindow = startTime === void 0 || entry.startTime - endTime2 >= MAX_UPDATE_GAP || entry.startTime - startTime >= MAX_WINDOW_DURATION;
      let isMaxValue;
      if (shouldCreateNewWindow) {
        startTime = endTime2 = entry.startTime;
        maxValue = cumulatedValue = entry.value;
        isMaxValue = true;
      } else {
        cumulatedValue += entry.value;
        endTime2 = entry.startTime;
        isMaxValue = entry.value > maxValue;
        if (isMaxValue) {
          maxValue = entry.value;
        }
      }
      return {
        cumulatedValue,
        isMaxValue
      };
    }
  };
}
function isLayoutShiftSupported() {
  return supportPerformanceTimingEvent(RumPerformanceEntryType.LAYOUT_SHIFT) && "WeakRef" in window;
}

// node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/interactionCountPolyfill.js
var observer;
var interactionCountEstimate = 0;
var minKnownInteractionId = Infinity;
var maxKnownInteractionId = 0;
function initInteractionCountPolyfill() {
  if ("interactionCount" in performance || observer) {
    return;
  }
  observer = new window.PerformanceObserver(monitor((entries) => {
    entries.getEntries().forEach((e) => {
      const entry = e;
      if (entry.interactionId) {
        minKnownInteractionId = Math.min(minKnownInteractionId, entry.interactionId);
        maxKnownInteractionId = Math.max(maxKnownInteractionId, entry.interactionId);
        interactionCountEstimate = (maxKnownInteractionId - minKnownInteractionId) / 7 + 1;
      }
    });
  }));
  observer.observe({ type: "event", buffered: true, durationThreshold: 0 });
}
var getInteractionCount = () => observer ? interactionCountEstimate : window.performance.interactionCount || 0;

// node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/trackInteractionToNextPaint.js
var MAX_INTERACTION_ENTRIES = 10;
var MAX_INP_VALUE = 1 * ONE_MINUTE;
function trackInteractionToNextPaint(configuration, viewStart, viewLoadingType) {
  if (!isInteractionToNextPaintSupported()) {
    return {
      getInteractionToNextPaint: () => void 0,
      setViewEnd: noop,
      stop: noop
    };
  }
  const { getViewInteractionCount, stopViewInteractionCount } = trackViewInteractionCount(viewLoadingType);
  let viewEnd = Infinity;
  const longestInteractions = trackLongestInteractions(getViewInteractionCount);
  let interactionToNextPaint = -1;
  let interactionToNextPaintTargetSelector;
  let interactionToNextPaintStartTime;
  function handleEntries(entries) {
    for (const entry of entries) {
      if (entry.interactionId && // Check the entry start time is inside the view bounds because some view interactions can be reported after the view end (if long duration).
      entry.startTime >= viewStart && entry.startTime <= viewEnd) {
        longestInteractions.process(entry);
      }
    }
    const newInteraction = longestInteractions.estimateP98Interaction();
    if (newInteraction && newInteraction.duration !== interactionToNextPaint) {
      interactionToNextPaint = newInteraction.duration;
      interactionToNextPaintStartTime = elapsed(viewStart, newInteraction.startTime);
      interactionToNextPaintTargetSelector = getInteractionSelector(newInteraction.startTime);
      if (!interactionToNextPaintTargetSelector && newInteraction.target && isElementNode(newInteraction.target)) {
        interactionToNextPaintTargetSelector = getSelectorFromElement(newInteraction.target, configuration.actionNameAttribute);
      }
    }
  }
  const firstInputSubscription = createPerformanceObservable(configuration, {
    type: RumPerformanceEntryType.FIRST_INPUT,
    buffered: true
  }).subscribe(handleEntries);
  const eventSubscription = createPerformanceObservable(configuration, {
    type: RumPerformanceEntryType.EVENT,
    // durationThreshold only impact PerformanceEventTiming entries used for INP computation which requires a threshold at 40 (default is 104ms)
    // cf: https://github.com/GoogleChrome/web-vitals/blob/3806160ffbc93c3c4abf210a167b81228172b31c/src/onINP.ts#L202-L210
    durationThreshold: 40,
    buffered: true
  }).subscribe(handleEntries);
  return {
    getInteractionToNextPaint: () => {
      if (interactionToNextPaint >= 0) {
        return {
          value: Math.min(interactionToNextPaint, MAX_INP_VALUE),
          targetSelector: interactionToNextPaintTargetSelector,
          time: interactionToNextPaintStartTime
        };
      } else if (getViewInteractionCount()) {
        return {
          value: 0
        };
      }
    },
    setViewEnd: (viewEndTime) => {
      viewEnd = viewEndTime;
      stopViewInteractionCount();
    },
    stop: () => {
      eventSubscription.unsubscribe();
      firstInputSubscription.unsubscribe();
    }
  };
}
function trackLongestInteractions(getViewInteractionCount) {
  const longestInteractions = [];
  function sortAndTrimLongestInteractions() {
    longestInteractions.sort((a, b) => b.duration - a.duration).splice(MAX_INTERACTION_ENTRIES);
  }
  return {
    /**
     * Process the performance entry:
     * - if its duration is long enough, add the performance entry to the list of worst interactions
     * - if an entry with the same interaction id exists and its duration is lower than the new one, then replace it in the list of worst interactions
     */
    process(entry) {
      const interactionIndex = longestInteractions.findIndex((interaction) => entry.interactionId === interaction.interactionId);
      const minLongestInteraction = longestInteractions[longestInteractions.length - 1];
      if (interactionIndex !== -1) {
        if (entry.duration > longestInteractions[interactionIndex].duration) {
          longestInteractions[interactionIndex] = entry;
          sortAndTrimLongestInteractions();
        }
      } else if (longestInteractions.length < MAX_INTERACTION_ENTRIES || entry.duration > minLongestInteraction.duration) {
        longestInteractions.push(entry);
        sortAndTrimLongestInteractions();
      }
    },
    /**
     * Compute the p98 longest interaction.
     * For better performance the computation is based on 10 longest interactions and the interaction count of the current view.
     */
    estimateP98Interaction() {
      const interactionIndex = Math.min(longestInteractions.length - 1, Math.floor(getViewInteractionCount() / 50));
      return longestInteractions[interactionIndex];
    }
  };
}
function trackViewInteractionCount(viewLoadingType) {
  initInteractionCountPolyfill();
  const previousInteractionCount = viewLoadingType === "initial_load" ? 0 : getInteractionCount();
  let state = { stopped: false };
  function computeViewInteractionCount() {
    return getInteractionCount() - previousInteractionCount;
  }
  return {
    getViewInteractionCount: () => {
      if (state.stopped) {
        return state.interactionCount;
      }
      return computeViewInteractionCount();
    },
    stopViewInteractionCount: () => {
      state = { stopped: true, interactionCount: computeViewInteractionCount() };
    }
  };
}
function isInteractionToNextPaintSupported() {
  return supportPerformanceTimingEvent(RumPerformanceEntryType.EVENT) && window.PerformanceEventTiming && "interactionId" in PerformanceEventTiming.prototype;
}

// node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/trackLoadingTime.js
function trackLoadingTime(lifeCycle, domMutationObservable, windowOpenObservable, configuration, loadType, viewStart, callback) {
  let isWaitingForLoadEvent = loadType === "initial_load";
  let isWaitingForActivityLoadingTime = true;
  const loadingTimeCandidates = [];
  const firstHidden = trackFirstHidden(configuration, viewStart);
  function invokeCallbackIfAllCandidatesAreReceived() {
    if (!isWaitingForActivityLoadingTime && !isWaitingForLoadEvent && loadingTimeCandidates.length > 0) {
      const loadingTime = Math.max(...loadingTimeCandidates);
      if (loadingTime < firstHidden.timeStamp - viewStart.relative) {
        callback(loadingTime);
      }
    }
  }
  const { stop } = waitPageActivityEnd(lifeCycle, domMutationObservable, windowOpenObservable, configuration, (event) => {
    if (isWaitingForActivityLoadingTime) {
      isWaitingForActivityLoadingTime = false;
      if (event.hadActivity) {
        loadingTimeCandidates.push(elapsed(viewStart.timeStamp, event.end));
      }
      invokeCallbackIfAllCandidatesAreReceived();
    }
  });
  return {
    stop: () => {
      stop();
      firstHidden.stop();
    },
    setLoadEvent: (loadEvent) => {
      if (isWaitingForLoadEvent) {
        isWaitingForLoadEvent = false;
        loadingTimeCandidates.push(loadEvent);
        invokeCallbackIfAllCandidatesAreReceived();
      }
    }
  };
}

// node_modules/@datadog/browser-rum-core/esm/browser/scroll.js
function getScrollX() {
  let scrollX;
  const visual = window.visualViewport;
  if (visual) {
    scrollX = visual.pageLeft - visual.offsetLeft;
  } else if (window.scrollX !== void 0) {
    scrollX = window.scrollX;
  } else {
    scrollX = window.pageXOffset || 0;
  }
  return Math.round(scrollX);
}
function getScrollY() {
  let scrollY;
  const visual = window.visualViewport;
  if (visual) {
    scrollY = visual.pageTop - visual.offsetTop;
  } else if (window.scrollY !== void 0) {
    scrollY = window.scrollY;
  } else {
    scrollY = window.pageYOffset || 0;
  }
  return Math.round(scrollY);
}

// node_modules/@datadog/browser-rum-core/esm/browser/viewportObservable.js
var viewportObservable;
function initViewportObservable(configuration) {
  if (!viewportObservable) {
    viewportObservable = createViewportObservable(configuration);
  }
  return viewportObservable;
}
function createViewportObservable(configuration) {
  return new Observable((observable) => {
    const { throttled: updateDimension } = throttle(() => {
      observable.notify(getViewportDimension());
    }, 200);
    return addEventListener(configuration, window, "resize", updateDimension, { capture: true, passive: true }).stop;
  });
}
function getViewportDimension() {
  const visual = window.visualViewport;
  if (visual) {
    return {
      width: Number(visual.width * visual.scale),
      height: Number(visual.height * visual.scale)
    };
  }
  return {
    width: Number(window.innerWidth || 0),
    height: Number(window.innerHeight || 0)
  };
}

// node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/trackScrollMetrics.js
var THROTTLE_SCROLL_DURATION = ONE_SECOND;
function trackScrollMetrics(configuration, viewStart, callback, scrollValues = createScrollValuesObservable(configuration)) {
  let maxScrollDepth = 0;
  let maxScrollHeight = 0;
  let maxScrollHeightTime = 0;
  const subscription = scrollValues.subscribe(({ scrollDepth, scrollTop, scrollHeight }) => {
    let shouldUpdate = false;
    if (scrollDepth > maxScrollDepth) {
      maxScrollDepth = scrollDepth;
      shouldUpdate = true;
    }
    if (scrollHeight > maxScrollHeight) {
      maxScrollHeight = scrollHeight;
      const now = relativeNow();
      maxScrollHeightTime = elapsed(viewStart.relative, now);
      shouldUpdate = true;
    }
    if (shouldUpdate) {
      callback({
        maxDepth: Math.min(maxScrollDepth, maxScrollHeight),
        maxDepthScrollTop: scrollTop,
        maxScrollHeight,
        maxScrollHeightTime
      });
    }
  });
  return {
    stop: () => subscription.unsubscribe()
  };
}
function computeScrollValues() {
  const scrollTop = getScrollY();
  const { height } = getViewportDimension();
  const scrollHeight = Math.round((document.scrollingElement || document.documentElement).scrollHeight);
  const scrollDepth = Math.round(height + scrollTop);
  return {
    scrollHeight,
    scrollDepth,
    scrollTop
  };
}
function createScrollValuesObservable(configuration, throttleDuration = THROTTLE_SCROLL_DURATION) {
  return new Observable((observable) => {
    function notify() {
      observable.notify(computeScrollValues());
    }
    if (window.ResizeObserver) {
      const throttledNotify = throttle(notify, throttleDuration, {
        leading: false,
        trailing: true
      });
      const observerTarget = document.scrollingElement || document.documentElement;
      const resizeObserver = new ResizeObserver(monitor(throttledNotify.throttled));
      if (observerTarget) {
        resizeObserver.observe(observerTarget);
      }
      const eventListener = addEventListener(configuration, window, "scroll", throttledNotify.throttled, {
        passive: true
      });
      return () => {
        throttledNotify.cancel();
        resizeObserver.disconnect();
        eventListener.stop();
      };
    }
  });
}

// node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/trackCommonViewMetrics.js
function trackCommonViewMetrics(lifeCycle, domMutationObservable, windowOpenObservable, configuration, scheduleViewUpdate, loadingType, viewStart) {
  const commonViewMetrics = {};
  const { stop: stopLoadingTimeTracking, setLoadEvent } = trackLoadingTime(lifeCycle, domMutationObservable, windowOpenObservable, configuration, loadingType, viewStart, (newLoadingTime) => {
    commonViewMetrics.loadingTime = newLoadingTime;
    scheduleViewUpdate();
  });
  const { stop: stopScrollMetricsTracking } = trackScrollMetrics(configuration, viewStart, (newScrollMetrics) => {
    commonViewMetrics.scroll = newScrollMetrics;
  });
  const { stop: stopCLSTracking } = trackCumulativeLayoutShift(configuration, viewStart.relative, (cumulativeLayoutShift) => {
    commonViewMetrics.cumulativeLayoutShift = cumulativeLayoutShift;
    scheduleViewUpdate();
  });
  const { stop: stopINPTracking, getInteractionToNextPaint, setViewEnd } = trackInteractionToNextPaint(configuration, viewStart.relative, loadingType);
  return {
    stop: () => {
      stopLoadingTimeTracking();
      stopCLSTracking();
      stopScrollMetricsTracking();
    },
    stopINPTracking,
    setLoadEvent,
    setViewEnd,
    getCommonViewMetrics: () => {
      commonViewMetrics.interactionToNextPaint = getInteractionToNextPaint();
      return commonViewMetrics;
    }
  };
}

// node_modules/@datadog/browser-rum-core/esm/domain/view/bfCacheSupport.js
function onBFCacheRestore(configuration, callback) {
  const { stop } = addEventListener(configuration, window, "pageshow", (event) => {
    if (event.persisted) {
      callback(event);
    }
  }, { capture: true });
  return stop;
}

// node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/trackBfcacheMetrics.js
function trackBfcacheMetrics(viewStart, metrics, scheduleViewUpdate) {
  trackRestoredFirstContentfulPaint(viewStart.relative, (paintTime) => {
    metrics.firstContentfulPaint = paintTime;
    metrics.largestContentfulPaint = { value: paintTime };
    scheduleViewUpdate();
  });
}

// node_modules/@datadog/browser-rum-core/esm/domain/view/trackViews.js
var THROTTLE_VIEW_UPDATE_PERIOD = 3e3;
var SESSION_KEEP_ALIVE_INTERVAL = 5 * ONE_MINUTE;
var KEEP_TRACKING_AFTER_VIEW_DELAY = 5 * ONE_MINUTE;
function trackViews(location2, lifeCycle, domMutationObservable, windowOpenObservable, configuration, locationChangeObservable, areViewsTrackedAutomatically, initialViewOptions) {
  const activeViews = /* @__PURE__ */ new Set();
  let currentView = startNewView("initial_load", clocksOrigin(), initialViewOptions);
  let stopOnBFCacheRestore;
  startViewLifeCycle();
  let locationChangeSubscription;
  if (areViewsTrackedAutomatically) {
    locationChangeSubscription = renewViewOnLocationChange(locationChangeObservable);
    if (configuration.trackBfcacheViews) {
      stopOnBFCacheRestore = onBFCacheRestore(configuration, (pageshowEvent) => {
        currentView.end();
        const startClocks = relativeToClocks(pageshowEvent.timeStamp);
        currentView = startNewView("bf_cache", startClocks, void 0);
      });
    }
  }
  function startNewView(loadingType, startClocks, viewOptions) {
    const newlyCreatedView = newView(lifeCycle, domMutationObservable, windowOpenObservable, configuration, location2, loadingType, startClocks, viewOptions);
    activeViews.add(newlyCreatedView);
    newlyCreatedView.stopObservable.subscribe(() => {
      activeViews.delete(newlyCreatedView);
    });
    return newlyCreatedView;
  }
  function startViewLifeCycle() {
    lifeCycle.subscribe(10, () => {
      currentView = startNewView("route_change", void 0, {
        name: currentView.name,
        service: currentView.service,
        version: currentView.version,
        context: currentView.contextManager.getContext()
      });
    });
    lifeCycle.subscribe(9, () => {
      currentView.end({ sessionIsActive: false });
    });
  }
  function renewViewOnLocationChange(locationChangeObservable2) {
    return locationChangeObservable2.subscribe(({ oldLocation, newLocation }) => {
      if (areDifferentLocation(oldLocation, newLocation)) {
        currentView.end();
        currentView = startNewView(
          "route_change"
          /* ViewLoadingType.ROUTE_CHANGE */
        );
      }
    });
  }
  return {
    addTiming: (name, time = timeStampNow()) => {
      currentView.addTiming(name, time);
    },
    startView: (options, startClocks) => {
      currentView.end({ endClocks: startClocks });
      currentView = startNewView("route_change", startClocks, options);
    },
    setViewContext: (context) => {
      currentView.contextManager.setContext(context);
    },
    setViewContextProperty: (key, value) => {
      currentView.contextManager.setContextProperty(key, value);
    },
    setViewName: (name) => {
      currentView.setViewName(name);
    },
    getViewContext: () => currentView.contextManager.getContext(),
    stop: () => {
      if (locationChangeSubscription) {
        locationChangeSubscription.unsubscribe();
      }
      if (stopOnBFCacheRestore) {
        stopOnBFCacheRestore();
      }
      currentView.end();
      activeViews.forEach((view) => view.stop());
    }
  };
}
function newView(lifeCycle, domMutationObservable, windowOpenObservable, configuration, initialLocation, loadingType, startClocks = clocksNow(), viewOptions) {
  const id = generateUUID();
  const stopObservable = new Observable();
  const customTimings = {};
  let documentVersion = 0;
  let endClocks;
  const location2 = shallowClone(initialLocation);
  const contextManager = createContextManager();
  let sessionIsActive = true;
  let name = viewOptions === null || viewOptions === void 0 ? void 0 : viewOptions.name;
  const service = (viewOptions === null || viewOptions === void 0 ? void 0 : viewOptions.service) || configuration.service;
  const version = (viewOptions === null || viewOptions === void 0 ? void 0 : viewOptions.version) || configuration.version;
  const context = viewOptions === null || viewOptions === void 0 ? void 0 : viewOptions.context;
  if (context) {
    contextManager.setContext(context);
  }
  const viewCreatedEvent = {
    id,
    name,
    startClocks,
    service,
    version,
    context
  };
  lifeCycle.notify(1, viewCreatedEvent);
  lifeCycle.notify(2, viewCreatedEvent);
  const { throttled, cancel: cancelScheduleViewUpdate } = throttle(triggerViewUpdate, THROTTLE_VIEW_UPDATE_PERIOD, {
    leading: false
  });
  const { setLoadEvent, setViewEnd, stop: stopCommonViewMetricsTracking, stopINPTracking, getCommonViewMetrics } = trackCommonViewMetrics(lifeCycle, domMutationObservable, windowOpenObservable, configuration, scheduleViewUpdate, loadingType, startClocks);
  const { stop: stopInitialViewMetricsTracking, initialViewMetrics } = loadingType === "initial_load" ? trackInitialViewMetrics(configuration, startClocks, setLoadEvent, scheduleViewUpdate) : { stop: noop, initialViewMetrics: {} };
  if (loadingType === "bf_cache") {
    trackBfcacheMetrics(startClocks, initialViewMetrics, scheduleViewUpdate);
  }
  const { stop: stopEventCountsTracking, eventCounts } = trackViewEventCounts(lifeCycle, id, scheduleViewUpdate);
  const keepAliveIntervalId = setInterval(triggerViewUpdate, SESSION_KEEP_ALIVE_INTERVAL);
  const pageMayExitSubscription = lifeCycle.subscribe(11, (pageMayExitEvent) => {
    if (pageMayExitEvent.reason === PageExitReason.UNLOADING) {
      triggerViewUpdate();
    }
  });
  triggerViewUpdate();
  contextManager.changeObservable.subscribe(scheduleViewUpdate);
  function triggerBeforeViewUpdate() {
    lifeCycle.notify(3, {
      id,
      name,
      context: contextManager.getContext(),
      startClocks,
      sessionIsActive
    });
  }
  function scheduleViewUpdate() {
    triggerBeforeViewUpdate();
    throttled();
  }
  function triggerViewUpdate() {
    cancelScheduleViewUpdate();
    triggerBeforeViewUpdate();
    documentVersion += 1;
    const currentEnd = endClocks === void 0 ? timeStampNow() : endClocks.timeStamp;
    lifeCycle.notify(4, {
      customTimings,
      documentVersion,
      id,
      name,
      service,
      version,
      context: contextManager.getContext(),
      loadingType,
      location: location2,
      startClocks,
      commonViewMetrics: getCommonViewMetrics(),
      initialViewMetrics,
      duration: elapsed(startClocks.timeStamp, currentEnd),
      isActive: endClocks === void 0,
      sessionIsActive,
      eventCounts
    });
  }
  return {
    get name() {
      return name;
    },
    service,
    version,
    contextManager,
    stopObservable,
    end(options = {}) {
      var _a, _b;
      if (endClocks) {
        return;
      }
      endClocks = (_a = options.endClocks) !== null && _a !== void 0 ? _a : clocksNow();
      sessionIsActive = (_b = options.sessionIsActive) !== null && _b !== void 0 ? _b : true;
      lifeCycle.notify(5, { endClocks });
      lifeCycle.notify(6, { endClocks });
      clearInterval(keepAliveIntervalId);
      setViewEnd(endClocks.relative);
      stopCommonViewMetricsTracking();
      pageMayExitSubscription.unsubscribe();
      triggerViewUpdate();
      setTimeout(() => {
        this.stop();
      }, KEEP_TRACKING_AFTER_VIEW_DELAY);
    },
    stop() {
      stopInitialViewMetricsTracking();
      stopEventCountsTracking();
      stopINPTracking();
      stopObservable.notify();
    },
    addTiming(name2, time) {
      if (endClocks) {
        return;
      }
      const relativeTime = looksLikeRelativeTime(time) ? time : elapsed(startClocks.timeStamp, time);
      customTimings[sanitizeTiming(name2)] = relativeTime;
      scheduleViewUpdate();
    },
    setViewName(updatedName) {
      name = updatedName;
      triggerViewUpdate();
    }
  };
}
function sanitizeTiming(name) {
  const sanitized = name.replace(/[^a-zA-Z0-9-_.@$]/g, "_");
  if (sanitized !== name) {
    display.warn(`Invalid timing name: ${name}, sanitized to: ${sanitized}`);
  }
  return sanitized;
}
function areDifferentLocation(currentLocation, otherLocation) {
  return currentLocation.pathname !== otherLocation.pathname || !isHashAnAnchor(otherLocation.hash) && getPathFromHash(otherLocation.hash) !== getPathFromHash(currentLocation.hash);
}
function isHashAnAnchor(hash) {
  const correspondingId = hash.substring(1);
  return correspondingId !== "" && !!document.getElementById(correspondingId);
}
function getPathFromHash(hash) {
  const index = hash.indexOf("?");
  return index < 0 ? hash : hash.slice(0, index);
}

// node_modules/@datadog/browser-rum-core/esm/domain/view/viewCollection.js
function startViewCollection(lifeCycle, hooks, configuration, location2, domMutationObservable, pageOpenObservable, locationChangeObservable, recorderApi, viewHistory, initialViewOptions) {
  lifeCycle.subscribe(4, (view) => lifeCycle.notify(12, processViewUpdate(view, configuration, recorderApi)));
  hooks.register(0, ({ startTime, eventType }) => {
    const view = viewHistory.findView(startTime);
    if (!view) {
      return DISCARDED;
    }
    return {
      type: eventType,
      service: view.service,
      version: view.version,
      context: view.context,
      view: {
        id: view.id,
        name: view.name
      }
    };
  });
  return trackViews(location2, lifeCycle, domMutationObservable, pageOpenObservable, configuration, locationChangeObservable, !configuration.trackViewsManually, initialViewOptions);
}
function processViewUpdate(view, configuration, recorderApi) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
  const replayStats = recorderApi.getReplayStats(view.id);
  const clsDevicePixelRatio = (_b = (_a = view.commonViewMetrics) === null || _a === void 0 ? void 0 : _a.cumulativeLayoutShift) === null || _b === void 0 ? void 0 : _b.devicePixelRatio;
  const viewEvent = {
    _dd: {
      document_version: view.documentVersion,
      replay_stats: replayStats,
      cls: clsDevicePixelRatio ? {
        device_pixel_ratio: clsDevicePixelRatio
      } : void 0,
      configuration: {
        start_session_replay_recording_manually: configuration.startSessionReplayRecordingManually
      }
    },
    date: view.startClocks.timeStamp,
    type: "view",
    view: {
      action: {
        count: view.eventCounts.actionCount
      },
      frustration: {
        count: view.eventCounts.frustrationCount
      },
      cumulative_layout_shift: (_c = view.commonViewMetrics.cumulativeLayoutShift) === null || _c === void 0 ? void 0 : _c.value,
      cumulative_layout_shift_time: toServerDuration((_d = view.commonViewMetrics.cumulativeLayoutShift) === null || _d === void 0 ? void 0 : _d.time),
      cumulative_layout_shift_target_selector: (_e = view.commonViewMetrics.cumulativeLayoutShift) === null || _e === void 0 ? void 0 : _e.targetSelector,
      first_byte: toServerDuration((_f = view.initialViewMetrics.navigationTimings) === null || _f === void 0 ? void 0 : _f.firstByte),
      dom_complete: toServerDuration((_g = view.initialViewMetrics.navigationTimings) === null || _g === void 0 ? void 0 : _g.domComplete),
      dom_content_loaded: toServerDuration((_h = view.initialViewMetrics.navigationTimings) === null || _h === void 0 ? void 0 : _h.domContentLoaded),
      dom_interactive: toServerDuration((_j = view.initialViewMetrics.navigationTimings) === null || _j === void 0 ? void 0 : _j.domInteractive),
      error: {
        count: view.eventCounts.errorCount
      },
      first_contentful_paint: toServerDuration(view.initialViewMetrics.firstContentfulPaint),
      first_input_delay: toServerDuration((_k = view.initialViewMetrics.firstInput) === null || _k === void 0 ? void 0 : _k.delay),
      first_input_time: toServerDuration((_l = view.initialViewMetrics.firstInput) === null || _l === void 0 ? void 0 : _l.time),
      first_input_target_selector: (_m = view.initialViewMetrics.firstInput) === null || _m === void 0 ? void 0 : _m.targetSelector,
      interaction_to_next_paint: toServerDuration((_o = view.commonViewMetrics.interactionToNextPaint) === null || _o === void 0 ? void 0 : _o.value),
      interaction_to_next_paint_time: toServerDuration((_p = view.commonViewMetrics.interactionToNextPaint) === null || _p === void 0 ? void 0 : _p.time),
      interaction_to_next_paint_target_selector: (_q = view.commonViewMetrics.interactionToNextPaint) === null || _q === void 0 ? void 0 : _q.targetSelector,
      is_active: view.isActive,
      name: view.name,
      largest_contentful_paint: toServerDuration((_r = view.initialViewMetrics.largestContentfulPaint) === null || _r === void 0 ? void 0 : _r.value),
      largest_contentful_paint_target_selector: (_s = view.initialViewMetrics.largestContentfulPaint) === null || _s === void 0 ? void 0 : _s.targetSelector,
      load_event: toServerDuration((_t = view.initialViewMetrics.navigationTimings) === null || _t === void 0 ? void 0 : _t.loadEvent),
      loading_time: discardNegativeDuration(toServerDuration(view.commonViewMetrics.loadingTime)),
      loading_type: view.loadingType,
      long_task: {
        count: view.eventCounts.longTaskCount
      },
      performance: computeViewPerformanceData(view.commonViewMetrics, view.initialViewMetrics),
      resource: {
        count: view.eventCounts.resourceCount
      },
      time_spent: toServerDuration(view.duration)
    },
    display: view.commonViewMetrics.scroll ? {
      scroll: {
        max_depth: view.commonViewMetrics.scroll.maxDepth,
        max_depth_scroll_top: view.commonViewMetrics.scroll.maxDepthScrollTop,
        max_scroll_height: view.commonViewMetrics.scroll.maxScrollHeight,
        max_scroll_height_time: toServerDuration(view.commonViewMetrics.scroll.maxScrollHeightTime)
      }
    } : void 0,
    privacy: {
      replay_level: configuration.defaultPrivacyLevel
    }
  };
  if (!isEmptyObject(view.customTimings)) {
    viewEvent.view.custom_timings = mapValues(view.customTimings, toServerDuration);
  }
  return {
    rawRumEvent: viewEvent,
    startTime: view.startClocks.relative,
    duration: view.duration,
    domainContext: {
      location: view.location
    }
  };
}
function computeViewPerformanceData({ cumulativeLayoutShift, interactionToNextPaint }, { firstContentfulPaint, firstInput, largestContentfulPaint }) {
  return {
    cls: cumulativeLayoutShift && {
      score: cumulativeLayoutShift.value,
      timestamp: toServerDuration(cumulativeLayoutShift.time),
      target_selector: cumulativeLayoutShift.targetSelector,
      previous_rect: cumulativeLayoutShift.previousRect,
      current_rect: cumulativeLayoutShift.currentRect
    },
    fcp: firstContentfulPaint && { timestamp: toServerDuration(firstContentfulPaint) },
    fid: firstInput && {
      duration: toServerDuration(firstInput.delay),
      timestamp: toServerDuration(firstInput.time),
      target_selector: firstInput.targetSelector
    },
    inp: interactionToNextPaint && {
      duration: toServerDuration(interactionToNextPaint.value),
      timestamp: toServerDuration(interactionToNextPaint.time),
      target_selector: interactionToNextPaint.targetSelector
    },
    lcp: largestContentfulPaint && {
      timestamp: toServerDuration(largestContentfulPaint.value),
      target_selector: largestContentfulPaint.targetSelector,
      resource_url: largestContentfulPaint.resourceUrl
    }
  };
}

// node_modules/@datadog/browser-rum-core/esm/domain/rumSessionManager.js
var RUM_SESSION_KEY = "rum";
function startRumSessionManager(configuration, lifeCycle, trackingConsentState) {
  const sessionManager = startSessionManager(configuration, RUM_SESSION_KEY, (rawTrackingType) => computeTrackingType(configuration, rawTrackingType), trackingConsentState);
  sessionManager.expireObservable.subscribe(() => {
    lifeCycle.notify(
      9
      /* LifeCycleEventType.SESSION_EXPIRED */
    );
  });
  sessionManager.renewObservable.subscribe(() => {
    lifeCycle.notify(
      10
      /* LifeCycleEventType.SESSION_RENEWED */
    );
  });
  sessionManager.sessionStateUpdateObservable.subscribe(({ previousState, newState }) => {
    if (!previousState.forcedReplay && newState.forcedReplay) {
      const sessionEntity = sessionManager.findSession();
      if (sessionEntity) {
        sessionEntity.isReplayForced = true;
      }
    }
  });
  return {
    findTrackedSession: (startTime) => {
      const session = sessionManager.findSession(startTime);
      if (!session || session.trackingType === "0") {
        return;
      }
      return {
        id: session.id,
        sessionReplay: session.trackingType === "1" ? 1 : session.isReplayForced ? 2 : 0,
        anonymousId: session.anonymousId
      };
    },
    expire: sessionManager.expire,
    expireObservable: sessionManager.expireObservable,
    setForcedReplay: () => sessionManager.updateSessionState({ forcedReplay: "1" })
  };
}
function startRumSessionManagerStub() {
  const session = {
    id: "00000000-aaaa-0000-aaaa-000000000000",
    sessionReplay: bridgeSupports(
      "records"
      /* BridgeCapability.RECORDS */
    ) ? 1 : 0
  };
  return {
    findTrackedSession: () => session,
    expire: noop,
    expireObservable: new Observable(),
    setForcedReplay: noop
  };
}
function computeTrackingType(configuration, rawTrackingType) {
  if (hasValidRumSession(rawTrackingType)) {
    return rawTrackingType;
  }
  if (!performDraw(configuration.sessionSampleRate)) {
    return "0";
  }
  if (!performDraw(configuration.sessionReplaySampleRate)) {
    return "2";
  }
  return "1";
}
function hasValidRumSession(trackingType) {
  return trackingType === "0" || trackingType === "1" || trackingType === "2";
}

// node_modules/@datadog/browser-rum-core/esm/transport/startRumBatch.js
function startRumBatch(configuration, lifeCycle, reportError, pageMayExitObservable, sessionExpireObservable, createEncoder) {
  const replica = configuration.replica;
  const batch = startBatchWithReplica(configuration, {
    endpoint: configuration.rumEndpointBuilder,
    encoder: createEncoder(
      2
      /* DeflateEncoderStreamId.RUM */
    )
  }, replica && {
    endpoint: replica.rumEndpointBuilder,
    transformMessage: (message) => combine(message, { application: { id: replica.applicationId } }),
    encoder: createEncoder(
      3
      /* DeflateEncoderStreamId.RUM_REPLICA */
    )
  }, reportError, pageMayExitObservable, sessionExpireObservable);
  lifeCycle.subscribe(13, (serverRumEvent) => {
    if (serverRumEvent.type === "view") {
      batch.upsert(serverRumEvent, serverRumEvent.view.id);
    } else {
      batch.add(serverRumEvent);
    }
  });
  return batch;
}

// node_modules/@datadog/browser-rum-core/esm/transport/startRumEventBridge.js
function startRumEventBridge(lifeCycle) {
  const bridge = getEventBridge();
  lifeCycle.subscribe(13, (serverRumEvent) => {
    bridge.send("rum", serverRumEvent);
  });
}

// node_modules/@datadog/browser-rum-core/esm/domain/contexts/urlContexts.js
var URL_CONTEXT_TIME_OUT_DELAY = SESSION_TIME_OUT_DELAY;
function startUrlContexts(lifeCycle, hooks, locationChangeObservable, location2) {
  const urlContextHistory = createValueHistory({ expireDelay: URL_CONTEXT_TIME_OUT_DELAY });
  let previousViewUrl;
  lifeCycle.subscribe(1, ({ startClocks }) => {
    const viewUrl = location2.href;
    urlContextHistory.add(buildUrlContext({
      url: viewUrl,
      referrer: !previousViewUrl ? document.referrer : previousViewUrl
    }), startClocks.relative);
    previousViewUrl = viewUrl;
  });
  lifeCycle.subscribe(6, ({ endClocks }) => {
    urlContextHistory.closeActive(endClocks.relative);
  });
  const locationChangeSubscription = locationChangeObservable.subscribe(({ newLocation }) => {
    const current = urlContextHistory.find();
    if (current) {
      const changeTime = relativeNow();
      urlContextHistory.closeActive(changeTime);
      urlContextHistory.add(buildUrlContext({
        url: newLocation.href,
        referrer: current.referrer
      }), changeTime);
    }
  });
  function buildUrlContext({ url, referrer }) {
    return {
      url,
      referrer
    };
  }
  hooks.register(0, ({ startTime, eventType }) => {
    const urlContext = urlContextHistory.find(startTime);
    if (!urlContext) {
      return DISCARDED;
    }
    return {
      type: eventType,
      view: {
        url: urlContext.url,
        referrer: urlContext.referrer
      }
    };
  });
  return {
    findUrl: (startTime) => urlContextHistory.find(startTime),
    stop: () => {
      locationChangeSubscription.unsubscribe();
      urlContextHistory.stop();
    }
  };
}

// node_modules/@datadog/browser-rum-core/esm/browser/locationChangeObservable.js
function createLocationChangeObservable(configuration, location2) {
  let currentLocation = shallowClone(location2);
  return new Observable((observable) => {
    const { stop: stopHistoryTracking } = trackHistory(configuration, onLocationChange);
    const { stop: stopHashTracking } = trackHash(configuration, onLocationChange);
    function onLocationChange() {
      if (currentLocation.href === location2.href) {
        return;
      }
      const newLocation = shallowClone(location2);
      observable.notify({
        newLocation,
        oldLocation: currentLocation
      });
      currentLocation = newLocation;
    }
    return () => {
      stopHistoryTracking();
      stopHashTracking();
    };
  });
}
function trackHistory(configuration, onHistoryChange) {
  const { stop: stopInstrumentingPushState } = instrumentMethod(getHistoryInstrumentationTarget("pushState"), "pushState", ({ onPostCall }) => {
    onPostCall(onHistoryChange);
  });
  const { stop: stopInstrumentingReplaceState } = instrumentMethod(getHistoryInstrumentationTarget("replaceState"), "replaceState", ({ onPostCall }) => {
    onPostCall(onHistoryChange);
  });
  const { stop: removeListener } = addEventListener(configuration, window, "popstate", onHistoryChange);
  return {
    stop: () => {
      stopInstrumentingPushState();
      stopInstrumentingReplaceState();
      removeListener();
    }
  };
}
function trackHash(configuration, onHashChange) {
  return addEventListener(configuration, window, "hashchange", onHashChange);
}
function getHistoryInstrumentationTarget(methodName) {
  return Object.prototype.hasOwnProperty.call(history, methodName) ? history : History.prototype;
}

// node_modules/@datadog/browser-rum-core/esm/domain/contexts/featureFlagContext.js
var FEATURE_FLAG_CONTEXT_TIME_OUT_DELAY = SESSION_TIME_OUT_DELAY;
function startFeatureFlagContexts(lifeCycle, hooks, configuration) {
  const featureFlagContexts = createValueHistory({
    expireDelay: FEATURE_FLAG_CONTEXT_TIME_OUT_DELAY
  });
  lifeCycle.subscribe(1, ({ startClocks }) => {
    featureFlagContexts.add({}, startClocks.relative);
  });
  lifeCycle.subscribe(6, ({ endClocks }) => {
    featureFlagContexts.closeActive(endClocks.relative);
  });
  hooks.register(0, ({ startTime, eventType }) => {
    const trackFeatureFlagsForEvents = configuration.trackFeatureFlagsForEvents.concat([
      "view",
      "error"
    ]);
    if (!trackFeatureFlagsForEvents.includes(eventType)) {
      return SKIPPED;
    }
    const featureFlagContext = featureFlagContexts.find(startTime);
    if (!featureFlagContext || isEmptyObject(featureFlagContext)) {
      return SKIPPED;
    }
    return {
      type: eventType,
      feature_flags: featureFlagContext
    };
  });
  return {
    addFeatureFlagEvaluation: (key, value) => {
      const currentContext = featureFlagContexts.find();
      if (currentContext) {
        currentContext[key] = value;
      }
    }
  };
}

// node_modules/@datadog/browser-rum-core/esm/domain/startCustomerDataTelemetry.js
var MEASURES_PERIOD_DURATION = 10 * ONE_SECOND;
var currentPeriodMeasures;
var batchHasRumEvent;
function startCustomerDataTelemetry(configuration, telemetry, lifeCycle, batchFlushObservable) {
  const customerDataTelemetryEnabled = telemetry.enabled && performDraw(configuration.customerDataTelemetrySampleRate);
  if (!customerDataTelemetryEnabled) {
    return;
  }
  initCurrentPeriodMeasures();
  batchHasRumEvent = false;
  lifeCycle.subscribe(13, () => {
    batchHasRumEvent = true;
  });
  batchFlushObservable.subscribe(({ bytesCount, messagesCount }) => {
    if (!batchHasRumEvent) {
      return;
    }
    currentPeriodMeasures.batchCount += 1;
    updateMeasure(currentPeriodMeasures.batchBytesCount, bytesCount);
    updateMeasure(currentPeriodMeasures.batchMessagesCount, messagesCount);
  });
  setInterval(sendCurrentPeriodMeasures, MEASURES_PERIOD_DURATION);
}
function sendCurrentPeriodMeasures() {
  if (currentPeriodMeasures.batchCount === 0) {
    return;
  }
  addTelemetryDebug("Customer data measures", currentPeriodMeasures);
  initCurrentPeriodMeasures();
}
function createMeasure() {
  return { min: Infinity, max: 0, sum: 0 };
}
function updateMeasure(measure, value) {
  measure.sum += value;
  measure.min = Math.min(measure.min, value);
  measure.max = Math.max(measure.max, value);
}
function initCurrentPeriodMeasures() {
  currentPeriodMeasures = {
    batchCount: 0,
    batchBytesCount: createMeasure(),
    batchMessagesCount: createMeasure()
  };
}

// node_modules/@datadog/browser-rum-core/esm/domain/contexts/pageStateHistory.js
var MAX_PAGE_STATE_ENTRIES = 4e3;
var MAX_PAGE_STATE_ENTRIES_SELECTABLE = 500;
var PAGE_STATE_CONTEXT_TIME_OUT_DELAY = SESSION_TIME_OUT_DELAY;
function startPageStateHistory(hooks, configuration, maxPageStateEntriesSelectable = MAX_PAGE_STATE_ENTRIES_SELECTABLE) {
  const pageStateEntryHistory = createValueHistory({
    expireDelay: PAGE_STATE_CONTEXT_TIME_OUT_DELAY,
    maxEntries: MAX_PAGE_STATE_ENTRIES
  });
  let currentPageState;
  if (supportPerformanceTimingEvent(RumPerformanceEntryType.VISIBILITY_STATE)) {
    const visibilityEntries = performance.getEntriesByType(RumPerformanceEntryType.VISIBILITY_STATE);
    visibilityEntries.forEach((entry) => {
      const state = entry.name === "hidden" ? "hidden" : "active";
      addPageState(state, entry.startTime);
    });
  }
  addPageState(getPageState(), relativeNow());
  const { stop: stopEventListeners } = addEventListeners(configuration, window, [
    "pageshow",
    "focus",
    "blur",
    "visibilitychange",
    "resume",
    "freeze",
    "pagehide"
  ], (event) => {
    addPageState(computePageState(event), event.timeStamp);
  }, { capture: true });
  function addPageState(nextPageState, startTime = relativeNow()) {
    if (nextPageState === currentPageState) {
      return;
    }
    currentPageState = nextPageState;
    pageStateEntryHistory.closeActive(startTime);
    pageStateEntryHistory.add({ state: currentPageState, startTime }, startTime);
  }
  function wasInPageStateDuringPeriod(state, startTime, duration) {
    return pageStateEntryHistory.findAll(startTime, duration).some((pageState) => pageState.state === state);
  }
  hooks.register(0, ({ startTime, duration = 0, eventType }) => {
    if (eventType === "view") {
      const pageStates = pageStateEntryHistory.findAll(startTime, duration);
      return {
        type: eventType,
        _dd: { page_states: processPageStates(pageStates, startTime, maxPageStateEntriesSelectable) }
      };
    }
    if (eventType === "action" || eventType === "error") {
      return {
        type: eventType,
        view: { in_foreground: wasInPageStateDuringPeriod("active", startTime, 0) }
      };
    }
    return SKIPPED;
  });
  return {
    wasInPageStateDuringPeriod,
    addPageState,
    stop: () => {
      stopEventListeners();
      pageStateEntryHistory.stop();
    }
  };
}
function processPageStates(pageStateEntries, eventStartTime, maxPageStateEntriesSelectable) {
  if (pageStateEntries.length === 0) {
    return;
  }
  return pageStateEntries.slice(-maxPageStateEntriesSelectable).reverse().map(({ state, startTime }) => ({
    state,
    start: toServerDuration(elapsed(eventStartTime, startTime))
  }));
}
function computePageState(event) {
  if (event.type === "freeze") {
    return "frozen";
  } else if (event.type === "pagehide") {
    return event.persisted ? "frozen" : "terminated";
  }
  return getPageState();
}
function getPageState() {
  if (document.visibilityState === "hidden") {
    return "hidden";
  }
  if (document.hasFocus()) {
    return "active";
  }
  return "passive";
}

// node_modules/@datadog/browser-rum-core/esm/domain/contexts/displayContext.js
function startDisplayContext(hooks, configuration) {
  let viewport;
  const animationFrameId = requestAnimationFrame(monitor(() => {
    viewport = getViewportDimension();
  }));
  const unsubscribeViewport = initViewportObservable(configuration).subscribe((viewportDimension) => {
    viewport = viewportDimension;
  }).unsubscribe;
  hooks.register(0, ({ eventType }) => ({
    type: eventType,
    display: viewport ? { viewport } : void 0
  }));
  return {
    stop: () => {
      unsubscribeViewport();
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
    }
  };
}

// node_modules/@datadog/browser-rum-core/esm/browser/cookieObservable.js
function createCookieObservable(configuration, cookieName) {
  const detectCookieChangeStrategy = window.cookieStore ? listenToCookieStoreChange(configuration) : watchCookieFallback;
  return new Observable((observable) => detectCookieChangeStrategy(cookieName, (event) => observable.notify(event)));
}
function listenToCookieStoreChange(configuration) {
  return (cookieName, callback) => {
    const listener = addEventListener(configuration, window.cookieStore, "change", (event) => {
      const changeEvent = event.changed.find((event2) => event2.name === cookieName) || event.deleted.find((event2) => event2.name === cookieName);
      if (changeEvent) {
        callback(changeEvent.value);
      }
    });
    return listener.stop;
  };
}
var WATCH_COOKIE_INTERVAL_DELAY = ONE_SECOND;
function watchCookieFallback(cookieName, callback) {
  const previousCookieValue = findCommaSeparatedValue(document.cookie, cookieName);
  const watchCookieIntervalId = setInterval(() => {
    const cookieValue = findCommaSeparatedValue(document.cookie, cookieName);
    if (cookieValue !== previousCookieValue) {
      callback(cookieValue);
    }
  }, WATCH_COOKIE_INTERVAL_DELAY);
  return () => {
    clearInterval(watchCookieIntervalId);
  };
}

// node_modules/@datadog/browser-rum-core/esm/domain/contexts/ciVisibilityContext.js
var CI_VISIBILITY_TEST_ID_COOKIE_NAME = "datadog-ci-visibility-test-execution-id";
function startCiVisibilityContext(configuration, hooks, cookieObservable = createCookieObservable(configuration, CI_VISIBILITY_TEST_ID_COOKIE_NAME)) {
  var _a;
  let testExecutionId = getInitCookie(CI_VISIBILITY_TEST_ID_COOKIE_NAME) || ((_a = window.Cypress) === null || _a === void 0 ? void 0 : _a.env("traceId"));
  const cookieObservableSubscription = cookieObservable.subscribe((value) => {
    testExecutionId = value;
  });
  hooks.register(0, ({ eventType }) => {
    if (typeof testExecutionId !== "string") {
      return SKIPPED;
    }
    return {
      type: eventType,
      session: {
        type: "ci_test"
      },
      ci_test: {
        test_execution_id: testExecutionId
      }
    };
  });
  return {
    stop: () => {
      cookieObservableSubscription.unsubscribe();
    }
  };
}

// node_modules/@datadog/browser-rum-core/esm/domain/longAnimationFrame/longAnimationFrameCollection.js
function startLongAnimationFrameCollection(lifeCycle, configuration) {
  const performanceResourceSubscription = createPerformanceObservable(configuration, {
    type: RumPerformanceEntryType.LONG_ANIMATION_FRAME,
    buffered: true
  }).subscribe((entries) => {
    for (const entry of entries) {
      const startClocks = relativeToClocks(entry.startTime);
      const rawRumEvent = {
        date: startClocks.timeStamp,
        long_task: {
          id: generateUUID(),
          entry_type: "long-animation-frame",
          duration: toServerDuration(entry.duration),
          blocking_duration: toServerDuration(entry.blockingDuration),
          first_ui_event_timestamp: toServerDuration(entry.firstUIEventTimestamp),
          render_start: toServerDuration(entry.renderStart),
          style_and_layout_start: toServerDuration(entry.styleAndLayoutStart),
          start_time: toServerDuration(entry.startTime),
          scripts: entry.scripts.map((script) => ({
            duration: toServerDuration(script.duration),
            pause_duration: toServerDuration(script.pauseDuration),
            forced_style_and_layout_duration: toServerDuration(script.forcedStyleAndLayoutDuration),
            start_time: toServerDuration(script.startTime),
            execution_start: toServerDuration(script.executionStart),
            source_url: script.sourceURL,
            source_function_name: script.sourceFunctionName,
            source_char_position: script.sourceCharPosition,
            invoker: script.invoker,
            invoker_type: script.invokerType,
            window_attribution: script.windowAttribution
          }))
        },
        type: "long_task",
        _dd: {
          discarded: false
        }
      };
      lifeCycle.notify(12, {
        rawRumEvent,
        startTime: startClocks.relative,
        duration: entry.duration,
        domainContext: { performanceEntry: entry }
      });
    }
  });
  return { stop: () => performanceResourceSubscription.unsubscribe() };
}

// node_modules/@datadog/browser-rum-core/esm/domain/longTask/longTaskCollection.js
function startLongTaskCollection(lifeCycle, configuration) {
  const performanceLongTaskSubscription = createPerformanceObservable(configuration, {
    type: RumPerformanceEntryType.LONG_TASK,
    buffered: true
  }).subscribe((entries) => {
    for (const entry of entries) {
      if (entry.entryType !== RumPerformanceEntryType.LONG_TASK) {
        break;
      }
      if (!configuration.trackLongTasks) {
        break;
      }
      const startClocks = relativeToClocks(entry.startTime);
      const rawRumEvent = {
        date: startClocks.timeStamp,
        long_task: {
          id: generateUUID(),
          entry_type: "long-task",
          duration: toServerDuration(entry.duration)
        },
        type: "long_task",
        _dd: {
          discarded: false
        }
      };
      lifeCycle.notify(12, {
        rawRumEvent,
        startTime: startClocks.relative,
        duration: entry.duration,
        domainContext: { performanceEntry: entry }
      });
    }
  });
  return {
    stop() {
      performanceLongTaskSubscription.unsubscribe();
    }
  };
}

// node_modules/@datadog/browser-rum-core/esm/domain/contexts/syntheticsContext.js
function startSyntheticsContext(hooks) {
  hooks.register(0, ({ eventType }) => {
    if (!isSyntheticsTest()) {
      return SKIPPED;
    }
    const testId = getSyntheticsTestId();
    const resultId = getSyntheticsResultId();
    return {
      type: eventType,
      session: {
        type: "synthetics"
      },
      synthetics: {
        test_id: testId,
        result_id: resultId,
        injected: willSyntheticsInjectRum()
      }
    };
  });
}

// node_modules/@datadog/browser-rum-core/esm/domain/limitModification.js
function limitModification(object, modifiableFieldPaths, modifier) {
  const clone = deepClone(object);
  const result = modifier(clone);
  objectEntries(modifiableFieldPaths).forEach(([fieldPath, fieldType]) => (
    // Traverse both object and clone simultaneously up to the path and apply the modification from the clone to the original object when the type is valid
    setValueAtPath(object, clone, fieldPath.split(/\.|(?=\[\])/), fieldType)
  ));
  return result;
}
function setValueAtPath(object, clone, pathSegments, fieldType) {
  const [field, ...restPathSegments] = pathSegments;
  if (field === "[]") {
    if (Array.isArray(object) && Array.isArray(clone)) {
      object.forEach((item, i) => setValueAtPath(item, clone[i], restPathSegments, fieldType));
    }
    return;
  }
  if (!isValidObject(object) || !isValidObject(clone)) {
    return;
  }
  if (restPathSegments.length > 0) {
    return setValueAtPath(object[field], clone[field], restPathSegments, fieldType);
  }
  setNestedValue(object, field, clone[field], fieldType);
}
function setNestedValue(object, field, value, fieldType) {
  const newType = getType(value);
  if (newType === fieldType) {
    object[field] = sanitize(value);
  } else if (fieldType === "object" && (newType === "undefined" || newType === "null")) {
    object[field] = {};
  }
}
function isValidObject(object) {
  return getType(object) === "object";
}

// node_modules/@datadog/browser-rum-core/esm/domain/assembly.js
var VIEW_MODIFIABLE_FIELD_PATHS = {
  "view.name": "string",
  "view.url": "string",
  "view.referrer": "string"
};
var USER_CUSTOMIZABLE_FIELD_PATHS = {
  context: "object"
};
var ROOT_MODIFIABLE_FIELD_PATHS = {
  service: "string",
  version: "string"
};
var modifiableFieldPathsByEvent;
function startRumAssembly(configuration, lifeCycle, hooks, reportError) {
  modifiableFieldPathsByEvent = {
    [
      "view"
      /* RumEventType.VIEW */
    ]: {
      "view.performance.lcp.resource_url": "string",
      ...USER_CUSTOMIZABLE_FIELD_PATHS,
      ...VIEW_MODIFIABLE_FIELD_PATHS,
      ...ROOT_MODIFIABLE_FIELD_PATHS
    },
    [
      "error"
      /* RumEventType.ERROR */
    ]: {
      "error.message": "string",
      "error.stack": "string",
      "error.resource.url": "string",
      "error.fingerprint": "string",
      ...USER_CUSTOMIZABLE_FIELD_PATHS,
      ...VIEW_MODIFIABLE_FIELD_PATHS,
      ...ROOT_MODIFIABLE_FIELD_PATHS
    },
    [
      "resource"
      /* RumEventType.RESOURCE */
    ]: {
      "resource.url": "string",
      ...isExperimentalFeatureEnabled(ExperimentalFeature.WRITABLE_RESOURCE_GRAPHQL) ? { "resource.graphql": "object" } : {},
      ...USER_CUSTOMIZABLE_FIELD_PATHS,
      ...VIEW_MODIFIABLE_FIELD_PATHS,
      ...ROOT_MODIFIABLE_FIELD_PATHS
    },
    [
      "action"
      /* RumEventType.ACTION */
    ]: {
      "action.target.name": "string",
      ...USER_CUSTOMIZABLE_FIELD_PATHS,
      ...VIEW_MODIFIABLE_FIELD_PATHS,
      ...ROOT_MODIFIABLE_FIELD_PATHS
    },
    [
      "long_task"
      /* RumEventType.LONG_TASK */
    ]: {
      "long_task.scripts[].source_url": "string",
      "long_task.scripts[].invoker": "string",
      ...USER_CUSTOMIZABLE_FIELD_PATHS,
      ...VIEW_MODIFIABLE_FIELD_PATHS
    },
    [
      "vital"
      /* RumEventType.VITAL */
    ]: {
      ...USER_CUSTOMIZABLE_FIELD_PATHS,
      ...VIEW_MODIFIABLE_FIELD_PATHS
    }
  };
  const eventRateLimiters = {
    [
      "error"
      /* RumEventType.ERROR */
    ]: createEventRateLimiter("error", configuration.eventRateLimiterThreshold, reportError),
    [
      "action"
      /* RumEventType.ACTION */
    ]: createEventRateLimiter("action", configuration.eventRateLimiterThreshold, reportError),
    [
      "vital"
      /* RumEventType.VITAL */
    ]: createEventRateLimiter("vital", configuration.eventRateLimiterThreshold, reportError)
  };
  lifeCycle.subscribe(12, ({ startTime, duration, rawRumEvent, domainContext, customerContext }) => {
    const defaultRumEventAttributes = hooks.triggerHook(0, {
      eventType: rawRumEvent.type,
      startTime,
      duration
    });
    if (defaultRumEventAttributes === DISCARDED) {
      return;
    }
    const serverRumEvent = combine(defaultRumEventAttributes, { context: customerContext }, rawRumEvent);
    if (shouldSend(serverRumEvent, configuration.beforeSend, domainContext, eventRateLimiters)) {
      if (isEmptyObject(serverRumEvent.context)) {
        delete serverRumEvent.context;
      }
      lifeCycle.notify(13, serverRumEvent);
    }
  });
}
function shouldSend(event, beforeSend, domainContext, eventRateLimiters) {
  var _a;
  if (beforeSend) {
    const result = limitModification(event, modifiableFieldPathsByEvent[event.type], (event2) => beforeSend(event2, domainContext));
    if (result === false && event.type !== "view") {
      return false;
    }
    if (result === false) {
      display.warn("Can't dismiss view events using beforeSend!");
    }
  }
  const rateLimitReached = (_a = eventRateLimiters[event.type]) === null || _a === void 0 ? void 0 : _a.isLimitReached();
  return !rateLimitReached;
}

// node_modules/@datadog/browser-rum-core/esm/domain/contexts/sessionContext.js
function startSessionContext(hooks, sessionManager, recorderApi, viewHistory) {
  hooks.register(0, ({ eventType, startTime }) => {
    const session = sessionManager.findTrackedSession(startTime);
    const view = viewHistory.findView(startTime);
    if (!session || !view) {
      return DISCARDED;
    }
    let hasReplay;
    let sampledForReplay;
    let isActive;
    if (eventType === "view") {
      hasReplay = recorderApi.getReplayStats(view.id) ? true : void 0;
      sampledForReplay = session.sessionReplay === 1;
      isActive = view.sessionIsActive ? void 0 : false;
    } else {
      hasReplay = recorderApi.isRecording() ? true : void 0;
    }
    return {
      type: eventType,
      session: {
        id: session.id,
        type: "user",
        has_replay: hasReplay,
        sampled_for_replay: sampledForReplay,
        is_active: isActive
      }
    };
  });
}

// node_modules/@datadog/browser-rum-core/esm/domain/contexts/connectivityContext.js
function startConnectivityContext(hooks) {
  hooks.register(0, ({ eventType }) => ({
    type: eventType,
    connectivity: getConnectivity()
  }));
}

// node_modules/@datadog/browser-rum-core/esm/domain/contexts/defaultContext.js
function startDefaultContext(hooks, configuration, sdkName) {
  hooks.register(0, ({ eventType }) => ({
    type: eventType,
    _dd: {
      format_version: 2,
      drift: currentDrift(),
      configuration: {
        session_sample_rate: round(configuration.sessionSampleRate, 3),
        session_replay_sample_rate: round(configuration.sessionReplaySampleRate, 3)
      },
      browser_sdk_version: canUseEventBridge() ? "6.12.3" : void 0,
      sdk_name: sdkName
    },
    application: {
      id: configuration.applicationId
    },
    date: timeStampNow(),
    source: "browser"
  }));
}

// node_modules/@datadog/browser-rum-core/esm/domain/hooks.js
var createHooks = abstractHooks;

// node_modules/@datadog/browser-rum-core/esm/boot/startRum.js
function startRum(configuration, recorderApi, profilerApi, initialViewOptions, createEncoder, trackingConsentState, customVitalsState, sdkName) {
  const cleanupTasks = [];
  const lifeCycle = new LifeCycle();
  const hooks = createHooks();
  lifeCycle.subscribe(13, (event) => sendToExtension("rum", event));
  const reportError = (error) => {
    lifeCycle.notify(14, { error });
    addTelemetryDebug("Error reported to customer", { "error.message": error.message });
  };
  const pageMayExitObservable = createPageMayExitObservable(configuration);
  const pageMayExitSubscription = pageMayExitObservable.subscribe((event) => {
    lifeCycle.notify(11, event);
  });
  cleanupTasks.push(() => pageMayExitSubscription.unsubscribe());
  const telemetry = startTelemetry("browser-rum-sdk", configuration, reportError, pageMayExitObservable, createEncoder);
  cleanupTasks.push(telemetry.stop);
  telemetry.setContextProvider("application.id", () => configuration.applicationId);
  const session = !canUseEventBridge() ? startRumSessionManager(configuration, lifeCycle, trackingConsentState) : startRumSessionManagerStub();
  telemetry.setContextProvider("session.id", () => {
    var _a;
    return (_a = session.findTrackedSession()) === null || _a === void 0 ? void 0 : _a.id;
  });
  telemetry.setContextProvider("usr.anonymous_id", () => {
    var _a;
    return (_a = session.findTrackedSession()) === null || _a === void 0 ? void 0 : _a.anonymousId;
  });
  if (!canUseEventBridge()) {
    const batch = startRumBatch(configuration, lifeCycle, reportError, pageMayExitObservable, session.expireObservable, createEncoder);
    cleanupTasks.push(() => batch.stop());
    startCustomerDataTelemetry(configuration, telemetry, lifeCycle, batch.flushObservable);
  } else {
    startRumEventBridge(lifeCycle);
  }
  const domMutationObservable = createDOMMutationObservable();
  const locationChangeObservable = createLocationChangeObservable(configuration, location);
  const { observable: windowOpenObservable, stop: stopWindowOpen } = createWindowOpenObservable();
  cleanupTasks.push(stopWindowOpen);
  startDefaultContext(hooks, configuration, sdkName);
  const pageStateHistory = startPageStateHistory(hooks, configuration);
  const viewHistory = startViewHistory(lifeCycle);
  cleanupTasks.push(() => viewHistory.stop());
  telemetry.setContextProvider("view.id", () => {
    var _a;
    return (_a = viewHistory.findView()) === null || _a === void 0 ? void 0 : _a.id;
  });
  const urlContexts = startUrlContexts(lifeCycle, hooks, locationChangeObservable, location);
  cleanupTasks.push(() => urlContexts.stop());
  const featureFlagContexts = startFeatureFlagContexts(lifeCycle, hooks, configuration);
  startSessionContext(hooks, session, recorderApi, viewHistory);
  startConnectivityContext(hooks);
  const globalContext = startGlobalContext(hooks, configuration, "rum", true);
  const userContext = startUserContext(hooks, configuration, session, "rum");
  const accountContext = startAccountContext(hooks, configuration, "rum");
  const { actionContexts, addAction, stop: stopRumEventCollection } = startRumEventCollection(lifeCycle, hooks, configuration, pageStateHistory, domMutationObservable, windowOpenObservable, reportError);
  cleanupTasks.push(stopRumEventCollection);
  telemetry.setContextProvider("action.id", () => actionContexts.findActionId());
  const { addTiming, startView, setViewName, setViewContext, setViewContextProperty, getViewContext, stop: stopViewCollection } = startViewCollection(lifeCycle, hooks, configuration, location, domMutationObservable, windowOpenObservable, locationChangeObservable, recorderApi, viewHistory, initialViewOptions);
  cleanupTasks.push(stopViewCollection);
  const { stop: stopResourceCollection } = startResourceCollection(lifeCycle, configuration, pageStateHistory);
  cleanupTasks.push(stopResourceCollection);
  if (configuration.trackLongTasks) {
    if (supportPerformanceTimingEvent(RumPerformanceEntryType.LONG_ANIMATION_FRAME)) {
      const { stop: stopLongAnimationFrameCollection } = startLongAnimationFrameCollection(lifeCycle, configuration);
      cleanupTasks.push(stopLongAnimationFrameCollection);
    } else {
      startLongTaskCollection(lifeCycle, configuration);
    }
  }
  const { addError } = startErrorCollection(lifeCycle, configuration);
  startRequestCollection(lifeCycle, configuration, session, userContext, accountContext);
  const vitalCollection = startVitalCollection(lifeCycle, pageStateHistory, customVitalsState);
  const internalContext = startInternalContext(configuration.applicationId, session, viewHistory, actionContexts, urlContexts);
  cleanupTasks.push(() => profilerApi.stop());
  return {
    addAction,
    addError,
    addTiming,
    addFeatureFlagEvaluation: featureFlagContexts.addFeatureFlagEvaluation,
    startView,
    setViewContext,
    setViewContextProperty,
    getViewContext,
    setViewName,
    lifeCycle,
    viewHistory,
    session,
    stopSession: () => session.expire(),
    getInternalContext: internalContext.get,
    startDurationVital: vitalCollection.startDurationVital,
    stopDurationVital: vitalCollection.stopDurationVital,
    addDurationVital: vitalCollection.addDurationVital,
    globalContext,
    userContext,
    accountContext,
    stop: () => {
      cleanupTasks.forEach((task) => task());
    }
  };
}
function startRumEventCollection(lifeCycle, hooks, configuration, pageStateHistory, domMutationObservable, windowOpenObservable, reportError) {
  const actionCollection = startActionCollection(lifeCycle, hooks, domMutationObservable, windowOpenObservable, configuration);
  const displayContext = startDisplayContext(hooks, configuration);
  const ciVisibilityContext = startCiVisibilityContext(configuration, hooks);
  startSyntheticsContext(hooks);
  startRumAssembly(configuration, lifeCycle, hooks, reportError);
  return {
    pageStateHistory,
    addAction: actionCollection.addAction,
    actionContexts: actionCollection.actionContexts,
    stop: () => {
      actionCollection.stop();
      ciVisibilityContext.stop();
      displayContext.stop();
      pageStateHistory.stop();
    }
  };
}

// node_modules/@datadog/browser-rum-core/esm/domain/getSessionReplayUrl.js
function getSessionReplayUrl(configuration, { session, viewContext, errorType }) {
  const sessionId = session ? session.id : "no-session-id";
  const parameters = [];
  if (errorType !== void 0) {
    parameters.push(`error-type=${errorType}`);
  }
  if (viewContext) {
    parameters.push(`seed=${viewContext.id}`);
    parameters.push(`from=${viewContext.startClocks.timeStamp}`);
  }
  const origin = getDatadogSiteUrl(configuration);
  const path = `/rum/replay/sessions/${sessionId}`;
  return `${origin}${path}?${parameters.join("&")}`;
}
function getDatadogSiteUrl(rumConfiguration) {
  const site = rumConfiguration.site;
  const subdomain = rumConfiguration.subdomain || getSiteDefaultSubdomain(rumConfiguration);
  return `https://${subdomain ? `${subdomain}.` : ""}${site}`;
}
function getSiteDefaultSubdomain(configuration) {
  switch (configuration.site) {
    case INTAKE_SITE_US1:
    case INTAKE_SITE_EU1:
      return "app";
    case INTAKE_SITE_STAGING:
      return "dd";
    default:
      return void 0;
  }
}

export {
  makeRumPublicApi,
  getMutationObserverConstructor,
  sanitizeIfLongDataUrl,
  RumPerformanceEntryType,
  supportPerformanceTimingEvent,
  isNodeShadowHost,
  isNodeShadowRoot,
  hasChildNodes,
  forEachChildNodes,
  getParentNode,
  NodePrivacyLevel,
  PRIVACY_ATTR_NAME,
  PRIVACY_ATTR_VALUE_HIDDEN,
  CENSORED_STRING_MARK,
  CENSORED_IMG_MARK,
  getNodePrivacyLevel,
  reducePrivacyLevel,
  getNodeSelfPrivacyLevel,
  shouldMaskNode,
  getTextContent,
  STABLE_ATTRIBUTES,
  getScrollX,
  getScrollY,
  initViewportObservable,
  getViewportDimension,
  startRum,
  getSessionReplayUrl
};
//# sourceMappingURL=chunk-ATFHSDKA.js.map
